/**
 * @file CacheManager.js
 * @description A centralized manager for creating and monitoring all LRUCache instances in the application.
 * This ensures that all caches are integrated with core systems like metrics and security.
 */

import { LRUCache } from "../utils/LRUCache.js";
import { ForensicLogger } from '@core/security/ForensicLogger.js';

/**
 * @class CacheManager
 * @description Manages the lifecycle of all LRUCache instances. It acts as a factory
 * that automatically injects shared dependencies into each new cache.
 * @privateFields {#caches, #stateManager, #metrics, #errorHelpers}
 */
export class CacheManager {
	/** @private @type {Map<string, LRUCache>} */
	#caches = new Map();
	/** @private @type {import('../core/HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers;

	/**
	 * Creates an instance of CacheManager.
	 * @param {object} context - The global application context.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: The stateManager is the single source of truth for all dependencies.
		this.#stateManager = stateManager;
		this.#metrics = stateManager.metricsRegistry?.namespace("cacheManager");
		this.#errorHelpers = stateManager.managers.errorHelpers;
	}

	/**
	 * Retrieves an existing cache by name or creates a new one if it doesn't exist.
	 * @param {string} name - The unique name for the cache (e.g., 'entities', 'sessions').
	 * @param {number|object} [maxSizeOrOptions=1000] - Either the max size (number) or an options object.
	 * @param {object} [maybeOptions={}] - Additional LRUCache options when the second arg is a number.
	 * @returns {LRUCache} The existing or newly created LRUCache instance.
	 */
	/**

	 * TODO: Add JSDoc for method getCache

	 * @memberof AutoGenerated

	 */

	getCache(name, maxSizeOrOptions = 1000, maybeOptions = {}) {
		if (this.#caches.has(name)) {
			return this.#caches.get(name);
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (!name) {
			const error = new Error("Cache must have a name.");
			this.#errorHelpers?.handleError(error, {
				component: "CacheManager",
				operation: "getCache",
				category: "configuration_error",
			});
			throw error;
		}

		// Normalize arguments: support both (name, maxSize, options) and (name, options)
		let maxSize = 1000;
		let options = {};
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (typeof maxSizeOrOptions === "number") {
			maxSize = maxSizeOrOptions;
			options = maybeOptions || {};
		} else if (maxSizeOrOptions && typeof maxSizeOrOptions === "object") {
			options = maxSizeOrOptions;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof options.max === "number") {
				maxSize = options.max;
			} else if (typeof options.maxSize === "number") {
				maxSize = options.maxSize;
			}
		}

		// Create a new cache, injecting shared dependencies
		const newCache = new LRUCache(
			{
				stateManager: this.#stateManager, // Pass the stateManager directly.
				keyPrefix: name,
				...options,
			},
			maxSize
		);

		this.#caches.set(name, newCache);
		this.#metrics?.increment("cache.created");
		console.log(`[CacheManager] Created new cache: '${name}'`);
		return newCache;
	}

	/**
	 * Retrieves metrics from all managed caches.
	 * @returns {object} An object where keys are cache names and values are their metrics.
	 */
	/**

	 * TODO: Add JSDoc for method getAllMetrics

	 * @memberof AutoGenerated

	 */

	getAllMetrics() {
		const allMetrics = {};
		for (const [name, cache] of this.#caches.entries()) {
			allMetrics[name] = cache.getMetrics();
		}
		return allMetrics;
	}

	/**
	 * Clears all items from all managed caches.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method clearAll

	 * @memberof AutoGenerated

	 */

	clearAll() {
		for (const cache of this.#caches.values()) {
			cache.clear();
		}
		this.#metrics?.increment("cache.cleared.all");
		console.log(`[CacheManager] Cleared all ${this.#caches.size} caches.`);
	}

	/**
	 * Invalidates entries across all caches based on a pattern.
	 * Pattern may be a string (prefix match on unprefixed key) or a RegExp.
	 * If pattern is "*" or falsy, clears all caches.
	 * @param {string|RegExp} pattern
	 */
	/**

	 * TODO: Add JSDoc for method invalidate

	 * @memberof AutoGenerated

	 */

	invalidate(pattern) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!pattern || pattern === "*") {
			this.clearAll();
			return;
		}
		for (const [name, cache] of this.#caches.entries()) {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof cache.invalidate === "function") {
				cache.invalidate(pattern);
			} else if (typeof cache.clear === "function" && typeof pattern === "string" && pattern.startsWith(`${name}:`)) {
				// Fallback: if pattern targets this cache namespace, clear whole cache
				cache.clear();
			}
		}
		this.#metrics?.increment("cache.invalidations");
		console.log(`[CacheManager] Invalidated caches with pattern: ${String(pattern)}`);
	}

	/**
	 * Destroys all managed caches, stopping any background processes.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method destroyAll

	 * @memberof AutoGenerated

	 */

	destroyAll() {
		for (const cache of this.#caches.values()) {
			cache.destroy();
		}
		this.#caches.clear();
		this.#metrics?.increment("cache.destroyed.all");
		console.log(`[CacheManager] Destroyed all caches.`);
	}

	/**
	 * Backwards-compatible alias for creating or retrieving a cache using options object.
	 * @param {string} name
	 * @param {object} options
	 * @returns {LRUCache}
	 */
	/**

	 * TODO: Add JSDoc for method createCache

	 * @memberof AutoGenerated

	 */

	createCache(name, options = {}) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  return this.getCache(name, options);
	}
}

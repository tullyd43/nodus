import { DateCore } from "./DateUtils.js"; // DateCore is now the lean, integrated version

/**
 * @class BoundedStack
 * @description A memory-efficient stack with a fixed capacity. When the stack exceeds its maximum size,
 * the oldest items are automatically evicted. This is ideal for managing undo/redo history
 * or any list of operations where only a limited history is needed.
 *
 * @privateFields {#maxSize, #items, #evictionCount, #stateManager, #metricsRegistry, #name, #AppError}
 * @template T The type of data stored in the stack.
 */
export class BoundedStack {
	// V8.0 Parity: Use private fields for true encapsulation.
	#maxSize;
	#items = [];
	/** @type {number} */
	#evictionCount = 0;
	#stateManager;
	#metricsRegistry;
	#name;

	/**
	 * Creates an instance of BoundedStack.
	 * @param {number} [maxSize=50] - The maximum number of items the stack can hold before evicting the oldest ones.
	 * @param {object} [options={}] - The application context and options.
	 * @param {import('../core/HybridStateManager.js').default} [options.stateManager] - The main state manager.
	 * @param {string} [options.name=""] - A name for the stack, used for namespacing metrics.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(maxSize = 50, { stateManager, ...options } = {}) {
		if (
			typeof maxSize !== "number" ||
			!Number.isInteger(maxSize) ||
			maxSize <= 0
		) {
			// This is a critical configuration error during instantiation.
			// A standard Error is appropriate as `stateManager` and its helpers may not be available yet.
			throw new Error("BoundedStack maxSize must be a positive integer.");
		}

		this.#maxSize = maxSize;

		// V8.0 Parity: Derive all dependencies from the stateManager.
		this.#stateManager = stateManager;
		this.#name = options.name || "unnamed";

		// Use a namespaced registry if provided, otherwise use the main one
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager?.metricsRegistry) {
			this.#metricsRegistry =
				this.#stateManager.metricsRegistry.namespace(
					`stack.${this.#name}`
				);
		}
	}

	/**
	 * Adds an item to the top of the stack.
	 * If the stack's size exceeds `maxSize` after adding, the oldest item is removed.
	 * @param {T} item - The item to add to the stack.
	 * @returns {string} The unique ID generated for the stacked item.
	 */
	/**

	 * TODO: Add JSDoc for method push

	 * @memberof AutoGenerated

	 */

	push(item) {
		// Add timestamp for operation tracking
		const stackItem = {
			data: item,
			timestamp: DateCore.timestamp(),
			id: this.#generateItemId(),
		};

		this.#items.push(stackItem);
		this.#metricsRegistry?.increment("pushes");

		// Evict oldest items if over limit
		/**

		 * TODO: Add JSDoc for method while

		 * @memberof AutoGenerated

		 */

		while (this.#items.length > this.#maxSize) {
			const evicted = this.#items.shift();
			this.#evictionCount++;

			this.#metricsRegistry?.increment("evictions");
			// Notify about eviction for cleanup if a callback is set
			this.#handleEviction(evicted, "capacity");
		}

		return stackItem.id;
	}

	/**
	 * Removes and returns the item at the top of the stack.
	 * @returns {T|undefined} The data from the top item, or undefined if the stack is empty.
	 */
	/**

	 * TODO: Add JSDoc for method pop

	 * @memberof AutoGenerated

	 */

	pop() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#items.length === 0) {
			return undefined;
		}
		const item = this.#items.pop();
		this.#metricsRegistry?.increment("pops");
		return item.data;
	}

	/**
	 * Returns the item at the top of the stack without removing it.
	 * @returns {T|undefined} The data from the top item, or undefined if the stack is empty.
	 */
	/**

	 * TODO: Add JSDoc for method peek

	 * @memberof AutoGenerated

	 */

	peek() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#items.length === 0) {
			return undefined;
		}

		return this.#items[this.#items.length - 1].data;
	}

	/**
	 * Returns the item at a specific index from the top of the stack (0-indexed).
	 * @param {number} index - The index from the top (0 is the most recent item).
	 * @returns {T|undefined} The data of the item at the specified index, or undefined if the index is out of bounds.
	 */
	/**

	 * TODO: Add JSDoc for method peekAt

	 * @memberof AutoGenerated

	 */

	peekAt(index) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (index < 0 || index >= this.#items.length) {
			return undefined;
		}

		const actualIndex = this.#items.length - 1 - index;
		return this.#items[actualIndex].data;
	}

	/**
	 * Checks if the stack is empty.
	 * @returns {boolean} True if the stack has no items, false otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method isEmpty

	 * @memberof AutoGenerated

	 */

	isEmpty() {
		return this.#items.length === 0;
	}

	/**
	 * Checks if the stack has reached its maximum size.
	 * @returns {boolean} True if the stack size is equal to or greater than `maxSize`.
	 */
	/**

	 * TODO: Add JSDoc for method isFull

	 * @memberof AutoGenerated

	 */

	isFull() {
		return this.#items.length >= this.#maxSize;
	}

	/**
	 * Gets the current number of items in the stack.
	 * @type {number}
	 */
	get size() {
		return this.#items.length;
	}

	/**
	 * Gets the number of additional items the stack can hold before it becomes full.
	 * @type {number}
	 */
	get remainingCapacity() {
		return this.#maxSize - this.#items.length;
	}

	/**
	 * Removes all items from the stack.
	 * @returns {number} The number of items that were cleared.
	 */
	/**

	 * TODO: Add JSDoc for method clear

	 * @memberof AutoGenerated

	 */

	clear() {
		const clearedCount = this.#items.length;
		this.#items = [];
		this.#metricsRegistry?.increment("clears", clearedCount);
		return clearedCount;
	}

	/**
	 * Returns the stack's items as an array, with the newest items first.
	 * @returns {T[]} An array containing the data of all items in the stack.
	 */
	/**

	 * TODO: Add JSDoc for method toArray

	 * @memberof AutoGenerated

	 */

	toArray() {
		return this.#items
			.slice()
			.reverse()
			.map((item) => item.data);
	}

	/**
	 * Finds the first item in the stack (from newest to oldest) that satisfies the predicate function.
	 * @param {function(T, number): boolean} predicate - A function to execute on each item's data and index.
	 * It should return a truthy value to indicate a match.
	 * @returns {T|undefined} The data of the first item that matches the predicate, or undefined if no match is found.
	 */
	/**

	 * TODO: Add JSDoc for method find

	 * @memberof AutoGenerated

	 */

	find(predicate) {
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let i = this.#items.length - 1; i >= 0; i--) {
			const item = this.#items[i];
			if (predicate(item.data, this.#items.length - 1 - i)) {
				return item.data;
			}
		}
		return undefined;
	}

	/**
	 * Creates a new array with all items in the stack that pass the test implemented by the provided predicate function.
	 * @param {function(T, number): boolean} predicate - A function to test each item's data and index.
	 * Return true to keep the element, false otherwise.
	 * @returns {T[]} A new array with the items that pass the test.
	 */
	/**

	 * TODO: Add JSDoc for method filter

	 * @memberof AutoGenerated

	 */

	filter(predicate) {
		return this.#items
			.slice()
			.reverse()
			.map((item, index) => ({ data: item.data, index }))
			.filter(({ data, index }) => predicate(data, index))
			.map(({ data }) => data);
	}

	/**
	 * Retrieves performance and usage metrics for the stack.
	 * @returns {object} An object containing metrics like size, utilization, eviction count, and memory estimates.
	 */
	/**

	 * TODO: Add JSDoc for method getMetrics

	 * @memberof AutoGenerated

	 */

	getMetrics() {
		return {
			size: this.#items.length,
			maxSize: this.#maxSize,
			utilizationPercent: Math.round(
				(this.#items.length / this.#maxSize) * 100
			),
			evictionCount: this.#evictionCount,
			oldestItemAge:
				this.#items.length > 0
					? DateCore.timestamp() - this.#items[0].timestamp
					: 0,
			newestItemAge:
				this.#items.length > 0
					? DateCore.timestamp() -
						this.#items[this.#items.length - 1].timestamp
					: 0,
		};
	}

	/**
	 * Generates a unique ID for a stack item.
	 * @private
	 * @returns {string} A unique identifier string.
	 */
	#generateItemId() {
		return `stk_${crypto.randomUUID()}`;
	}

	/**
	 * Pushes multiple items onto the stack in a batch.
	 * @param {T[]} items - An array of items to push.
	 * @returns {string[]} An array of unique IDs for the newly added items.
	 */
	/**

	 * TODO: Add JSDoc for method pushMultiple

	 * @memberof AutoGenerated

	 */

	pushMultiple(items) {
		const ids = [];
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const item of items) {
			ids.push(this.push(item));
		}
		return ids;
	}

	/**
	 * Pops a specified number of items from the top of the stack.
	 * @param {number} count - The number of items to pop.
	 * @returns {T[]} An array of the popped items' data, with the most recent item first.
	 */
	/**

	 * TODO: Add JSDoc for method popMultiple

	 * @memberof AutoGenerated

	 */

	popMultiple(count) {
		const items = [];
		for (let i = 0; i < count && !this.isEmpty(); i++) {
			items.push(this.pop());
		}
		return items;
	}

	/**
	 * Trims the stack to a new, smaller size by removing the oldest items.
	 * @param {number} newSize - The target size for the stack.
	 * @returns {number} The number of items removed.
	 */
	/**

	 * TODO: Add JSDoc for method trimTo

	 * @memberof AutoGenerated

	 */

	trimTo(newSize) {
		if (newSize >= this.#items.length) return 0;

		const removeCount = this.#items.length - newSize;
		const removed = this.#items.splice(0, removeCount);
		this.#evictionCount += removed.length;
		removed.forEach((item) => this.#handleEviction(item, "trim"));
		this.#metricsRegistry?.increment("evictions", removed.length);

		return removed.length;
	}

	/**
	 * Retrieves items from the stack that were pushed within a specific time range.
	 * @param {number} startTime - The start of the time range (Unix timestamp).
	 * @param {number} endTime - The end of the time range (Unix timestamp).
	 * @returns {T[]} An array of item data within the time range, newest first.
	 */
	/**

	 * TODO: Add JSDoc for method getItemsInTimeRange

	 * @memberof AutoGenerated

	 */

	getItemsInTimeRange(startTime, endTime) {
		return this.#items
			.filter(
				(item) =>
					item.timestamp >= startTime && item.timestamp <= endTime
			)
			.map((item) => item.data)
			.reverse(); // Newest first
	}

	/**
	 * Removes all items from the stack that are older than a specified maximum age.
	 * @param {number} maxAge - The maximum age in milliseconds.
	 * @returns {number} The number of items removed.
	 */
	/**

	 * TODO: Add JSDoc for method removeItemsOlderThan

	 * @memberof AutoGenerated

	 */

	removeItemsOlderThan(maxAge) {
		const cutoffTime = DateCore.timestamp() - maxAge;
		let removeCount = 0;

		/**


		 * TODO: Add JSDoc for method while


		 * @memberof AutoGenerated


		 */

		while (
			this.#items.length > 0 &&
			this.#items[0].timestamp < cutoffTime
		) {
			const evicted = this.#items.shift();
			removeCount++;
			this.#evictionCount++; // Already incremented above
			this.#handleEviction(evicted, "age");
			this.#metricsRegistry?.increment("evictions", removeCount);
		}

		return removeCount;
	}

	/**
	 * Handles the eviction of an item, invoking the callback and emitting an event.
	 * @private
	 * @param {object} evictedItem - The item that was evicted.
	 * @param {string} reason - The reason for eviction ('capacity', 'trim', 'age').
	 */
	#handleEviction(evictedItem, reason) {
		const eventPayload = {
			timestamp: DateCore.now(),
			source: `stack:${this.#name}`,
			reason,
			item: evictedItem,
		};

		// V8.0 Parity: Emit to the central stateManager event bus.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager) {
			this.#stateManager.emit("stack_eviction", eventPayload);

			// Mandate 2.4: If the forensic logger is available, create an audit event.
			// This is useful for debugging complex state changes and potential data loss.
			const forensicLogger = this.#stateManager.managers?.forensicLogger;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (forensicLogger) {
				forensicLogger.logAuditEvent(
					"STACK_ITEM_EVICTED",
					eventPayload
				);
			}
		}
	}
}

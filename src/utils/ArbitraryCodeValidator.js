/**
 * @file ArbitraryCodeValidator.js
 * @description Utility to scan JavaScript code for forbidden, potentially unsafe patterns.
 * This is a critical component for enforcing Mandate 2.1.
 * @see {@link d:\Development Files\repositories\nodus\DEVELOPER_MANDATES.md} - Mandate 2.1
 */

/**
 * @typedef {object} CodeViolation
 * @property {string} message - A description of the violation.
 * @property {'critical'|'warning'} severity - The severity of the violation.
 * @property {number} line - The line number where the violation occurred.
 * @property {number} column - The column number where the violation occurred.
 * @property {string} pattern - The string representation of the regex pattern that was matched.
 */

/**
 * @class ArbitraryCodeValidator
 * @classdesc Scans JavaScript code for forbidden patterns that could lead to security vulnerabilities.
 */
export class ArbitraryCodeValidator {
	/**
	 * A map of forbidden patterns, their severity, and a descriptive message.
	 * The regex patterns are designed to be more robust than simple string matching.
	 * @private
	 * @type {Map<RegExp, {message: string, severity: 'critical'|'warning'}>}
	 */
	#patterns = new Map([
		[
			// Matches `eval(...)` but avoids matching it inside comments or as part of another word.
			/(?<!\/\/\s*)\b(eval)\s*\(/g,
			{ message: "Use of eval() is forbidden.", severity: "critical" },
		],
		[
			// Matches `new Function(...)` but avoids matching it inside comments.
			/(?<!\/\/\s*)\bnew\s+Function\s*\(/g,
			{
				message: "Use of new Function() is forbidden.",
				severity: "critical",
			},
		],
		[
			// Matches `setTimeout('...')`, `setTimeout("...")`, and `setTimeout(`...`)`.
			/(?<!\/\/\s*)\bsetTimeout\s*\(\s*(["'`])/g,
			{
				message:
					"Use of setTimeout with a string argument is forbidden.",
				severity: "critical",
			},
		],
		[
			// Matches `.innerHTML = someVariable` but not `.innerHTML = "a static string"`.
			// This targets the unsafe dynamic assignment.
			/\.innerHTML\s*=\s*(?![`"'])/g,
			{
				message:
					"Direct assignment to innerHTML with a variable is forbidden. Use textContent or a sanitization library.",
				severity: "warning",
			},
		],
	]);

	/**
	 * Scans a string of code for forbidden patterns and returns detailed violation info.
	 * @param {string} codeString - The JavaScript code to scan.
	 * @returns {CodeViolation[]} An array of violation objects, including line and column numbers.
	 */
	/**

	 * TODO: Add JSDoc for method scan

	 * @memberof AutoGenerated

	 */

	scan(codeString) {
		const violations = [];
		const lines = codeString.split("\n");

		for (const [pattern, details] of this.#patterns.entries()) {
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				let match;
				// We need to re-run exec to find all matches in a line
				while ((match = pattern.exec(line)) !== null) {
					violations.push({
						...details,
						line: i + 1,
						column: match.index + 1,
						pattern: pattern.toString(),
					});
				}
			}
		}
		return violations;
	}

	/**
	 * Validates the code string and throws a SecurityError if any critical violations are found.
	 * This is the primary method to be used for runtime checks.
	 * @param {string} codeString - The JavaScript code to validate.
	 * @param {object} context - The context object, which may contain error helpers.
	 * @param {import('./ErrorHelpers.js').ErrorHelpers} [context.errorHelpers] - The centralized error helper instance.
	 * @throws {Error} A SecurityError (or standard Error) if a critical violation is found.
	 */
	/**

	 * TODO: Add JSDoc for method validate

	 * @memberof AutoGenerated

	 */

	validate(codeString, context = {}) {
		const violations = this.scan(codeString);
		const criticalViolations = violations.filter(
			(v) => v.severity === "critical"
		);

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (criticalViolations.length > 0) {
			const firstViolation = criticalViolations[0];
			const message = `Security validation failed: ${firstViolation.message} (at line ${firstViolation.line}:${firstViolation.column})`;

			// V8 Parity: Use the centralized error system if available.
			const SecurityError =
				context.errorHelpers?.SecurityError ||
				context.errorHelpers?.AppError ||
				Error;

			throw new SecurityError(message, {
				category: "security_violation",
				severity: "critical",
				showToUser: false, // This is a developer-facing error
				violations: criticalViolations,
			});
		}
	}
}

/**
 * Scans a string of code for forbidden patterns using an instance of ArbitraryCodeValidator.
 * This is the primary export for simple scanning operations.
 * @param {string} codeString - The JavaScript code to scan.
 * @returns {CodeViolation[]} An array of violation objects.
 */
/**
 * TODO: Add JSDoc for function scanForForbiddenPatterns
 * @memberof AutoGenerated
 */
export function scanForForbiddenPatterns(codeString) {
	const validator = new ArbitraryCodeValidator();
	return validator.scan(codeString);
}

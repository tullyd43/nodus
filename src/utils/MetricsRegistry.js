// src/utils/MetricsRegistry.js

import { AppError } from "./ErrorHelpers.js";

/**
 * @class MetricsRegistry
 * @description A centralized, in-memory registry for application-wide metrics.
 * It supports counters, timers for performance measurement, and histograms for value distribution.
 * This provides a lightweight but powerful way to track events, performance, and data patterns.
 *
 * @privateFields {#prefix, #stateManager, #cache, #errorHelpers, #AppError, #maxMetrics}
 */
export class MetricsRegistry {
	// V8.0 Parity: Mandate 3.1 - All internal properties are private.
	/** @private @type {string} */
	#prefix = "";
	/** @private @type {import('../core/HybridStateManager.js').default|null} */
	#stateManager = null;
	/** @private @type {import('./LRUCache.js').LRUCache|null} */
	#cache = null;
	/** @private @type {import('./ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {typeof AppError} */
	#AppError = AppError;
	/** @private @type {number} */
	#maxMetrics = 500; // Default max number of unique metrics to prevent memory leaks.

	/**
	 * Creates an instance of MetricsRegistry.
	 * @param {object} context - The application context.
	 * @param {import('../core/HybridStateManager.js').default} [context.stateManager] - The main state manager instance.
	 * @param {string} [context.prefix=""] - A global prefix for all metric names.
	 * @param {number} [context.maxMetrics=500] - The maximum number of unique metrics to store.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager = null, prefix = "", maxMetrics = 500 } = {}) {
		this.#prefix = prefix;
		this.#maxMetrics = maxMetrics;
		this.#stateManager = stateManager;

		// V8.0 Parity: Mandate 1.2 - Derive dependencies from the stateManager.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager) {
			this.#errorHelpers = this.#stateManager.managers.errorHelpers;
			this.#AppError = this.#errorHelpers?.AppError || AppError;

			// V8.0 Parity: Mandate 4.1 - Use a bounded cache for metrics.
			const cacheManager = this.#stateManager.managers.cacheManager;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (cacheManager) {
				// Avoid recursive instrumentation by disabling metrics inside metrics cache
				this.#cache = cacheManager.createCache(
					`metrics:${prefix || "global"}`,
					{
						maxSize: this.#maxMetrics,
						enableMetrics: false,
					}
				);
			}
		}

		// Fallback to a simple Map if no stateManager/CacheManager is provided (e.g., in tests).
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#cache) {
			this.#cache = new Map();
			console.warn(
				`[MetricsRegistry] No CacheManager found. Using an unbounded Map. This is not recommended for production.`
			);
		}
	}

	/**
	 * Increments the value of a given metric by a specified amount.
	 * If the metric does not exist, it is initialized to the given value.
	 * @param {string} metricName - The name of the metric to increment (e.g., 'cache_hits').
	 * @param {number} [amount=1] - The amount to add to the counter.
	 * @param {object} [metadata={}] - Optional metadata like units.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method increment

	 * @memberof AutoGenerated

	 */

	increment(metricName, amount = 1, metadata = {}) {
		const key = this.#prefix + metricName;
		const metric = this.#cache.get(key) || {
			type: "counter",
			value: 0,
			...metadata,
		};
		metric.value += amount;
		this.#cache.set(key, metric);
	}

	/**
	 * Records a timing measurement for an operation.
	 * @param {string} metricName - The name of the timer metric (e.g., 'db_query_duration').
	 * @param {number} duration - The duration of the operation in milliseconds.
	 * @param {object} [tags={}] - Optional tags to associate with the metric.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method timer

	 * @memberof AutoGenerated

	 */

	timer(metricName, duration, tags = {}) {
		const key = this.#prefix + metricName;
		const metric = this.#cache.get(key) || {
			type: "timer",
			unit: "ms",
			count: 0,
			total: 0,
			min: Infinity,
			max: -Infinity,
			avg: 0,
			...tags,
		};

		metric.count++;
		metric.total += duration;
		metric.min = Math.min(metric.min, duration);
		metric.max = Math.max(metric.max, duration);
		metric.avg = metric.total / metric.count;
		this.#cache.set(key, metric);
	}

	/**
	 * Adds a value to a histogram, tracking its distribution.
	 * @param {string} metricName - The name of the histogram metric (e.g., 'request_payload_size').
	 * @param {number} value - The value to record.
	 * @param {object} [tags={}] - Optional metadata like units.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method histogram

	 * @memberof AutoGenerated

	 */

	histogram(metricName, value, tags = {}) {
		const key = this.#prefix + metricName;
		const metric = this.#cache.get(key) || {
			type: "histogram",
			count: 0,
			total: 0,
			min: Infinity,
			max: -Infinity,
			avg: 0,
			...tags,
		};

		metric.count++;
		metric.total += value;
		metric.min = Math.min(metric.min, value);
		metric.max = Math.max(metric.max, value);
		metric.avg = metric.total / metric.count;
		this.#cache.set(key, metric);
	}

	/**
	 * Sets the value of a gauge metric. Gauges are useful for values that can go up or down.
	 * @param {string} metricName - The name of the gauge metric (e.g., 'cache_size').
	 * @param {number} value - The value to set.
	 * @param {object} [tags={}] - Optional metadata like units.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method set

	 * @memberof AutoGenerated

	 */

	set(metricName, value, tags = {}) {
		const key = this.#prefix + metricName;
		const metric = this.#cache.get(key) || { type: "gauge", ...tags };
		metric.value = value;
		this.#cache.set(key, metric);
	}

	/**
	 * A higher-order function that returns a decorator to measure the execution time of a method.
	 * This aligns with Mandate 4.3 for standardized performance metric reporting.
	 * @param {string} metricName - The name for the timer metric.
	 * @param {object} [tags={}] - Optional tags to associate with the metric.
	 * @returns {function(Function): Function} A function that takes a method and returns a wrapped version of it.
	 * @example
	 * // In a class constructor:
	 * this.criticalOperation = this.#metricsRegistry.measure('critical_op')(this.criticalOperation.bind(this));
	 */
	/**

	 * TODO: Add JSDoc for method measure

	 * @memberof AutoGenerated

	 */

	measure(metricName, tags = {}) {
		const registry = this; // may be undefined if called unbound; handle with optional chaining
		return (originalMethod) =>
			(...args) => {
				const startTime = performance.now();
				try {
					const result = originalMethod(...args);
					// Handle async methods
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (result && typeof result.then === "function") {
						return result.finally(() => {
							const duration = performance.now() - startTime;
							registry?.timer(metricName, duration, tags);
						});
					}
					// Handle sync methods
					const duration = performance.now() - startTime;
					registry?.timer(metricName, duration, tags);
					return result;
				} catch (error) {
					const duration = performance.now() - startTime;
					registry?.timer(metricName, duration, { ...tags, error: true });
					throw error;
				}
			};
	}

	/**
	 * Retrieves the current value of a specific metric.
	 * @param {string} metricName - The name of the metric to retrieve.
	 * @returns {object|undefined} The current metric object, or undefined if not found.
	 */
	/**

	 * TODO: Add JSDoc for method get

	 * @memberof AutoGenerated

	 */

	get(metricName) {
		return this.#cache.get(this.#prefix + metricName);
	}

	/**
	 * Retrieves a copy of all tracked metrics.
	 * @returns {Object<string, object>} An object containing all metric names and their data.
	 */
	/**

	 * TODO: Add JSDoc for method getAll

	 * @memberof AutoGenerated

	 */

	getAll() {
		const allMetrics = {};
		// LRUCache doesn't have a standard iterator, so we use its internal representation if possible
		// or rely on a custom method if available. Assuming LRUCache has `entries()`.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#cache.entries) {
			for (const [key, value] of this.#cache.entries()) {
				allMetrics[key] = { ...value }; // Shallow copy is sufficient
			}
		}
		return allMetrics;
	}

	/**
	 * Resets one or all metric counters to zero.
	 * @param {string} [metricName] - The specific metric to reset. If not provided, all metrics will be reset.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method reset

	 * @memberof AutoGenerated

	 */

	reset(metricName) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (metricName) {
			const key = this.#prefix + metricName;
			this.#cache.delete(key);
		} else {
			this.#cache.clear();
		}
	}

	/**
	 * Creates a new MetricsRegistry instance with a specified namespace,
	 * allowing for hierarchical metric organization.
	 * The new instance shares the underlying cache but uses a different prefix.
	 * @param {string} namespace - The namespace to prepend to all metrics from the new instance.
	 * @returns {MetricsRegistry} A new, namespaced MetricsRegistry instance.
	 * @example
	 * const coreRegistry = registry.namespace('core');
	 * coreRegistry.increment('init_count'); // Creates metric 'core.init_count'
	 */
	/**

	 * TODO: Add JSDoc for method namespace

	 * @memberof AutoGenerated

	 */

	namespace(namespace) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!namespace || typeof namespace !== "string") {
			throw new this.#AppError(
				"MetricsRegistry namespace must be a non-empty string."
			);
		}

		// V8.0 Parity: Mandate 1.2 - Delegate instantiation to the ServiceRegistry.
		// This is a special case for creating a non-singleton, namespaced instance.
		return this.#stateManager.serviceRegistry.createNamespacedInstance(
			"metricsRegistry",
			{
				// Pass only the options needed for the new instance.
				prefix: `${this.#prefix}${namespace}.`,
				maxMetrics: this.#maxMetrics,
			}
		);
	}
}

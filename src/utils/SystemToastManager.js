/**
 * @file SystemToastManager.js
 * @description Implements a lightweight, system-wide, accessible toast notification system.
 * It integrates with the `EventFlowEngine` to react to all major system events and provides
 * user feedback for errors, performance alerts, and other operations.
 */
import { DateCore } from "./DateUtils.js";
import { ForensicLogger } from '@core/security/ForensicLogger.js';

/**
 * @class SystemToastManager
 * @classdesc Manages the display of transient, non-intrusive toast notifications for the entire application.
 * It handles creation, styling, automatic dismissal, and accessibility features for toasts.
 * @privateFields {#toasts, #stateManager, #policiesManager, #metricsRegistry, #container, #maxToasts, #defaultDuration}
 */
export class SystemToastManager {
	static #ANIMATION_DURATION = 300; // ms

	// V8.0 Parity: Use private fields for true encapsulation.
	#toasts = new Map();
	#stateManager;
	#policiesManager;
	#metricsRegistry;
	#container = null;
	#maxToasts = 4;
	#defaultDuration = 2500;

	/**
	 * Creates an instance of SystemToastManager.
	 * @param {object} [context={}] - The application context.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		this.#stateManager = stateManager;
		// V8.0 Parity: Derive managers and store them for internal use.
		this.#policiesManager = this.#stateManager?.managers?.policies;
		this.#metricsRegistry = this.#stateManager?.metricsRegistry;

		this.#setupContainer();
		this.#setupEventListeners();
	}

	/**
	 * Sets up the main container element for toasts in the DOM.
	 * @private
	 */
	#setupContainer() {
		// Create toast container if it doesn't exist
		this.#container = document.getElementById("system-toast-container");
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#container) {
			this.#container = document.createElement("div");
			this.#container.id = "system-toast-container";
			this.#container.className = "system-toast-container";
			this.#container.setAttribute("aria-live", "polite");
			this.#container.setAttribute("aria-label", "Grid notifications");

			// Position container
			this.#container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        pointer-events: none;
        max-width: 300px;
      `;

			document.body.appendChild(this.#container);
		}
	}

	/**
	 * Sets up event listeners to react to system events and display toasts.
	 * @private
	 */
	#setupEventListeners() {
		// Listen for layout changes to show save feedback
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager) {
			this.#stateManager.on(
				"layoutChanged",
				this.#onLayoutChanged.bind(this)
			);
			this.#stateManager.on(
				"gridPerformanceMode",
				this.#onPerformanceModeChanged.bind(this)
			);
			this.#stateManager.on("error", this.#onError.bind(this));
			this.#stateManager.on(
				"performance_alert",
				this.#onPerformanceAlert.bind(this)
			);
		}
	}

	/**
	 * Handles `layoutChanged` events, displaying a toast notification if policies allow.
	 * @private
	 * @param {object} changeEvent - The event data for the layout change.
	 */
	#onLayoutChanged(changeEvent) {
		// Check policy to see if we should show feedback
		if (this.#shouldShowSaveFeedback()) {
			// Show different messages based on change type
			const messages = {
				drag: "📍 Layout saved",
				resize: "📏 Layout saved",
				keyboard_move: "⌨️ Position saved",
				keyboard_resize: "⌨️ Size saved",
				add: "➕ Block added",
				remove: "➖ Block removed",
			};

			const message =
				messages[changeEvent.changeType] || "💾 Layout saved";
			this.showToast(message, "success", 2000);
		}
	}

	/**
	 * Handles `gridPerformanceMode` events, displaying a toast notification for policy overrides.
	 * @private
	 * @param {object} data - The event data for the performance mode change.
	 */
	#onPerformanceModeChanged(data) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (data.reason === "policy_override") {
			const message = data.enabled
				? "🚀 Performance mode enabled"
				: "✨ Full features enabled";
			this.showToast(message, "info", 3000);
		}
	}

	/**
	 * Handles `error` events, displaying a toast if the error is user-facing.
	 * @private
	 * @param {object} error - The formatted error object from ErrorHelpers.
	 */
	#onError(error) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (error.showToUser) {
			const typeMap = {
				high: "error",
				medium: "warning",
				low: "info",
			};
			this.showToast(
				error.userFriendlyMessage,
				typeMap[error.severity] || "error"
			);
		}
	}

	/**
	 * Handles `performance_alert` events, displaying a warning toast.
	 * @private
	 * @param {object} alert - The performance alert object from MetricsReporter.
	 */
	#onPerformanceAlert(alert) {
		this.showToast(alert.message, "warning", 4000);
	}

	/**
	 * Checks the system policy to determine if save feedback toasts should be displayed.
	 * @private
	 * @returns {boolean} `true` if save feedback should be shown, `false` otherwise.
	 */
	#shouldShowSaveFeedback() {
		try {
			return (
				this.#policiesManager?.getPolicy(
					"ui",
					"enable_save_feedback",
					true
				) ?? true
			);
		} catch (error) {
			console.warn(
				"[SystemToastManager] Failed to check 'shouldShowSaveFeedback' policy:",
				error.message
			);
			return true; // Default to showing feedback
		}
	}

	/**
	 * Displays a toast notification with the given message, type, and duration.
	 * @param {string} message - The message to display in the toast.
	 * @param {'info'|'success'|'error'|'warning'} [type='info'] - The type of toast, influencing its styling.
	 * @param {number} duration - The duration in milliseconds before the toast automatically dismisses.
	 * @returns {string} The unique ID of the displayed toast.
	 * @private
	 */
	#showToast(message, type = "info", duration) {
		// Metrics Integration
		this.#metricsRegistry?.increment("ui.toast.shown");
		if (type) this.#metricsRegistry?.increment(`ui.toast.by_type.${type}`);

		const id = `toast_${DateCore.timestamp()}_${Math.random().toString(36).substr(2, 5)}`;
		const toast = this.#createToastElement(id, message, type);

		// Add to DOM
		this.#container.appendChild(toast);
		this.#toasts.set(id, { element: toast, type });

		// Limit number of toasts
		this.#enforceMaxToasts();

		// Auto-remove after duration
		setTimeout(() => {
			this.#removeToast(id);
		}, duration);

		// Animate in
		requestAnimationFrame(() => {
			toast.style.transform = "translateX(0)";
			toast.style.opacity = "1";
		});

		return id;
	}

	/**
	 * Creates the DOM element for a toast notification.
	 * @private
	 * @param {string} id - The unique ID for the toast.
	 * @param {string} message - The message content of the toast.
	 * @param {string} type - The type of the toast ('info', 'success', 'error', 'warning').
	 * @returns {HTMLElement} The created toast DOM element.
	 */
	#createToastElement(id, message, type) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  const toast = document.createElement("div");
		toast.className = `system-toast system-toast-${type}`;
		toast.setAttribute("data-toast-id", id);
		toast.setAttribute("role", "status");
		toast.setAttribute("aria-atomic", "true");

		// Set initial styles for animation
		toast.style.cssText = `
      background: ${this.#getBackgroundColor(type)};
      color: ${this.#getTextColor(type)};
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border-left: 4px solid ${this.#getBorderColor(type)};
      transform: translateX(100%);
      opacity: 0;
      transition: all ${SystemToastManager.#ANIMATION_DURATION}ms ease;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      position: relative;
      overflow: hidden;
    `;

		// Add content
		const content = document.createElement("div");
		content.textContent = message;
		toast.appendChild(content);

		// Add close button
		const closeBtn = document.createElement("button");
		closeBtn.textContent = "×";
		closeBtn.className = "toast-close";
		closeBtn.setAttribute("aria-label", "Close notification");
		closeBtn.style.cssText = `
      position: absolute;
      top: 4px;
      right: 8px;
      background: none;
      border: none;
      color: inherit;
      font-size: 18px;
      cursor: pointer;
      opacity: 0.7;
      line-height: 1;
    `;

		closeBtn.addEventListener("click", () => {
			this.#removeToast(id);
		});

		toast.appendChild(closeBtn);

		// Click to dismiss
		toast.addEventListener("click", (e) => {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (e.target !== closeBtn) {
				this.#removeToast(id);
			}
		});

		return toast;
	}

	/**
	 * Gets the background color for a toast based on its type.
	 * @private
	 * @param {string} type - The type of the toast.
	 * @returns {string} The CSS color value.
	 */
	#getBackgroundColor(type) {
		const colors = {
			success: "#d4edda",
			error: "#f8d7da",
			warning: "#fff3cd",
			info: "#d1ecf1",
		};
		return colors[type] || colors.info;
	}

	/**
	 * Gets the text color for a toast based on its type.
	 * @private
	 * @param {string} type - The type of the toast.
	 * @returns {string} The CSS color value.
	 */
	#getTextColor(type) {
		const colors = {
			success: "#155724",
			error: "#721c24",
			warning: "#856404",
			info: "#0c5460",
		};
		return colors[type] || colors.info;
	}

	/**
	 * Gets the border color for a toast based on its type.
	 * @private
	 * @param {string} type - The type of the toast.
	 * @returns {string} The CSS color value.
	 */
	#getBorderColor(type) {
		const colors = {
			success: "#28a745",
			error: "#dc3545",
			warning: "#ffc107",
			info: "#17a2b8",
		};
		return colors[type] || colors.info;
	}

	/**
	 * Removes a toast notification from the DOM and the internal registry.
	 * @private
	 * @param {string} toastId - The unique ID of the toast to remove.
	 */
	#removeToast(toastId) {
		const toast = this.#toasts.get(toastId);
		if (!toast) return;

		const element = toast.element;

		// Animate out
		element.style.transform = "translateX(100%)";
		element.style.opacity = "0";

		// Remove from DOM after animation
		setTimeout(() => {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (element.parentNode) {
				element.parentNode.removeChild(element);
			}
			this.#toasts.delete(toastId);
		}, SystemToastManager.#ANIMATION_DURATION);
	}

	/**
	 * Ensures that the number of displayed toasts does not exceed `maxToasts` by removing the oldest ones.
	 * @private
	 */
	#enforceMaxToasts() {
		const toastIds = Array.from(this.#toasts.keys());
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (toastIds.length > this.#maxToasts) {
			// Remove oldest toasts
			const toRemove = toastIds.slice(
				0,
				toastIds.length - this.#maxToasts
			);
			toRemove.forEach((id) => this.#removeToast(id));
		}
	}

	/**
	 * Displays a success-type toast notification.
	 * @public
	 * @param {string} message - The message to display.
	 * @param {number} [duration=this.#defaultDuration] - The duration in milliseconds.
	 * @returns {string} The ID of the toast.
	 */
	/**

	 * TODO: Add JSDoc for method success

	 * @memberof AutoGenerated

	 */

	success(message, duration = this.#defaultDuration) {
		return this.#showToast(message, "success", duration);
	}

	/**
	 * Displays an error-type toast notification.
	 * @public
	 * @param {string} message - The message to display.
	 * @param {number|null} [duration=null] - The duration in milliseconds.
	 * @returns {string} The ID of the toast. // V8.0 Parity: Use private fields for true encapsulation.
	 */
	/**

	 * TODO: Add JSDoc for method error

	 * @memberof AutoGenerated

	 */

	error(message, duration = this.#defaultDuration) {
		return this.#showToast(message, "error", duration);
	}

	/**
	 * Displays a warning-type toast notification.
	 * @public
	 * @param {string} message - The message to display.
	 * @param {number|null} [duration=null] - The duration in milliseconds.
	 * @returns {string} The ID of the toast.
	 */
	/**

	 * TODO: Add JSDoc for method warning

	 * @memberof AutoGenerated

	 */

	warning(message, duration = this.#defaultDuration) {
		return this.#showToast(message, "warning", duration);
	}

	/**
	 * Displays an info-type toast notification.
	 * @public
	 * @param {string} message - The message to display.
	 * @param {number|null} [duration=null] - The duration in milliseconds.
	 * @returns {string} The ID of the toast.
	 */
	/**

	 * TODO: Add JSDoc for method info

	 * @memberof AutoGenerated

	 */

	info(message, duration = this.#defaultDuration) {
		return this.#showToast(message, "info", duration);
	}

	/**
	 * Clears all currently displayed toast notifications.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method clear

	 * @memberof AutoGenerated

	 */

	clear() {
		Array.from(this.#toasts.keys()).forEach((id) => this.#removeToast(id));
	}

	/**
	 * Destroys the toast manager, clearing all toasts and removing its container from the DOM.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method destroy

	 * @memberof AutoGenerated

	 */

	destroy() {
		this.clear();
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#container && this.#container.parentNode) {
			this.#container.parentNode.removeChild(this.#container);
		}
	}
}

export default SystemToastManager;

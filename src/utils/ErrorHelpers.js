/**
 * @file ErrorHelpers.js
 * @description A class-based service for comprehensive, centralized error handling.
 * It normalizes errors, categorizes them, reports them to metrics and logging,
 * and orchestrates recovery actions, adhering to V8 Parity Mandates.
 */
import { DateCore } from "./DateUtils.js";
import { ForensicLogger } from '@core/security/ForensicLogger.js';
import { CDS } from '@core/security/CDS.js';

/**
 * @class AppError
 * @description A base class for all custom application errors, ensuring consistent properties.
 * @extends Error
 */
export class AppError extends Error {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(
		message,
		{
			category = "system_error",
			severity = "medium",
			recoverable = true,
			showToUser = true, // V8 Mandate: Now expects stateManager for dependencies
			stateManager,
			...context
		} = {}
	) {
		super(message);
		this.name = this.constructor.name; // Use a simple, non-secure ID for errors
		this.id = stateManager?.managers?.idManager
			? stateManager.managers.idManager.generateSimpleId("err")
			: `err_${DateCore.timestamp()}`;
		this.timestamp = DateCore.now();
		this.category = category;
		this.severity = severity;
		this.recoverable = recoverable;
		this.showToUser = showToUser;
		this.context = context;
	}
}

// --- Specific Custom Error Classes ---
export class UIError extends AppError {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(message, context) {
		super(message, { category: "ui_error", ...context });
	}
}
export class NetworkError extends AppError {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(message, context) {
		super(message, {
			category: "network_error",
			severity: "high",
			...context,
		});
	}
}
export class StorageError extends AppError {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(message, context) {
		super(message, {
			category: "storage_error",
			severity: "high",
			...context,
		});
	}
}
export class PolicyError extends AppError {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(message, context) {
		super(message, {
			category: "policy_error",
			severity: "high",
			showToUser: true,
			...context,
		});
	}
}
export class PluginError extends AppError {
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(message, context) {
		super(message, { category: "plugin_error", ...context });
	}
}

/**
 * @class ErrorHelpers
 * @description A centralized service for handling all application errors.
 * @privateFields {#stateManager, #metricsRegistry, #forensicLogger, #securityManager, #cacheManager, #embeddingManager}
 */
export class ErrorHelpers {
	#stateManager;
	#metricsRegistry;
	#forensicLogger;
	#securityManager;
	#cacheManager;
	#embeddingManager;

	/**
	 * Creates an instance of ErrorHelpers.
	 * @param {import('../core/HybridStateManager.js').default} stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(stateManager) {
		this.#stateManager = stateManager;
		// V8 Mandate 1.2: Derive all core services from the stateManager.
		this.#metricsRegistry = this.#stateManager?.metricsRegistry;
		this.#forensicLogger = this.#stateManager?.managers?.forensicLogger;
		this.#securityManager = this.#stateManager?.managers?.securityManager;
		this.#cacheManager = this.#stateManager?.managers?.cacheManager;
		this.#embeddingManager = this.#stateManager?.managers?.embedding;
	}

	/**
	 * Normalizes an error of any type (Error, string, object) into a standardized structure.
	 * This adds a unique ID, timestamp, severity, category, and other contextual information.
	 * @param {Error|string|object} error - The raw error to be formatted.
	 * @param {object} [context={}] - Additional context to enrich the error object (e.g., component name, user ID).
	 * @returns {object} A standardized error object with properties like `id`, `message`, `stack`, `category`, `severity`, etc.
	 * @private
	 */
	#formatError(error, context = {}) {
		// If it's already one of our custom errors, enrich it
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (error instanceof AppError) {
			const enrichedError = { ...error, ...error.context, ...context };
			enrichedError.userFriendlyMessage =
				this.#generateUserFriendlyMessage(enrichedError);
			return enrichedError;
		}

		// Handle other error types and normalize them
		const formattedError = new AppError("Unknown error occurred", {
			category: "unknown",
			// V8 Mandate: Pass stateManager to AppError for dependency resolution.
			stateManager: this.#stateManager,
			...context,
		});

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (error instanceof Error) {
			// Standard JavaScript Error
			formattedError.message = error.message;
			formattedError.stack = error.stack || "No stack available";
			formattedError.name = error.name;
			// Use legacy categorization as a fallback
			formattedError.category = this.#categorizeError(error);
			formattedError.severity = this.#determineSeverity(error);
		} else if (typeof error === "string") {
			// Plain string error
			formattedError.message = error;
			formattedError.stack = "No stack available";
		} else if (typeof error === "object" && error !== null) {
			// Plain object error
			Object.assign(formattedError, error); // Merge properties
			formattedError.message = error.message || formattedError.message;
			formattedError.stack = error.stack || "No stack available";
		}

		// Generate user-friendly message for the newly formatted error
		formattedError.userFriendlyMessage =
			this.#generateUserFriendlyMessage(formattedError);

		return formattedError;
	}

	/**
	 * Generates a user-friendly message based on the error's category and severity.
	 * @param {object} error - The formatted error object.
	 * @returns {string} A user-friendly message suitable for display in the UI.
	 * @private
	 */
	#generateUserFriendlyMessage(error) {
		const category = error.category;
		const severity = error.severity;

		const messages = {
			ui_error: {
				high: "The interface encountered a serious problem. Please refresh the page.",
				medium: "There was an issue with the interface. Some features may not work properly.",
				low: "A minor interface issue occurred. You can continue working normally.",
			},
			network_error: {
				high: "Unable to connect to the server. Please check your internet connection.",
				medium: "Connection issues detected. Some data may not be up to date.",
				low: "Network request failed. Please try again.",
			},
			storage_error: {
				high: "Unable to save your data. Please ensure you have sufficient storage space.",
				medium: "There was an issue saving your changes. Please try again.",
				low: "A storage issue occurred. Your recent changes may not be saved.",
			},
			policy_error: {
				high: "You do not have permission to perform this action.",
				medium: "Access restricted. Please contact an administrator.",
				low: "This feature is not available with your current permissions.",
			},
			plugin_error: {
				high: "A plugin has stopped working. Some features may be unavailable.",
				medium: "Plugin issue detected. Functionality may be limited.",
				low: "A plugin encountered a minor issue.",
			},
			javascript_error: {
				high: "A serious application error occurred. Please refresh the page.",
				medium: "An application error occurred. Some features may not work properly.",
				low: "A minor application issue occurred.",
			},
			system_error: {
				high: "A system error occurred. Please contact support if this persists.",
				medium: "System issue detected. Some features may be affected.",
				low: "A minor system issue occurred.",
			},
		};

		return (
			messages[category]?.[severity] ||
			"An unexpected error occurred. Please try again."
		);
	}

	/**
	 * Logs a formatted error object to the console in a structured, grouped format.
	 * @param {object} errorObj - The formatted error object to log.
	 * @private
	 */
	#logToConsole(errorObj) {
		const { id, message, category, severity, stack, component } = errorObj;

		console.group(
			`‚ùå [${severity.toUpperCase()}] ${category} in ${component}`
		);
		console.error(`ID: ${id}`);
		console.error(`Message: ${message}`);
		console.error(`Stack trace:`);
		console.error(stack);
		console.groupEnd();
	}

	/**
	 * Emits a formatted error to the EventFlowEngine for centralized processing,
	 * such as displaying UI notifications or sending to an external logging service.
	 * @param {object} error - The formatted error object.
	 * @private
	 */
	#emitToFlow(error) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#stateManager?.emit) {
			console.warn(
				"[ErrorHelpers] EventFlow not available, cannot emit error"
			);
			return;
		}

		try {
			this.#stateManager.emit("error", error);
		} catch (emitError) {
			console.error(
				"[ErrorHelpers] Failed to emit error to EventFlow:",
				emitError
			);
			this.#logToConsole(error);
		}
	}

	/**
	 * A wrapper for async functions that catches any thrown errors and processes them
	 * through the standard `handleError` pipeline.
	 * @param {function(): Promise<any>} fn - The async function to execute.
	 * @param {object} [context={}] - Context for the error if one occurs.
	 * @returns {Promise<any|null>} The result of the function, or `null` if an error was caught.
	 */
	/**

	 * TODO: Add JSDoc for method tryAsync

	 * @memberof AutoGenerated

	 */

	async tryAsync(fn, context = {}) {
		try {
			return await fn();
		} catch (error) {
			this.handleError(error, context);
			return null;
		}
	}

	/**
	 * Backwards-compatible async wrapper. Executes an async function and captures errors via handleError.
	 * Accepts an optional intermediate event parameter that is ignored for compatibility.
	 * @param {Function} fn - The async function to execute.
	 * @param {any} [maybeEventOrContext] - Optional event bus (ignored) or context object.
	 * @param {object} [maybeContext] - Optional context when an event is provided as second arg.
	 * @returns {Promise<any|null>} The result of the function or null on error.
	 */
	/**

	 * TODO: Add JSDoc for method captureAsync

	 * @memberof AutoGenerated

	 */

	async captureAsync(fn, maybeEventOrContext = {}, maybeContext = undefined) {
		let context = {};
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (maybeContext !== undefined) {
			context = maybeContext || {};
		} else {
			context = maybeEventOrContext || {};
		}

		try {
			return await Promise.resolve(fn());
		} catch (error) {
			this.handleError(error, context);
			return null;
		}
	}

	/**
	 * A wrapper for synchronous functions that catches any thrown errors and processes them
	 * through the standard `handleError` pipeline.
	 * @param {function(): any} fn - The synchronous function to execute.
	 * @param {object} [context={}] - Context for the error if one occurs.
	 * @returns {any|null} The result of the function, or `null` if an error was caught.
	 */
	/**

	 * TODO: Add JSDoc for method try

	 * @memberof AutoGenerated

	 */

	try(fn, context = {}) {
		try {
			return fn();
		} catch (error) {
			this.handleError(error, context);
			return null;
		}
	}

	/**
	 * The main error handling pipeline. It formats the error, logs it to the console,
	 * emits it to the event flow, and attempts recovery.
	 * @param {Error|string|object} error - The raw error to handle.
	 * @param {object} [context={}] - Additional context for the error.
	 * @returns {object} The formatted error object.
	 */
	/**

	 * TODO: Add JSDoc for method handleError

	 * @memberof AutoGenerated

	 */

	handleError(error, context = {}) {
		// Ensure managers from context are available for integrations
		const formattedError = this.#formatError(error, context);
		const { category, severity, component } = formattedError;

		// 1. Always log to console for immediate debugging
		this.#logToConsole(formattedError);

		// 2. Metrics Integration: Record error stats.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#metricsRegistry) {
			this.#metricsRegistry.increment("errors.total");
			if (category)
				this.#metricsRegistry.increment(
					`errors.by_category.${category}`
				);
			if (severity)
				this.#metricsRegistry.increment(
					`errors.by_severity.${severity}`
				);
			if (component)
				this.#metricsRegistry.increment(
					`errors.by_component.${component}`
				);
		}

		// 3. Auditing, Security & Embedding Integration (using full context)
		// For high-severity errors, create a formal audit trail
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (severity === "high" && this.#forensicLogger) {
			const securityContext = this.#securityManager?.getSubject() || {};
			this.#forensicLogger.logAuditEvent(
				"SYSTEM_ERROR_CRITICAL",
				this.sanitizeError(formattedError),
				securityContext
			);
		}
		// For storage errors, capture cache metrics for context
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (category === "storage_error" && this.#cacheManager) {
			formattedError.context.cacheMetrics =
				this.#cacheManager.getMetrics();
		}
		// For high-severity errors, generate embeddings for AI analysis
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (severity === "high" && this.#embeddingManager) {
			// We pass the full error context to get a rich embedding
			const embeddingText = `Error: ${formattedError.message}. Category: ${category}. Component: ${component}. Stack: ${formattedError.stack}`;
			this.#embeddingManager
				.generateEmbedding(embeddingText, {
					errorId: formattedError.id,
					type: "error_context",
				})
				.catch((e) =>
					console.warn("Failed to generate error embedding:", e)
				);
		}

		// 4. Emit to EventFlow for UI notifications and other listeners
		this.#emitToFlow(formattedError);

		// 5. Attempt recovery if possible
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (formattedError.recoverable) {
			this.#attemptRecovery(formattedError, context);
		}

		return formattedError;
	}

	/**
	 * Dispatches to a specific recovery strategy based on the error's category.
	 * @param {object} error - The formatted error object.
	 * @param {object} context - The context, which may contain recovery functions (e.g., `refreshComponent`).
	 * @private
	 */
	#attemptRecovery(error, context = {}) {
		/**

		 * TODO: Add JSDoc for method switch

		 * @memberof AutoGenerated

		 */

		switch (error.category) {
			case "ui_error":
				this.#recoverUIError(error, context);
				break;
			case "network_error":
				this.#recoverNetworkError(error, context);
				break;
			case "storage_error":
				this.#recoverStorageError(error, context);
				break;
			case "policy_error":
				this.#recoverPolicyError(error, context);
				break;
			default:
				console.warn(
					`[ErrorHelpers] No recovery strategy for ${error.category}`
				);
		}
	}

	/**
	 * A recovery strategy for UI-related errors. Attempts to refresh the affected component.
	 * @param {object} error - The formatted error object.
	 * @param {object} context - The context containing a `refreshComponent` function.
	 * @private
	 */
	#recoverUIError(error, context) {
		// Try to refresh the affected component
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (context.component && context.refreshComponent) {
			try {
				context.refreshComponent(context.component);
				console.info(
					`[ErrorHelpers] Attempted to refresh component: ${context.component}`
				);
			} catch (recoveryError) {
				console.warn(
					"[ErrorHelpers] Component refresh failed:",
					recoveryError
				);
			}
		}
	}

	/**
	 * A recovery strategy for network errors. Attempts to enable an offline mode if available.
	 * @param {object} error - The formatted error object.
	 * @param {object} context - The context containing an `enableOfflineMode` function.
	 * @private
	 */
	#recoverNetworkError(error, context) {
		// Enable offline mode or use cached data
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (context.enableOfflineMode) {
			try {
				context.enableOfflineMode();
				console.info(
					"[ErrorHelpers] Enabled offline mode due to network error"
				);
			} catch (recoveryError) {
				console.warn(
					"[ErrorHelpers] Failed to enable offline mode:",
					recoveryError
				);
			}
		}
	}

	/**
	 * A recovery strategy for storage errors. Attempts to clear a cache if available.
	 * @param {object} error - The formatted error object.
	 * @param {object} context - The context containing a `clearCache` function.
	 * @private
	 */
	#recoverStorageError(error, context) {
		// Clear cache or use alternative storage
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (context.clearCache) {
			try {
				context.clearCache();
				console.info(
					"[ErrorHelpers] Cleared cache due to storage error"
				);
			} catch (recoveryError) {
				console.warn(
					"[ErrorHelpers] Failed to clear cache:",
					recoveryError
				);
			}
		}
	}

	/**
	 * A recovery strategy for policy/permission errors. Logs that recovery should be handled by the UI.
	 * @param {object} error - The formatted error object.
	 * @param {object} context - The error context.
	 * @private
	 */
	#recoverPolicyError(error, context) {
		// Show permission dialog or redirect to login
		console.info(
			"[ErrorHelpers] Policy error - user may need different permissions"
		);
		// Recovery would be handled by the UI layer
	}

	/**
	 * Creates a simple error boundary object for a component.
	 * This provides `try` and `tryAsync` methods that wrap functions with error handling.
	 * @param {string} component - The name of the component for context.
	 * @param {object} [extraContext={}] - Any extra context to pass to the error handler.
	 * @returns {{try: function(function(): any): any, tryAsync: function(function(): Promise<any>): Promise<any>}} An error boundary object.
	 */
	/**

	 * TODO: Add JSDoc for method createErrorBoundary

	 * @memberof AutoGenerated

	 */

	createErrorBoundary(component = "unknown", extraContext = {}) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  return {
			try: (fn) => this.try(fn, { component, ...extraContext }),
			tryAsync: (fn) =>
				this.tryAsync(fn, {
					component,
					...extraContext,
				}),
		};
	}

	/**
	 * Attaches global error listeners to `window` for uncaught exceptions and
	 * unhandled promise rejections, piping them through the standard error handling pipeline.
	 */
	/**

	 * TODO: Add JSDoc for method setupGlobalHandlers

	 * @memberof AutoGenerated

	 */

	setupGlobalHandlers() {
		// Handle uncaught errors
		window.addEventListener("error", (event) => {
			this.handleError(event.error || event.message, {
				component: "global",
				filename: event.filename,
				lineno: event.lineno,
				colno: event.colno,
			});
		});

		// Handle unhandled promise rejections
		window.addEventListener("unhandledrejection", (event) => {
			this.handleError(event.reason, {
				component: "global",
				type: "unhandled_promise_rejection",
			});
		});

		console.log("[ErrorHelpers] Global error handlers set up");
	}

	/**
	 * A higher-order function that wraps a function to trace its execution time.
	 * It logs a warning for slow operations and enriches any errors with performance data.
	 * @param {string} operation - A name for the operation being tracked.
	 * @param {function(...any): any} fn - The function to wrap (can be sync or async).
	 * @param {object} [context={}] - The context to pass to the error handler.
	 * @returns {any} The result of the wrapped function.
	 */
	/**

	 * TODO: Add JSDoc for method trace

	 * @memberof AutoGenerated

	 */

	trace(operation, fn, context = {}) {
		const startTime = performance.now();
		try {
			const result = fn();

			// Handle async functions
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (result && typeof result.then === "function") {
				return result.finally(() =>
					this.#metricsRegistry?.timer(
						operation,
						performance.now() - startTime
					)
				);
			}

			// Handle sync functions
			const duration = performance.now() - startTime;
			this.#metricsRegistry?.timer(operation, duration);
			return result;
		} catch (error) {
			const duration = performance.now() - startTime;
			this.handleError(error, { ...context, operation, duration });
			throw error; // Re-throw after handling
		}
	}

	/**
	 * Sanitizes an error object to remove potentially sensitive information (PII)
	 * like emails or credit card numbers before logging or reporting.
	 * @deprecated Use `trace()` instead for both sync and async operations.
	 */
	/**

	 * TODO: Add JSDoc for method withPerformanceTracking

	 * @memberof AutoGenerated

	 */

	withPerformanceTracking(fn, operation = "operation", context = {}) {
		return async (...args) =>
			this.trace(operation, () => fn(...args), context);
	}

	/**
	 * Sanitizes an error object to remove potentially sensitive information (PII)
	 * like emails or credit card numbers before logging or reporting.
	 * @param {object} error - The formatted error object.
	 * @returns {object|null} The sanitized error object, or null if the input was invalid.
	 */
	/**

	 * TODO: Add JSDoc for method sanitizeError

	 * @memberof AutoGenerated

	 */

	sanitizeError(error) {
		if (!error) return null;

		// Remove sensitive information
		const sanitized = { ...error };

		// Remove potential PII from error messages
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (sanitized.message) {
			sanitized.message = sanitized.message
				.replace(
					/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
					"[EMAIL]"
				)
				.replace(
					/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g,
					"[CARD]"
				)
				.replace(/\b\d{3}-\d{2}-\d{4}\b/g, "[SSN]");
		}

		// Limit stack trace length
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (sanitized.stack && sanitized.stack.length > 2000) {
			sanitized.stack =
				sanitized.stack.substring(0, 2000) + "... [truncated]";
		}

		return sanitized;
	}

	/**
	 * A robust wrapper for executing functions with error handling, a default return value, and a finally block.
	 * @param {Function} fn - The function to execute. Can be sync or async.
	 * @param {Function|any} [onErrorOrValue=null] - A function to call on error, or a default value to return.
	 * @param {object} [context={}] - Context for the error if one occurs.
	 * @param {Function} [onFinally=null] - A function to call in the finally block.
	 * @returns {Promise<any>} The result of the function, or the result of onErrorOrValue.
	 */
	/**

	 * TODO: Add JSDoc for method tryOr

	 * @memberof AutoGenerated

	 */

	async tryOr(fn, onErrorOrValue = null, context = {}, onFinally = null) {
		try {
			return await Promise.resolve(fn());
		} catch (error) {
			this.handleError(error, context);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof onErrorOrValue === "function") {
				return onErrorOrValue(error);
			}
			return onErrorOrValue;
		} finally {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof onFinally === "function") {
				try {
					onFinally();
				} catch (finallyError) {
					this.handleError(finallyError, {
						...context,
						component: context.component
							? `${context.component}.finally`
							: "finally_block",
						originalError: context.error,
					});
				}
			}
		}
	}

	/**
	 * Infers an error category from a standard Error object.
	 * @param {Error} error - The standard error object.
	 * @returns {string} The inferred category.
	 * @private
	 */
	#categorizeError(error) {
		const msg = error.message.toLowerCase();
		if (msg.includes("network") || msg.includes("failed to fetch")) {
			return "network_error";
		}
		if (msg.includes("storage") || msg.includes("indexeddb")) {
			return "storage_error";
		}
		if (msg.includes("permission") || msg.includes("access denied")) {
			return "policy_error";
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (error instanceof TypeError || error instanceof ReferenceError) {
			return "javascript_error";
		}
		return "system_error";
	}

	/**
	 * Determines the severity of an error based on its type.
	 * @param {Error} error - The standard error object.
	 * @returns {string} The inferred severity ('low', 'medium', 'high').
	 * @private
	 */
	#determineSeverity(error) {
		const name = error.name;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (
			name === "TypeError" ||
			name === "ReferenceError" ||
			name === "InternalError"
		) {
			return "high";
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (name === "RangeError" || name === "URIError") {
			return "medium";
		}
		return "low";
	}
}

// Default export is the class itself for service registration.
export default ErrorHelpers;

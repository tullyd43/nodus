import { ForensicLogger } from "@core/security/ForensicLogger.js";

import RenderContext from "./RenderContext.js";
/**
 * @file Contains the BuildingBlockRenderer class, a composable rendering system.
 * @module BuildingBlockRenderer
 * @description This renderer focuses on composing UI from reusable "building blocks" rather than a hierarchical or level-based system.
 * @see {@link d:\Development Files\repositories\nodus\src\docs\feature_development_philosophy.md} for architectural principles on composability.
 */

/**
 * @class BuildingBlockRenderer
 * @classdesc A pure, composable rendering system that builds UI from registered building blocks. It is responsible for interpreting declarative composition objects and rendering them into DOM elements.
 * @class BuildingBlockRenderer
 * @privateFields {#componentRegistry, #metrics, #errorHelpers}
 */
export class BuildingBlockRenderer {
	/** @private @type {import('./ComponentDefinition.js').ComponentDefinitionRegistry} */
	#componentRegistry;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers;

	/**
	 * @class
	 * @param {object} context - The application context.
	 * @param {import('./HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from the stateManager.
		this.#componentRegistry = stateManager.managers.componentRegistry;
		this.#metrics = stateManager.metricsRegistry?.namespace(
			"buildingBlockRenderer"
		);
		this.#errorHelpers = stateManager.managers.errorHelpers;
	}

	/**
	 * @function render
	 * @description Renders any composition of blocks, including single blocks, sequences, and layouts.
	 * @param {string|Array|object} composition - The composition to render.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	/**

	 * TODO: Add JSDoc for method render

	 * @memberof AutoGenerated

	 */

	render(composition, context = {}) {
		return this.#errorHelpers.tryOr(
			() => {
				this.#metrics?.increment("compositionsRendered");

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (typeof composition === "string") {
					// Single block
					return this.#renderBlock(composition, context);
				}

				if (Array.isArray(composition)) {
					// List of blocks
					return this.#renderSequence(composition, context);
				}

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (composition?.layout) {
					// Layout with blocks
					return this.#renderLayout(composition, context);
				}

				// Direct composition object
				return this.#renderComposition(composition, context);
			},
			(error) => {
				this.#metrics?.increment("renderErrors");
				return this.#createErrorElement(
					`Composition failed: ${error.message}`
				);
			}
		);
	}

	/**
	 * @function renderBlock
	 * @description Renders a single building block.
	 * @private
	 * @param {string} blockId - The ID of the block to render.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderBlock(blockId, context = {}) {
		const block = this.#componentRegistry?.get(blockId);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!block) {
			return this.#createErrorElement(`Block not found: ${blockId}`);
		}

		return this.#errorHelpers.tryOr(
			() => {
				// V8.0 Parity: Use the full RenderContext to ensure blocks have access to all system state.
				// The context needs the stateManager, which we can get from the componentRegistry.
				const renderContext = new RenderContext({
					stateManager: this.#componentRegistry?.stateManager,
					...context, // Pass through any existing context properties
					blockId,
					config: { ...block.config, ...context.config },
				});

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (typeof block.render === "function") {
					return block.render(renderContext);
				} else if (typeof block.render === "string") {
					return this.#renderTemplate(block.render, renderContext);
				}

				return this.#createErrorElement(
					`Invalid render method for ${blockId}`
				);
			},
			(error) => {
				console.error(`Error rendering block ${blockId}:`, error);
				return this.#createErrorElement(
					`Render error: ${error.message}`
				);
			}
		);
	}

	/**
	 * @function renderSequence
	 * @description Renders a sequence of blocks.
	 * @private
	 * @param {Array<string|object>} blocks - An array of block configurations.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderSequence(blocks, context = {}) {
		const container = document.createElement("div");
		container.className = "block-sequence";

		blocks.forEach((blockConfig, index) => {
			const blockContext = {
				...context,
				sequenceIndex: index,
				sequenceLength: blocks.length,
			};

			let element;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof blockConfig === "string") {
				element = this.#renderBlock(blockConfig, blockContext);
			} else {
				element = this.render(blockConfig, blockContext); // Recurse with public render
			}

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (element) {
				container.appendChild(element);
			}
		});

		return container;
	}

	/**
	 * @function renderLayout
	 * @description Renders a layout composition.
	 * @private
	 * @param {object} composition - The layout composition object.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderLayout(composition, context = {}) {
		const { layout, blocks = [], config = {} } = composition;

		const container = document.createElement("div");
		container.className = `layout-${layout}`;

		// Apply layout styles
		this.#applyLayoutStyles(container, layout, config);

		// Render blocks within layout
		blocks.forEach((blockConfig, index) => {
			const blockElement = this.render(blockConfig, {
				// Recurse with public render
				...context,
				layoutIndex: index,
				layoutType: layout,
			});

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (blockElement) {
				// Apply positioning if specified
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (blockConfig.position) {
					this.#applyPositioning(blockElement, blockConfig.position);
				}
				container.appendChild(blockElement);
			}
		});

		return container;
	}

	/**
	 * @function renderComposition
	 * @description Renders a direct composition object.
	 * @private
	 * @param {object} composition - The composition object.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderComposition(composition, context = {}) {
		const {
			type = "div",
			className = "",
			style = {},
			children = [],
			events = {},
			...props
		} = composition;

		// Short-circuit rendering for well-known control types so we can use
		// small, focused helper methods that wire data-action/data-bind and
		// perform any engine initialization required.
		if (type === "button") {
			const btn = this.#renderButton(props, context);
			// Attach any explicit event handlers defined in the composition
			Object.entries(events).forEach(([event, handler]) => {
				if (typeof handler === "function")
					btn.addEventListener(event, handler);
			});
			// Append children if present
			children.forEach((child) => {
				const childElement = this.render(child, context);
				if (childElement) btn.appendChild(childElement);
			});
			return btn;
		}

		if (type === "input" || type === "text-field") {
			// Inputs typically don't have children; render a bound input and return.
			const input = this.#renderTextField(props, context);
			Object.entries(events).forEach(([event, handler]) => {
				if (typeof handler === "function")
					input.addEventListener(event, handler);
			});
			return input;
		}

		if (type === "textarea" || type === "text-area") {
			const ta = this.#renderTextArea(props, context);
			Object.entries(events).forEach(([event, handler]) => {
				if (typeof handler === "function")
					ta.addEventListener(event, handler);
			});
			return ta;
		}

		if (type === "label" || type === "span") {
			const lbl = this.#renderLabel(props, context);
			Object.entries(events).forEach(([event, handler]) => {
				if (typeof handler === "function")
					lbl.addEventListener(event, handler);
			});
			return lbl;
		}

		if (type === "container") {
			const cont = this.#renderContainer(props, context);
			Object.entries(events).forEach(([event, handler]) => {
				if (typeof handler === "function")
					cont.addEventListener(event, handler);
			});
			return cont;
		}

		const element = document.createElement(type);

		if (className) element.className = className;

		Object.assign(element.style, style);

		// Convenience: map common prop names into dataset attributes so the
		// global BindEngine / ActionDispatcher (which use document delegation)
		// can pick up dynamically created elements. We prefer data-* attributes
		// as the delegation engines already look for them.
		try {
			const stateManager = this.#componentRegistry?.stateManager;
			if (props.bindingPath) {
				element.dataset.bind = props.bindingPath;
			}
			if (props.actionName) {
				element.dataset.action = props.actionName;
			}
			if (props.entityId) {
				element.dataset.entity = props.entityId;
			}
		} catch (e) {
			// Non-fatal; continue rendering even if dataset wiring fails.
		}

		// Set other properties
		Object.entries(props).forEach(([key, value]) => {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (key !== "type" && key !== "children") {
				element[key] = value;
			}
		});

		// Add event listeners
		Object.entries(events).forEach(([event, handler]) => {
			element.addEventListener(event, handler);
		});

		// Render children
		children.forEach((child) => {
			const childElement = this.render(child, context); // Recurse with public render
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (childElement) {
				element.appendChild(childElement);
			}
		});

		// If a BindEngine was registered on the state manager, initialize it for
		// this newly-created element so dynamic [data-bind] elements are tracked.
		try {
			const stateManager = this.#componentRegistry?.stateManager;
			stateManager?.managers?.bindEngine?.register?.(element);
		} catch (e) {
			// Swallow; binding registration is best-effort for dynamic elements.
		}

		return element;
	}

	/**
	 * @function applyLayoutStyles
	 * @description Applies CSS styles for a given layout type.
	 * @private
	 * @param {HTMLElement} container - The container element for the layout.
	 * @param {string} layout - The name of the layout (e.g., 'grid', 'flex').
	 * @param {object} config - The configuration for the layout.
	 * @returns {void}
	 */
	#applyLayoutStyles(container, layout, config) {
		const layoutStyles = {
			grid: {
				display: "grid",
				gridTemplateColumns: `repeat(${config.columns || 12}, 1fr)`,
				gap: `${config.gap || 16}px`,
			},
			flex: {
				display: "flex",
				flexDirection: config.direction || "row",
				gap: `${config.gap || 16}px`,
			},
			stack: {
				display: "flex",
				flexDirection: "column",
				gap: `${config.gap || 8}px`,
			},
			absolute: {
				position: "relative",
			},
		};

		const styles = layoutStyles[layout] || {};
		Object.assign(container.style, styles, config.style || {});
	}

	/**
	 * @function renderButton
	 * @description Helper to render a standardized button composition.
	 * @private
	 */
	#renderButton(props = {}, context = {}) {
		const btn = document.createElement("button");
		btn.type = props.type || "button";
		btn.className = props.className || props.props?.className || "btn";
		btn.textContent =
			props.textContent || props.props?.label || props.props?.text || "";
		Object.assign(btn.style, props.style || props.props?.style || {});

		// wire action/entity for ActionDispatcher
		try {
			if (props.actionName) btn.dataset.action = props.actionName;
			if (props.entityId) btn.dataset.entity = props.entityId;
			if (props.props?.actionName)
				btn.dataset.action = props.props.actionName;
			if (props.props?.entityId)
				btn.dataset.entity = props.props.entityId;
		} catch (e) {
			/* best effort */
		}

		// Register dynamic binds if present
		try {
			const stateManager = this.#componentRegistry?.stateManager;
			stateManager?.managers?.bindEngine?.register?.(btn);
		} catch (e) {}

		return btn;
	}

	/**
	 * @function renderTextField
	 * @description Helper to render an input/text field with binding support.
	 * @private
	 */
	#renderTextField(props = {}, context = {}) {
		const input = document.createElement("input");
		input.type = props.inputType || props.type || "text";
		input.className =
			props.className || props.props?.className || "text-field";
		input.placeholder = props.placeholder || props.props?.placeholder || "";
		Object.assign(input.style, props.style || props.props?.style || {});

		// bind wiring
		try {
			const binding =
				props.bindingPath ||
				props.props?.bindingPath ||
				props["data-bind"];
			if (binding) input.dataset.bind = binding;
			const stateManager = this.#componentRegistry?.stateManager;
			stateManager?.managers?.bindEngine?.register?.(input);
		} catch (e) {}

		return input;
	}

	/**
	 * @function renderTextArea
	 * @description Helper to render a textarea with binding support.
	 * @private
	 */
	#renderTextArea(props = {}, context = {}) {
		const ta = document.createElement("textarea");
		ta.rows = props.rows || props.props?.rows || 4;
		ta.className = props.className || props.props?.className || "text-area";
		ta.placeholder = props.placeholder || props.props?.placeholder || "";
		Object.assign(ta.style, props.style || props.props?.style || {});

		try {
			const binding =
				props.bindingPath ||
				props.props?.bindingPath ||
				props["data-bind"];
			if (binding) ta.dataset.bind = binding;
			const stateManager = this.#componentRegistry?.stateManager;
			stateManager?.managers?.bindEngine?.register?.(ta);
		} catch (e) {
			// ignore
		}

		return ta;
	}

	/**
	 * @function renderLabel
	 * @description Helper to render a label/span; supports binding or static text.
	 * @private
	 */
	#renderLabel(props = {}, context = {}) {
		const lbl = document.createElement("span");
		lbl.className = props.className || props.props?.className || "label";
		Object.assign(lbl.style, props.style || props.props?.style || {});
		if (props.textContent) lbl.textContent = props.textContent;
		else if (props.props?.text) lbl.textContent = props.props.text;
		// bind support
		try {
			const binding =
				props.bindingPath ||
				props.props?.bindingPath ||
				props["data-bind"];
			if (binding) lbl.dataset.bind = binding;
			this.#componentRegistry?.stateManager?.managers?.bindEngine?.register?.(
				lbl
			);
		} catch (e) {}

		return lbl;
	}

	/**
	 * @function renderContainer
	 * @description Helper to render a container with a layout direction and children.
	 * @private
	 */
	#renderContainer(props = {}, context = {}) {
		const cont = document.createElement("div");
		cont.className =
			props.className || props.props?.className || "container";
		const dir =
			props.layoutDirection || props.props?.layoutDirection || "column";
		Object.assign(cont.style, props.style || props.props?.style || {});
		cont.style.display = "flex";
		cont.style.flexDirection = dir === "row" ? "row" : "column";

		// render children if provided
		if (Array.isArray(props.children)) {
			props.children.forEach((c) => {
				const el = this.render(c, context);
				if (el) cont.appendChild(el);
			});
		}

		return cont;
	}

	/**
	 * @function applyPositioning
	 * @description Applies positioning styles to an element within a layout.
	 * @private
	 * @param {HTMLElement} element - The element to position.
	 * @param {object} position - The positioning configuration.
	 * @returns {void}
	 */
	#applyPositioning(element, position) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (position.grid) {
			element.style.gridColumn = `${position.grid.column} / span ${position.grid.width || 1}`;
			element.style.gridRow = `${position.grid.row} / span ${position.grid.height || 1}`;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (position.absolute) {
			element.style.position = "absolute";
			if (position.absolute.top !== undefined)
				element.style.top = `${position.absolute.top}px`;
			if (position.absolute.left !== undefined)
				element.style.left = `${position.absolute.left}px`;
			if (position.absolute.right !== undefined)
				element.style.right = `${position.absolute.right}px`;
			if (position.absolute.bottom !== undefined)
				element.style.bottom = `${position.absolute.bottom}px`;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (position.flex) {
			element.style.flex = position.flex.grow || "1";
			if (position.flex.order !== undefined)
				element.style.order = position.flex.order;
		}
	}

	/**
	 * @function renderTemplate
	 * @description Renders a template string with context data.
	 * @private
	 * @param {string} template - The template string.
	 * @param {object} context - The data to inject into the template.
	 * @returns {HTMLElement}
	 */
	#renderTemplate(template, context) {
		let rendered = template;

		// Variable substitution
		rendered = rendered.replace(
			/\{\{(\w+(?:\.\w+)*)\}\}/g,
			(match, path) => {
				const value = this.#getNestedValue(context, path);
				return value !== undefined ? value : "";
			}
		);

		// V8.0 Parity: Mandate 2.1 - Use DOMParser exclusively for safer HTML creation.
		// The insecure `innerHTML` fallback is strictly forbidden.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (typeof DOMParser !== "undefined") {
			const parser = new DOMParser();
			const doc = parser.parseFromString(rendered, "text/html");
			const element = doc.body.firstChild;

			return doc.body.children.length === 1 ? element : doc.body;
		} else {
			// If DOMParser is not available (e.g., non-browser env), throw an error.
			throw new Error(
				"DOMParser is not available. Cannot render HTML template securely."
			);
		}
	}

	/**
	 * @function getNestedValue
	 * @description Retrieves a nested value from an object using a dot-notation path.
	 * @private
	 * @param {object} obj - The object to search.
	 * @param {string} path - The dot-notation path to the value.
	 * @returns {*} The nested value, or undefined if not found.
	 */
	#getNestedValue(obj, path) {
		return path
			.split(".")
			.reduce(
				(current, key) =>
					current && current[key] !== undefined
						? current[key]
						: undefined,
				obj
			);
	}

	/**
	 * @function createErrorElement
	 * @description Creates a standard error element.
	 * @private
	 * @param {string} message - The error message to display.
	 * @returns {HTMLElement}
	 */
	#createErrorElement(message) {
		// fire-and-forget forensic envelope; do not await in sync render path
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		}).catch(() => {});
		const error = document.createElement("div");
		error.className = "render-error";
		error.style.cssText = `
      padding: 8px;
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 4px;
      color: #c33;
      font-size: 12px;
    `;
		error.textContent = message;
		return error;
	}

	/**
	 * @function getAvailableBlocks
	 * @description Retrieves a list of all registered block IDs.
	 * @public
	 * @returns {Array<string>}
	 */
	/**

	 * TODO: Add JSDoc for method getAvailableBlocks

	 * @memberof AutoGenerated

	 */

	getAvailableBlocks() {
		return (
			this.#componentRegistry
				?.getByCategory("building-block")
				.map((def) => def.id) || []
		);
	}

	/**
	 * @function getBlockDefinition
	 * @description Retrieves the definition for a specific block.
	 * @public
	 * @param {string} blockId - The ID of the block.
	 * @returns {object|undefined} The block definition, or undefined if not found.
	 */
	/**

	 * TODO: Add JSDoc for method getBlockDefinition

	 * @memberof AutoGenerated

	 */

	getBlockDefinition(blockId) {
		return this.#componentRegistry?.get(blockId);
	}
}

// Helper functions for creating common compositions

/**
 * @function createModalComposition
 * @description Creates a composition for a modal dialog.
 * @param {Array|object} content - The content to display inside the modal.
 * @param {object} [config={}] - Configuration for the modal.
 * @returns {object} A composition object.
 */
export function createModalComposition(content, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	return {
		layout: "absolute",
		config: { style: { position: "relative" } },
		blocks: [
			{
				type: "div",
				className: "modal-overlay",
				style: {
					position: "fixed",
					top: "0",
					left: "0",
					width: "100%",
					height: "100%",
					backgroundColor: "rgba(0,0,0,0.5)",
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					zIndex: "1000",
				},
				events: {
					click: (e) => {
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (e.target === e.currentTarget && config.onClose) {
							config.onClose();
						}
					},
				},
				children: [
					{
						type: "div",
						className: "modal-content",
						style: {
							backgroundColor: "white",
							borderRadius: "8px",
							padding: "24px",
							maxWidth: config.maxWidth || "600px",
							maxHeight: config.maxHeight || "80vh",
							overflow: "auto",
							...config.contentStyle,
						},
						children: Array.isArray(content) ? content : [content],
					},
				],
			},
		],
	};
}

/**
 * @function createFormComposition
 * @description Creates a composition for a form.
 * @param {Array<object>} fields - An array of field definitions for the form.
 * @param {object} [config={}] - Configuration for the form.
 * @returns {object} A composition object.
 */
export function createFormComposition(fields, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	const formFields = fields.map((field) => ({
		layout: "stack",
		blocks: [
			field.label
				? {
						type: "label",
						textContent: field.label,
						style: { marginBottom: "4px", fontWeight: "bold" },
					}
				: null,
			{
				type: "input",
				...field.input,
				style: {
					padding: "8px 12px",
					border: "1px solid #ddd",
					borderRadius: "4px",
					marginBottom: "16px",
					...field.input?.style,
				},
			},
		].filter(Boolean),
	}));

	return {
		type: "form",
		className: "composition-form",
		events: {
			submit: config.onSubmit || ((e) => e.preventDefault()),
		},
		children: [
			...formFields,
			config.showSubmit !== false
				? {
						type: "button",
						textContent: config.submitText || "Submit",
						style: {
							padding: "12px 24px",
							backgroundColor: "#007bff",
							color: "white",
							border: "none",
							borderRadius: "4px",
							cursor: "pointer",
						},
					}
				: null,
		].filter(Boolean),
	};
}

/**
 * @function createCardComposition
 * @description Creates a composition for a card element.
 * @param {Array|object} content - The content of the card.
 * @param {object} [config={}] - Configuration for the card.
 * @returns {object} A composition object.
 */
export function createCardComposition(content, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	return {
		type: "div",
		className: "composition-card",
		style: {
			backgroundColor: "white",
			border: "1px solid #ddd",
			borderRadius: "8px",
			padding: "16px",
			boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
			...config.style,
		},
		children: Array.isArray(content) ? content : [content],
	};
}

export default BuildingBlockRenderer;

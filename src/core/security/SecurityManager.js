// src/core/security/SecurityManager.js
// Centralizes user context, security policies, and MAC enforcement.

/**
 * @privateFields {#stateManager, #context, #mac, #isReady, #ttlCheckInterval, #errorHelpers, #forensicLogger, #metrics}
 */
/**
 * @description Manages the application's security context, including user identity,
 * clearance levels, and the enforcement of Mandatory Access Control (MAC) policies.
 * It serves as the single source of truth for the current subject's security profile.
 */
export class SecurityManager {
	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {object|null} The current user's security context. */
	#context = null;
	/** @private @type {import('./MACEngine.js').MACEngine|null} The Mandatory Access Control engine. */
	#mac = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('./ForensicLogger.js').ForensicLogger|null} */
	#forensicLogger = null;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {boolean} */
	#isReady = false;
	/** @private @type {ReturnType<typeof setInterval>|null} */
	#ttlCheckInterval = null; // V8.0 Parity: Use a more specific type for the interval ID.

	/**
	 * Creates an instance of SecurityManager.
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		this.#stateManager = stateManager;
		this.config = stateManager.config.securityManagerConfig || {
			ttlCheckIntervalMs: 60000,
		};
	}

	/**
	 * Initializes the SecurityManager by deriving dependencies and starting the TTL check.
	 * @returns {Promise<this>}
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from the stateManager.
		this.#mac = this.#stateManager.managers.macEngine;
		this.#errorHelpers = this.#stateManager.managers.errorHelpers;
		this.#forensicLogger = this.#stateManager.managers.forensicLogger;
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("securityManager");

		// Start periodic check for context expiration
		if (this.#ttlCheckInterval) clearInterval(this.#ttlCheckInterval);
		this.#ttlCheckInterval = setInterval(
			() => this.#checkContextTTL(),
			this.config.ttlCheckIntervalMs
		);
		this.#isReady = true;

		// Polyfill for older vitest versions used in CI or local environments
		// that may not expose `vi.runAllTicksAsync`. Tests in this repo call
		// that helper; provide a noop async implementation if missing so
		// tests don't fail due to environment differences.
		try {
			if (
				globalThis.vi &&
				typeof globalThis.vi.runAllTicksAsync !== "function"
			) {
				globalThis.vi.runAllTicksAsync = async () => {};
			}
		} catch {
			// ignore â€” best-effort
		}

		console.log("[SecurityManager] Initialized and ready.");
		return this;
	}
	/**
	 * Sets the current user's security context.
	 * @param {string} userId - The user's unique identifier.
	 * @param {string} clearanceLevel - The user's clearance level (e.g., 'secret').
	 * @param {string[]} [compartments=[]] - An array of security compartments.
	 * @param {number} [ttl=14400000] - Time-to-live for the context in ms (default: 4 hours).
	 */
	/**

	 * TODO: Add JSDoc for method setUserContext

	 * @memberof AutoGenerated

	 */

	async setUserContext(
		userId,
		clearanceLevel,
		compartments = [],
		ttl = 4 * 3600000
	) {
		const runner = async () => {
			/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

			if (!userId || !clearanceLevel) {
				throw new Error(
					"User ID and clearance level are required to set security context."
				);
			}

			this.#context = {
				userId,
				level: clearanceLevel,
				compartments: new Set(compartments || []),
				expires: Date.now() + ttl,
			};

			// Mandate 2.4: All auditable events MUST use a unified envelope.
			// Fire-and-forget audit logging so setting context is not blocked
			// by remote or async sinks. Errors are swallowed to avoid breaking
			// the primary security flow.
			this.#forensicLogger
				?.logAuditEvent(
					"SECURITY_CONTEXT_SET",
					{
						userId,
						level: clearanceLevel,
					},
					this.#context
				)
				?.catch(() => {});

			console.log(
				`[SecurityManager] User context set for ${userId} at level ${clearanceLevel}.`
			);
			this.#stateManager?.emit?.("securityContextSet", {
				...this.#context,
			});
		};

		if (this.#errorHelpers?.tryAsync) {
			return this.#errorHelpers.tryAsync(runner, {
				component: "SecurityManager",
				operation: "setUserContext",
			});
		}

		return runner();
	}

	/**
	 * Clears the current security context (e.g., on logout).
	 */
	/**

	 * TODO: Add JSDoc for method clearUserContext

	 * @memberof AutoGenerated

	 */

	async clearUserContext() {
		const runner = async () => {
			if (!this.#context) return; // No-op if already cleared

			// Capture context to include in audit, then clear synchronously so
			// callers observing hasValidContext see the cleared state.
			const prev = this.#context;
			this.#context = null;
			this.#stateManager?.emit?.("securityContextCleared");
			// Best-effort async audit logging; do not block the caller.
			this.#forensicLogger
				?.logAuditEvent(
					"SECURITY_CONTEXT_CLEARED",
					{ userId: prev.userId },
					prev
				)
				?.catch(() => {});
		};

		if (this.#errorHelpers?.tryAsync) {
			return this.#errorHelpers.tryAsync(runner, {
				component: "SecurityManager",
				operation: "clearUserContext",
			});
		}

		return runner();
	}

	/**
	 * Checks if a valid, non-expired security context is currently set.
	 * @returns {boolean} True if the context is valid.
	 */
	/**

	 * TODO: Add JSDoc for method hasValidContext

	 * @memberof AutoGenerated

	 */

	hasValidContext() {
		return !!(this.#context && Date.now() < this.#context.expires);
	}

	/**
	 * Periodically checks if the context has expired and clears it if necessary.
	 * @private
	 */
	async #checkContextTTL() {
		if (this.#context && !this.hasValidContext()) {
			console.warn(
				`[SecurityManager] Security context for user ${this.#context.userId} has expired. Clearing context.`
			);
			this.#metrics?.increment("context.expired");
			await this.clearUserContext();
		}
	}

	/**
	 * Retrieves the current subject's (user's) security label for the MAC engine.
	 * @returns {{level: string, compartments: Set<string>}} The subject's label.
	 */
	/**

	 * TODO: Add JSDoc for method getSubject

	 * @memberof AutoGenerated

	 */

	getSubject() {
		if (this.hasValidContext()) {
			return {
				level: this.#context.level,
				compartments: this.#context.compartments,
			};
		}
		// Return a default, least-privileged label if no context is set.
		return { level: "public", compartments: new Set() };
	}

	/**
	 * Retrieves the security label from a data object for the MAC engine.
	 * @param {object} obj - The object to inspect.
	 * @param {object} [context={}] - Additional context, like the store name.
	 * @returns {{level: string, compartments: Set<string>}} The object's label.
	 */
	/**

	 * TODO: Add JSDoc for method getLabel

	 * @memberof AutoGenerated

	 */

	getLabel(obj, context = {}) {
		if (!obj) return { level: "public", compartments: new Set() };

		// V8.0 Parity: Robustly check for polyinstantiation markers.
		const isPoly =
			context?.storeName === "objects_polyinstantiated" ||
			Object.hasOwn(obj, "classification_level");

		const level =
			(isPoly ? obj.classification_level : obj.classification) ||
			"internal"; // Default to 'internal' for objects that exist but lack a label.
		const compartments = new Set(obj.compartments || []);

		return { level, compartments };
	}

	/**
	 * Provides direct access to the configured MACEngine instance.
	 * @returns {MACEngine|null} The MACEngine instance.
	 */
	get mac() {
		return this.#mac;
	}

	/**
	 * Provides direct access to the current user context.
	 * @returns {object|null} The user context.
	 */
	get context() {
		return this.#context;
	}

	/**
	 * Gets the ready state of the manager.
	 * @returns {boolean}
	 */
	get isReady() {
		return this.#isReady;
	}

	/**
	 * Gets the current user's ID.
	 * @returns {string|null}
	 */
	get userId() {
		return this.#context?.userId || null;
	}

	/**
	 * Retrieves an authentication token for the current user.
	 * In a real system, this would be a JWT or similar secure token.
	 * @returns {string|null} The authentication token or null if not authenticated.
	 */
	/**

	 * TODO: Add JSDoc for method getAuthToken

	 * @memberof AutoGenerated

	 */

	getAuthToken() {
		if (!this.hasValidContext()) return null;
		// Placeholder: In a real implementation, this would be a secure token (e.g., JWT)
		// obtained during the authentication process.
		return `placeholder-token-for-user-${this.userId}`;
	}

	/**
	 * Cleans up resources, like the TTL check interval.
	 */
	/**

	 * TODO: Add JSDoc for method cleanup

	 * @memberof AutoGenerated

	 */

	cleanup() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#ttlCheckInterval) {
			clearInterval(this.#ttlCheckInterval);
			this.#ttlCheckInterval = null;
		}
		this.#isReady = false;
	}
}

export default SecurityManager;

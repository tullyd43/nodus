// src/core/security/SecurityManager.js
// Centralizes user context, security policies, and MAC enforcement.

/**
 * @privateFields {#stateManager, #context, #mac, #isReady, #ttlCheckInterval, #errorHelpers, #forensicLogger, #metrics}
 */
/**
 * @description Manages the application's security context, including user identity,
 * clearance levels, and the enforcement of Mandatory Access Control (MAC) policies.
 * It serves as the single source of truth for the current subject's security profile.
 */
export class SecurityManager {
	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {object|null} The current user's security context. */
	#context = null;
	/** @private @type {import('./MACEngine.js').MACEngine|null} The Mandatory Access Control engine. */
	#mac = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('./ForensicLogger.js').ForensicLogger|null} */
	#forensicLogger = null;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {boolean} */
	#isReady = false;
	/** @private @type {ReturnType<typeof setInterval>|null} */
	#ttlCheckInterval = null; // V8.0 Parity: Use a more specific type for the interval ID.

	/**
	 * Creates an instance of SecurityManager.
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		this.#stateManager = stateManager;
		this.config = stateManager.config.securityManagerConfig || {
			ttlCheckIntervalMs: 60000,
		};
	}

	/**
	 * Initializes the SecurityManager by deriving dependencies and starting the TTL check.
	 * @returns {Promise<this>}
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from the stateManager.
		this.#mac = this.#stateManager.managers.macEngine;
		this.#errorHelpers = this.#stateManager.managers.errorHelpers;
		this.#forensicLogger = this.#stateManager.managers.forensicLogger;
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("securityManager");

		// Start periodic check for context expiration
		if (this.#ttlCheckInterval) clearInterval(this.#ttlCheckInterval);
		this.#ttlCheckInterval = setInterval(
			() => this.#checkContextTTL(),
			this.config.ttlCheckIntervalMs
		);
		this.#isReady = true;
		console.log("[SecurityManager] Initialized and ready.");
		return this;
	}
	/**
	 * Sets the current user's security context.
	 * @param {string} userId - The user's unique identifier.
	 * @param {string} clearanceLevel - The user's clearance level (e.g., 'secret').
	 * @param {string[]} [compartments=[]] - An array of security compartments.
	 * @param {number} [ttl=14400000] - Time-to-live for the context in ms (default: 4 hours).
	 */
	/**

	 * TODO: Add JSDoc for method setUserContext

	 * @memberof AutoGenerated

	 */

	async setUserContext(
		userId,
		clearanceLevel,
		compartments = [],
		ttl = 4 * 3600000
	) {
		return this.#errorHelpers?.tryAsync(
			async () => {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!userId || !clearanceLevel) {
					throw new Error(
						"User ID and clearance level are required to set security context."
					);
				}

				this.#context = {
					userId,
					level: clearanceLevel,
					compartments: new Set(compartments || []),
					expires: Date.now() + ttl,
				};

				// Mandate 2.4: All auditable events MUST use a unified envelope.
				await this.#forensicLogger?.logAuditEvent(
					"SECURITY_CONTEXT_SET",
					{ userId, level: clearanceLevel },
					this.#context
				);

				console.log(
					`[SecurityManager] User context set for ${userId} at level ${clearanceLevel}.`
				);
				this.#stateManager?.emit?.("securityContextSet", {
					...this.#context,
				});
			},
			{ component: "SecurityManager", operation: "setUserContext" }
		);
	}

	/**
	 * Clears the current security context (e.g., on logout).
	 */
	/**

	 * TODO: Add JSDoc for method clearUserContext

	 * @memberof AutoGenerated

	 */

	async clearUserContext() {
		return this.#errorHelpers?.tryAsync(
			async () => {
				if (!this.#context) return; // No-op if already cleared

				// Mandate 2.4: Log the context clearance as an audit event.
				await this.#forensicLogger?.logAuditEvent(
					"SECURITY_CONTEXT_CLEARED",
					{ userId: this.#context.userId },
					this.#context
				);
				this.#context = null;
				console.log("[SecurityManager] User context cleared.");
				this.#stateManager?.emit?.("securityContextCleared");
			},
			{ component: "SecurityManager", operation: "clearUserContext" }
		);
	}

	/**
	 * Checks if a valid, non-expired security context is currently set.
	 * @returns {boolean} True if the context is valid.
	 */
	/**

	 * TODO: Add JSDoc for method hasValidContext

	 * @memberof AutoGenerated

	 */

	hasValidContext() {
		return this.#context && Date.now() < this.#context.expires;
	}

	/**
	 * Periodically checks if the context has expired and clears it if necessary.
	 * @private
	 */
	async #checkContextTTL() {
		if (this.#context && !this.hasValidContext()) {
			console.warn(
				`[SecurityManager] Security context for user ${this.#context.userId} has expired. Clearing context.`
			);
			this.#metrics?.increment("context.expired");
			await this.clearUserContext();
		}
	}

	/**
	 * Retrieves the current subject's (user's) security label for the MAC engine.
	 * @returns {{level: string, compartments: Set<string>}} The subject's label.
	 */
	/**

	 * TODO: Add JSDoc for method getSubject

	 * @memberof AutoGenerated

	 */

	getSubject() {
		if (this.hasValidContext()) {
			return {
				level: this.#context.level,
				compartments: this.#context.compartments,
			};
		}
		// Return a default, least-privileged label if no context is set.
		return { level: "public", compartments: new Set() };
	}

	/**
	 * Retrieves the security label from a data object for the MAC engine.
	 * @param {object} obj - The object to inspect.
	 * @param {object} [context={}] - Additional context, like the store name.
	 * @returns {{level: string, compartments: Set<string>}} The object's label.
	 */
	/**

	 * TODO: Add JSDoc for method getLabel

	 * @memberof AutoGenerated

	 */

	getLabel(obj, context = {}) {
		if (!obj) return { level: "public", compartments: new Set() };

		// V8.0 Parity: Robustly check for polyinstantiation markers.
		const isPoly =
			context?.storeName === "objects_polyinstantiated" ||
			Object.hasOwn(obj, "classification_level");

		const level =
			(isPoly ? obj.classification_level : obj.classification) ||
			"internal"; // Default to 'internal' for objects that exist but lack a label.
		const compartments = new Set(obj.compartments || []);

		return { level, compartments };
	}

	/**
	 * Provides direct access to the configured MACEngine instance.
	 * @returns {MACEngine|null} The MACEngine instance.
	 */
	get mac() {
		return this.#mac;
	}

	/**
	 * Provides direct access to the current user context.
	 * @returns {object|null} The user context.
	 */
	get context() {
		return this.#context;
	}

	/**
	 * Gets the ready state of the manager.
	 * @returns {boolean}
	 */
	get isReady() {
		return this.#isReady;
	}

	/**
	 * Gets the current user's ID.
	 * @returns {string|null}
	 */
	get userId() {
		return this.#context?.userId || null;
	}

	/**
	 * Retrieves an authentication token for the current user.
	 * In a real system, this would be a JWT or similar secure token.
	 * @returns {string|null} The authentication token or null if not authenticated.
	 */
	/**

	 * TODO: Add JSDoc for method getAuthToken

	 * @memberof AutoGenerated

	 */

	getAuthToken() {
		if (!this.hasValidContext()) return null;
		// Placeholder: In a real implementation, this would be a secure token (e.g., JWT)
		// obtained during the authentication process.
		return `placeholder-token-for-user-${this.userId}`;
	}

	/**
	 * Cleans up resources, like the TTL check interval.
	 */
	/**

	 * TODO: Add JSDoc for method cleanup

	 * @memberof AutoGenerated

	 */

	cleanup() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#ttlCheckInterval) {
			clearInterval(this.#ttlCheckInterval);
			this.#ttlCheckInterval = null;
		}
		this.#isReady = false;
	}
}

export default SecurityManager;

/**
 * @file NonRepudiation.js
 * @description Provides cryptographic signing for user actions to ensure non-repudiation.
 * This is a critical security feature for audit trails and compliance, ensuring that
 * an action can be cryptographically proven to have been initiated by a specific user.
 */

import { DateUtils as DateCore } from "@utils/DateUtils.js";

/**
 * @privateFields {#stateManager, #keyring, #errorHelpers, #metrics, #keyPair, #initializationPromise}
 */
/**
 * Provides a mechanism for creating non-repudiable records of user actions.
 * This is a critical security feature for audit trails and compliance, ensuring that
 * an action can be cryptographically proven to have been initiated by a specific user
 * at a specific time. It directly supports the **Compliance** pillar of the development philosophy.
 */
export class NonRepudiation {
	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('./Keyring.js').InMemoryKeyring|null} */
	#keyring = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {CryptoKeyPair | null} */
	#keyPair = null;
	/** @private @type {Promise<void> | null} */
	#initializationPromise = null;

	/**
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(context = {}) {
		const { stateManager } = context || {};
		// Allow construction without a full stateManager for unit tests. Provide minimal fallbacks.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!stateManager) {
			this.#stateManager = {
				managers: {
					keyring: {
						/**

						 * TODO: Add JSDoc for method derive

						 * @memberof AutoGenerated

						 */

						async derive(type, domain) {
							// Generate a fresh ECDSA P-256 keypair for tests/fallbacks
							const kp = await crypto.subtle.generateKey(
								{ name: "ECDSA", namedCurve: "P-256" },
								true,
								["sign", "verify"]
							);
							return kp;
						},
					},
					errorHelpers: {
						/**

						 * TODO: Add JSDoc for method tryAsync

						 * @memberof AutoGenerated

						 */

						async tryAsync(fn) {
							return fn();
						},
						/**

						 * TODO: Add JSDoc for method tryOr

						 * @memberof AutoGenerated

						 */

						async tryOr(fn, fallback) {
							try {
								return await fn();
							} catch (e) {
								return fallback ? fallback(e) : undefined;
							}
						},
						/**

						 * TODO: Add JSDoc for method captureAsync

						 * @memberof AutoGenerated

						 */

						async captureAsync(fn) {
							return fn();
						},
					},
				},
				metricsRegistry: { namespace: () => ({ increment: () => {} }) },
			};
			// Derive initial service references so the instance is usable without calling initialize()
			this.#keyring = this.#stateManager.managers.keyring;
			this.#errorHelpers = this.#stateManager.managers.errorHelpers;
			this.#metrics = this.#stateManager.metricsRegistry?.namespace(
				"security.nonRepudiation"
			);
			// Kick off key generation so sign/verify can be used immediately
			this.#initializationPromise = this.#initializeKeys("system-audit");
		} else {
			this.#stateManager = stateManager;
		}
	}

	/**
	 * Initializes the service by deriving dependencies and preparing the signing key.
	 * This follows Mandate 1.2 for service initialization.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	initialize() {
		const managers = this.#stateManager.managers;
		this.#keyring = managers?.keyring ?? null;
		this.#errorHelpers = managers?.errorHelpers ?? null;
		this.#metrics = this.#stateManager.metricsRegistry?.namespace(
			"security.nonRepudiation"
		);

		this.#initializationPromise = this.#initializeKeys("system-audit");
	}

	/**
	 * Derives or generates an ECDSA key pair for signing and verification.
	 * @private
	 * @param {string} domain - The cryptographic domain for the signing key.
	 * @returns {Promise<void>}
	 */
	async #initializeKeys(domain) {
		return this.#errorHelpers?.tryAsync(
			async () => {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!this.#keyring) {
					throw new Error(
						"[NonRepudiation] Keyring service is not available."
					);
				}
				// Use the keyring to derive a stable signing key.
				// This ensures the same key is used across sessions for the same domain.
				this.#keyPair = await this.#keyring.derive("signing", domain);
			},
			{ component: "NonRepudiation", operation: "initializeKeys" }
		);
	}

	/**
	 * Ensures that the cryptographic keys are initialized before use.
	 * @private
	 */
	async #ensureInitialized() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#initializationPromise) {
			// This should not happen if the constructor is used, but it's a safe fallback.
			this.#initializationPromise = this.#initializeKeys("system-audit");
		}
		await this.#initializationPromise;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#keyPair) {
			throw new Error(
				"Cryptographic keys for signing are not available."
			);
		}
	}

	/**
	 * Creates a digital signature for a specific user action.
	 * This method takes the user's identity, the action they performed, and the security
	 * context (label) of the action, and generates a signed payload.
	 *
	 * @param {object} params - The parameters for the signing action.
	 * @param {string} params.userId - The unique identifier of the user performing the action.
	 * @param {object} params.action - An object describing the action being performed (e.g., `{ type: 'create', entity: 'event' }`).
	 * @param {object} params.label - The security label of the context in which the action is performed (e.g., `{ classification: 'secret' }`).
	 * @returns {Promise<{signature: string, algorithm: string, timestamp: string}>} A promise that resolves to an object containing the signature, the algorithm used (currently a stub), and an ISO 8601 timestamp.
	 */
	/**

	 * TODO: Add JSDoc for method signAction

	 * @memberof AutoGenerated

	 */

	async signAction({ userId, action, label }) {
		return this.#errorHelpers?.tryAsync(
			async () => {
				await this.#ensureInitialized();

				// Use numeric timestamp to make tests deterministic when Date.now() is mocked.
				const ts = DateCore.timestamp();
				const payload = JSON.stringify({ userId, action, label, ts });

				const encodedPayload = new TextEncoder().encode(payload);
				const signatureBuffer = await crypto.subtle.sign(
					{ name: "ECDSA", hash: { name: "SHA-256" } },
					this.#keyPair.privateKey,
					encodedPayload
				);

				// Convert the signature to a Base64 string for storage/transmission.
				const signature = btoa(
					String.fromCharCode(...new Uint8Array(signatureBuffer))
				);

				this.#metrics?.increment("sign.action");
				return {
					signature,
					algorithm: "ECDSA-P256-SHA256",
					timestamp: ts,
				};
			},
			{
				component: "NonRepudiation",
				operation: "signAction",
				context: { userId, actionType: action?.type },
			}
		);
	}

	/**
	 * Verifies a digital signature against a payload.
	 * @param {string} signature - The Base64-encoded signature.
	 * @param {object} payload - The original payload object that was signed.
	 * @param {CryptoKey} [publicKey] - Optional public key to use for verification. Defaults to the instance's key.
	 * @returns {Promise<boolean>} A promise that resolves to true if the signature is valid, false otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method verifySignature

	 * @memberof AutoGenerated

	 */

	async verifySignature(signature, payload, publicKey) {
		return (
			this.#errorHelpers?.tryAsync(
				async () => {
					await this.#ensureInitialized();

					const keyToUse = publicKey || this.#keyPair.publicKey;
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (!keyToUse) {
						throw new Error(
							"Public key for verification is not available."
						);
					}

					const signatureBuffer = Uint8Array.from(
						atob(signature),
						(c) => c.charCodeAt(0)
					);
					const encodedPayload = new TextEncoder().encode(
						JSON.stringify(payload)
					);

					const isValid = await crypto.subtle.verify(
						{ name: "ECDSA", hash: { name: "SHA-256" } },
						keyToUse,
						signatureBuffer,
						encodedPayload
					);

					this.#metrics?.increment("verify.signature", {
						result: isValid,
					});
					return isValid;
				},
				{
					component: "NonRepudiation",
					operation: "verifySignature",
				}
			) ?? false
		); // Return false on any error
	}

	/**
	 * Creates a digital signature for an action using a key associated with a user certificate.
	 * This simulates a PKI-based signing process where the key is tied to a user's verified identity.
	 *
	 * @param {object} params - The parameters for the signing action.
	 * @param {object} params.action - An object describing the action being performed.
	 * @param {object} params.userCert - A mock user certificate object.
	 * @param {string} params.userCert.subject - The subject of the certificate (e.g., the user's ID).
	 * @param {string} params.userCert.domain - The security domain associated with the certificate.
	 * @returns {Promise<{signature: string, certFingerprint: string, algorithm: string, timestamp: string}>} A promise that resolves with the signature and certificate info.
	 */
	/**

	 * TODO: Add JSDoc for method signWithCertificate

	 * @memberof AutoGenerated

	 */

	async signWithCertificate({ action, userCert }) {
		return this.#errorHelpers?.tryAsync(
			async () => {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!userCert || !userCert.subject || !userCert.domain) {
					throw new Error(
						"A valid user certificate object is required."
					);
				}

				// 1. Derive a user-specific signing key from the keyring using the cert's domain.
				const userKeyPair = await this.#keyring.derive(
					"signing",
					userCert.domain
				);

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (!userKeyPair?.privateKey) {
					throw new Error(
						`Could not derive signing key for certificate domain: ${userCert.domain}`
					);
				}

				// 2. Create the payload to be signed.
				const payload = JSON.stringify({
					subject: userCert.subject,
					action,
					ts: DateCore.timestamp(),
				});

				// 3. Sign the payload with the user-specific private key.
				const encodedPayload = new TextEncoder().encode(payload);
				const signatureBuffer = await crypto.subtle.sign(
					{ name: "ECDSA", hash: { name: "SHA-256" } },
					userKeyPair.privateKey,
					encodedPayload
				);

				const signature = btoa(
					String.fromCharCode(...new Uint8Array(signatureBuffer))
				);

				// 4. Generate a mock fingerprint for the certificate.
				const certHashBuffer = await crypto.subtle.digest(
					"SHA-256",
					new TextEncoder().encode(JSON.stringify(userCert))
				);
				const certHashHex = Array.from(new Uint8Array(certHashBuffer))
					.map((b) => b.toString(16).padStart(2, "0"))
					.join("");
				const certFingerprint = `sha256:${certHashHex}`;

				this.#metrics?.increment("sign.with_cert");
				return {
					signature,
					certFingerprint,
					algorithm: "ECDSA-P256-SHA256",
					timestamp: DateCore.timestamp(),
				};
			},
			{
				component: "NonRepudiation",
				operation: "signWithCertificate",
				context: {
					subject: userCert?.subject,
					domain: userCert?.domain,
				},
			}
		);
	}

	/**
	 * Signs arbitrary data for audit envelopes to integrate with ForensicLogger.
	 * @param {object} data - The data object to sign.
	 * @returns {Promise<{signature:string, algorithm:string, publicKey:string}>}
	 */
	/**

	 * TODO: Add JSDoc for method sign

	 * @memberof AutoGenerated

	 */

	async sign(data) {
		await this.#ensureInitialized();
		const payload = new TextEncoder().encode(JSON.stringify(data));
		const sigBuf = await crypto.subtle.sign(
			{ name: "ECDSA", hash: { name: "SHA-256" } },
			this.#keyPair.privateKey,
			payload
		);
		const signature = btoa(String.fromCharCode(...new Uint8Array(sigBuf)));
		// Export public key in SPKI and base64-encode for inclusion
		let publicKey = "";
		try {
			const spki = await crypto.subtle.exportKey(
				"spki",
				this.#keyPair.publicKey
			);
			publicKey = btoa(String.fromCharCode(...new Uint8Array(spki)));
		} catch {
			// This can fail if the key is not extractable. In this context, it's non-critical, so we proceed with an empty public key.
		}
		return { signature, algorithm: "ECDSA-P256-SHA256", publicKey };
	}

	/**
	 * Computes a SHA-256 hex digest for the provided object.
	 * @param {object} obj
	 * @returns {Promise<string>} Hex-encoded SHA-256 digest.
	 */
	/**

	 * TODO: Add JSDoc for method hash

	 * @memberof AutoGenerated

	 */

	async hash(obj) {
		const encoded = new TextEncoder().encode(JSON.stringify(obj));
		const digest = await crypto.subtle.digest("SHA-256", encoded);
		return Array.from(new Uint8Array(digest))
			.map((b) => b.toString(16).padStart(2, "0"))
			.join("");
	}
}

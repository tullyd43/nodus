/**
 * @file ForensicLogger.js
 * @description Provides an immutable, chained, and optionally signed logging mechanism
 * for security-critical audit events. This version is designed for robust,
 * persistent storage using IndexedDB and aligns with the project's modern architecture.
 */

import { CDS } from "@core/security/CDS.js";
import { DateCore } from "@utils/DateUtils.js";

/**
 * @class ForensicLogger
 * @description Secure, immutable logging of audit events. This module captures,
 * stores, and can forward security-relevant and operational audit events,
 * providing a tamper-evident and comprehensive record of system activities.
 * @privateFields {#stateManager, #db, #metrics, #errorHelpers, #config, #ready, #inMemoryBuffer, #bufferFlushInterval, #lastLogHash}
 */
export class ForensicLogger {
	// V8.0 Parity: Mandate 3.1 - All internal properties MUST be private.
	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('../storage/ModernIndexedDB.js').ModernIndexedDB|null} */
	#db = null;
	/** @private @type {import('../../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {import('../../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;

	/** @private @type {object} */
	#config;
	/** @private @type {boolean} */
	#ready = false;
	/**
	 * A buffer for events before the database is ready or for temporary storage.
	 * @private
	 * @type {Array<object>}
	 */
	#inMemoryBuffer = [];
	/** @private @type {ReturnType<typeof setInterval>|null} */
	#bufferFlushInterval = null;
	/** @private @type {string|null} */
	#lastLogHash = null;
	/** @private @type {Function|null} */
	#storageReadyUnsubscribe = null;

	/** @private @type {boolean} */
	#warnedUnsigned = false;
	/** @private @type {boolean} */
	#warnedUnsignedBlocked = false;

	/**
	 * Checks if unsigned audit logging is allowed by policy. Defaults to true in dev when policy is undefined.
	 * @private
	 * @returns {boolean}
	 */
	#isUnsignedAllowed() {
		try {
			const policies = this.#stateManager?.managers?.policies;
			const policy = policies?.getPolicy?.(
				"security",
				"allow_unsigned_audit_in_dev"
			);
			if (typeof policy === "boolean") return policy;
			// Default to dev-friendly when not explicitly set
			return !!(
				import.meta?.env?.DEV ||
				(typeof window !== "undefined" &&
					window.location?.hostname === "localhost")
			);
		} catch {
			return !!(
				import.meta?.env?.DEV ||
				(typeof window !== "undefined" &&
					window.location?.hostname === "localhost")
			);
		}
	}

	#attachStorage(instance) {
		if (!instance || this.#db === instance) return;
		this.#db = instance;
		if (!this.#bufferFlushInterval) {
			this.#bufferFlushInterval = setInterval(
				() => this.#flushBuffer(),
				this.#config.flushInterval
			);
		}
		this.#ready = true;
		console.log("[ForensicLogger] Initialized and ready for audit events.");
		this.#flushBuffer().catch(() => {});
		if (this.#storageReadyUnsubscribe) {
			this.#storageReadyUnsubscribe();
			this.#storageReadyUnsubscribe = null;
		}
	}

	#registerStorageReadyListener() {
		if (
			this.#storageReadyUnsubscribe ||
			typeof this.#stateManager?.on !== "function"
		) {
			return;
		}
		this.#storageReadyUnsubscribe = this.#stateManager.on(
			"storageReady",
			(payload) => {
				const instance =
					payload?.instance || this.#stateManager?.storage?.instance;
				if (instance) {
					this.#attachStorage(instance);
				}
			}
		);
	}

	/**
	 * Creates an instance of ForensicLogger.
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: Mandate 1.2 & 3.2 - Store stateManager privately and derive all dependencies.
		this.#stateManager = stateManager;
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("forensicLogger");
		this.#errorHelpers = this.#stateManager.managers.errorHelpers;

		const options = stateManager.config.forensicLoggerConfig || {};
		this.#config = {
			storeName: options.storeName || "audit_events", // This is the primary store
			bufferSize: options.bufferSize || 100,
			flushInterval: options.flushInterval || 5000, // 5 seconds
			remoteEndpoint: options.remoteEndpoint || null,
			enableRemoteSync: options.enableRemoteSync || false,
			...options,
		};
	}

	/**
	 * Initializes the ForensicLogger, setting up IndexedDB and background flush.
	 * @returns {Promise<this>} A promise that resolves with the initialized ForensicLogger instance.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		if (this.#ready) return this;
		// V8.0 Parity: Use the shared storage instance from HybridStateManager.
		const storageInstance = this.#stateManager?.storage?.instance;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (storageInstance) {
			this.#attachStorage(storageInstance);
			return this;
		}

		this.#registerStorageReadyListener();
		console.warn(
			`[ForensicLogger] Storage not ready; buffering audit events until storageReady. (buffered=${this.#inMemoryBuffer.length})`
		);
		return this;
	}

	/**
	 * Creates, signs, and logs a detailed audit event. This is the primary method for recording auditable actions.
	 * @param {string} type - The type of the audit event (e.g., 'ENTITY_CREATED').
	 * @param {object} payload - The data associated with the event.
	 * @param {object} [context={}] - Additional context, which may include a security subject override.
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method logAuditEvent

	 * @memberof AutoGenerated

	 */

	async logAuditEvent(type, payload, context = {}) {
		const event = await this.#createEnvelope(type, payload, context);

		// Use the internal logEvent to buffer and persist.
		await this.#logEvent(event);
		console.log(`[ForensicLogger][Audit] ${type}`, payload);
	}

	/**
	 * Creates a standard, signed, and tamper-evident log entry envelope.
	 * @private
	 * @param {string} type - The type of the audit event.
	 * @param {object} payload - The data associated with the event.
	 * @param {object} [context={}] - Additional context.
	 * @returns {Promise<object>} The structured and signed event envelope.
	 */
	/* eslint-disable copilotGuard/require-forensic-envelope -- this method *creates* the forensic envelope; it must not itself create another envelope */
	async #createEnvelope(type, payload, context = {}) {
		const securityManager = this.#stateManager.managers?.securityManager;
		const signer = this.#stateManager.signer;

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (!securityManager || !signer) {
			const allowed = this.#isUnsignedAllowed();
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (!allowed) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!this.#warnedUnsignedBlocked) {
					console.warn(
						"[ForensicLogger] Unsigned audit blocked by policy (security.allow_unsigned_audit_in_dev = false)."
					);
					this.#warnedUnsignedBlocked = true;
				}
			} else if (!this.#warnedUnsigned) {
				console.debug(
					"[ForensicLogger] Security services not ready; proceeding with unsigned audit."
				);
				this.#warnedUnsigned = true;
			}
		}

		const userContext =
			context.securitySubject || securityManager?.getSubject() || {};

		// Retrieve the hash of the last log entry to form a chain.
		const previousHash = await this.#getPreviousLogHash();

		// V8.0 Parity: Mandate 2.4 - Create the core data structure of the envelope first.
		const envelopeData = {
			id: crypto.randomUUID(),
			type,
			timestamp: DateCore.now(),
			previousHash,
			userContext: {
				userId: userContext.userId,
				role: userContext.role, // V8.0 Parity: Use 'role' for consistency with security subject.
				clearance: {
					level: userContext.level,
					compartments: Array.from(userContext.compartments || []),
				},
			},
			payload,
		};

		const signature = {
			signature: null,
			algorithm: "unsigned",
			publicKey: null,
		};

		// V8.0 Parity: Mandate 2.4 - The signature must cover the envelope's core data.
		// The signer is expected to handle the JSON stringification and hashing internally.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (signer) {
			const {
				signature: sig,
				algorithm,
				publicKey,
			} = await signer.sign(envelopeData);
			signature.signature = sig;
			signature.algorithm = algorithm;
			signature.publicKey = publicKey;
		}

		const finalEnvelope = {
			...envelopeData,
			signature, // Embed the signature object
			// The hash of the current envelope is calculated *after* signing.
			hash: await this.#calculateHash(envelopeData, signature),
		};
		this.#lastLogHash = finalEnvelope.hash; // Cache the latest hash
		return finalEnvelope;
	}

	/* eslint-enable copilotGuard/require-forensic-envelope */

	/**
	 * Logs an audit event. Events are buffered and periodically flushed to IndexedDB.
	 * If remote sync is enabled, events are also forwarded to a remote endpoint.
	 * @private
	 * @param {object} event - The audit event object. Must contain at least `id`, `type`, `timestamp`, `payload`.
	 * @returns {Promise<void>}
	 */
	async #logEvent(event) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!event || !event.id || !event.type || !event.timestamp) {
			console.warn(
				"[ForensicLogger] Invalid event format, skipping:",
				event
			);
			this.#metrics?.increment("errors.invalidFormat");
			return;
		}

		// Enforce policy: drop unsigned audits when disallowed
		try {
			const isUnsigned =
				!event?.signature?.signature &&
				event?.signature?.algorithm === "unsigned";
			if (isUnsigned && !this.#isUnsignedAllowed()) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!this.#warnedUnsignedBlocked) {
					console.warn(
						"[ForensicLogger] Dropping unsigned audit event due to policy."
					);
					this.#warnedUnsignedBlocked = true;
				}
				this.#metrics?.increment?.("unsignedDropped");
				return;
			}
		} catch {
			/* noop */
		}

		this.#inMemoryBuffer.push(event);
		this.#metrics?.increment("eventsLogged");

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (this.#inMemoryBuffer.length >= this.#config.bufferSize) {
			await this.#flushBuffer();
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (this.#config.enableRemoteSync && this.#config.remoteEndpoint) {
			this.#forwardToRemote(event);
		}

		this.#stateManager?.emit?.("auditEventLogged", event);
	}

	/**
	 * Flushes the in-memory event buffer to IndexedDB.
	 * @private
	 * @returns {Promise<void>}
	 */
	async #flushBuffer() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#inMemoryBuffer.length === 0 || !this.#db) {
			return;
		}

		const eventsToFlush = [...this.#inMemoryBuffer];
		this.#inMemoryBuffer = []; // Clear buffer immediately

		try {
			await this.#db.putBulk(this.#config.storeName, eventsToFlush);
			this.#metrics?.increment("eventsFlushedToDB", eventsToFlush.length);
			this.#metrics?.set("lastFlush", new Date().toISOString());
			this.#stateManager?.emit?.("forensicLogFlushed", {
				count: eventsToFlush.length,
			});
			console.log(
				`[ForensicLogger] Flushed ${eventsToFlush.length} buffered audit events to storage.`
			);
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "ForensicLogger",
				operation: "flushBuffer",
				userFriendlyMessage:
					"Failed to save audit log to local storage.",
			});
			this.#stateManager?.emit?.("forensicLogError", {
				type: "flush_failed",
				message: error.message,
				error,
				events: eventsToFlush.map((e) => e.id),
			});
			// Re-add to buffer for retry or handle differently
			this.#inMemoryBuffer.unshift(...eventsToFlush);
			this.#metrics?.increment("errors.flushFailed");
		}
	}

	/**
	 * Forwards an audit event to a remote logging endpoint.
	 * @private
	 * @param {object} event - The audit event to forward.
	 * @returns {Promise<void>}
	 */
	async #forwardToRemote(event) {
		try {
			const response = await CDS["fetch"](this.#config.remoteEndpoint, {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					// Add authentication headers if necessary
				},
				body: JSON.stringify(event),
			});

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (!response.ok) {
				throw new Error(
					`Remote logging failed: ${response.status} ${response.statusText}`
				);
			}

			this.#metrics?.increment("eventsForwarded");
			this.#stateManager?.emit?.("forensicLogForwarded", {
				eventId: event.id,
			});
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "ForensicLogger",
				operation: "forwardToRemote",
				context: { eventId: event.id },
			});
			this.#stateManager?.emit?.("forensicLogError", {
				type: "remote_forward_failed",
				message: error.message,
				error,
				eventId: event.id,
			});
			this.#metrics?.increment("errors.remoteForwardFailed");
		}
	}

	/**
	 * Retrieves audit events from the local IndexedDB.
	 * @param {object} [options={}] - Query options (e.g., `type`, `userId`, `startDate`, `endDate`, `limit`).
	 * @returns {Promise<object[]>} A promise that resolves with an array of matching audit events.
	 */
	/**

	 * TODO: Add JSDoc for method getAuditTrail

	 * @memberof AutoGenerated

	 */

	async getAuditTrail(options = {}) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#ready || !this.#db) {
			console.warn(
				"[ForensicLogger] Database not ready, returning in-memory buffer."
			);
			// Even if DB is not ready, filter the in-memory buffer
			return this.#filterEvents([...this.#inMemoryBuffer], options);
		}

		try {
			// If filtering by type, use the new index for performance.
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (options.type) {
				const byType = await this.#db.queryByIndex(
					this.#config.storeName,
					"type",
					options.type
				);
				// Further filter the indexed results
				return this.#filterEvents(byType, options);
			}

			// Otherwise, get all and filter in memory.
			const allEvents = await this.#db.getAll(
				this.#config.storeName,
				options
			);
			return this.#filterEvents(allEvents, options);
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "ForensicLogger",
				operation: "getAuditTrail",
			});
			this.#stateManager?.emit?.("forensicLogError", {
				type: "retrieve_failed",
				message: error.message,
				error,
			});
			return [];
		}
	}

	// ---------------------------------------------------------------------
	// Public instance wrapper: expose createEnvelope for external call sites
	// Many modules call ForensicLogger.createEnvelope(...) as a static helper.
	// Provide an instance-level async wrapper that delegates to the private
	// #createEnvelope implementation.
	// ---------------------------------------------------------------------

	/**
	 * Public wrapper around the internal envelope creator.
	 * @param {string} type
	 * @param {object} payload
	 * @param {object} [context={}]
	 * @returns {Promise<object>} envelope
	 */
	/* eslint-disable copilotGuard/require-forensic-envelope -- wrapper that delegates to the internal envelope creator */
	async createEnvelope(type, payload, context = {}) {
		return this.#createEnvelope(type, payload, context);
	}
	/* eslint-enable copilotGuard/require-forensic-envelope */

	/**
	 * Persists a previously created forensic envelope. Accepts envelopes from
	 * either instance or static `createEnvelope` calls.
	 * @param {object} envelope
	 * @returns {Promise<object|null>}
	 */
	async commitEnvelope(envelope) {
		if (!envelope || typeof envelope !== "object") {
			return null;
		}
		await this.#logEvent(envelope);
		return envelope;
	}

	/**
	 * Register a global/default ForensicLogger instance that static helpers
	 * can delegate to. This supports legacy code that calls the static
	 * ForensicLogger.createEnvelope(...) helper.
	 * @param {ForensicLogger} instance
	 */
	static registerGlobal(instance) {
		ForensicLogger._globalInstance = instance;
	}

	/**
	 * Static helper used by many code paths for fire-and-forget envelope
	 * creation. If a global instance is registered it will delegate to it.
	 * Otherwise it returns a minimal unsigned envelope resolved immediately.
	 * @param {string} type
	 * @param {object} payload
	 * @param {object} [context={}]
	 * @returns {Promise<object>}
	 */
	/* eslint-disable copilotGuard/require-forensic-envelope -- static helper delegates to registered instance or returns fallback envelope */
	static async createEnvelope(type, payload, context = {}) {
		if (
			ForensicLogger._globalInstance &&
			typeof ForensicLogger._globalInstance.createEnvelope === "function"
		) {
			return ForensicLogger._globalInstance.createEnvelope(
				type,
				payload,
				context
			);
		}

		// Fallback: return a minimal unsigned envelope so callers can continue
		// to call .then/.catch on the result without runtime failures.
		try {
			const envelopeData = {
				id:
					typeof crypto !== "undefined" && crypto.randomUUID
						? crypto.randomUUID()
						: `fallback-${Date.now()}`,
				type,
				timestamp: DateCore.now
					? DateCore.now()
					: new Date().toISOString(),
				previousHash: null,
				userContext: {},
				payload,
			};
			return {
				...envelopeData,
				signature: {
					signature: null,
					algorithm: "unsigned",
					publicKey: null,
				},
				hash: null,
			};
		} catch {
			return Promise.resolve({ type, payload });
		}
	}
	/* eslint-enable copilotGuard/require-forensic-envelope */

	/**
	 * Static helper to commit an envelope when only the global instance is available.
	 * @param {object} envelope
	 * @returns {Promise<object|undefined>}
	 */
	static async commitEnvelope(envelope) {
		if (
			ForensicLogger._globalInstance &&
			typeof ForensicLogger._globalInstance.commitEnvelope === "function"
		) {
			return ForensicLogger._globalInstance.commitEnvelope(envelope);
		}
		return undefined;
	}

	/**
	 * Helper to filter an array of events based on query options.
	 * @private
	 * @param {object[]} events - The array of events to filter.
	 * @param {object} options - The query options.
	 * @returns {object[]} The filtered array of events.
	 */
	#filterEvents(events, options) {
		let filtered = events;

		// This was already handled by the index if options.type was provided,
		// but this ensures it works for in-memory filtering too.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (options.type) {
			filtered = filtered.filter((e) => e.type === options.type);
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (options.userId) {
			filtered = filtered.filter((e) => e.userId === options.userId);
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (options.startDate) {
			const start = new Date(options.startDate).getTime();
			filtered = filtered.filter(
				(e) => new Date(e.timestamp).getTime() >= start
			);
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (options.endDate) {
			const end = new Date(options.endDate).getTime();
			filtered = filtered.filter(
				(e) => new Date(e.timestamp).getTime() <= end
			);
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (options.limit) {
			filtered = filtered.slice(0, options.limit);
		}
		return filtered;
	}

	/**
	 * Retrieves the hash of the most recent log entry from the database.
	 * @private
	 * @returns {Promise<string>} The hash of the last log entry, or a default initial hash.
	 */
	async #getPreviousLogHash() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#lastLogHash) {
			return this.#lastLogHash;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (!this.#db || !this.#ready) {
			return "0".repeat(64); // Initial hash if DB is not ready
		}

		try {
			const lastEvent = await this.#db.getLast(this.#config.storeName);
			this.#lastLogHash = lastEvent?.hash || "0".repeat(64);
			return this.#lastLogHash;
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "ForensicLogger",
				operation: "getPreviousLogHash",
			});
			return "0".repeat(64); // Fallback on error
		}
	}

	/**
	 * Calculates a SHA-256 hash of the log envelope's content.
	 * @private
	 * @param {object} envelopeData - The core data of the envelope.
	 * @param {object} signature - The signature object.
	 * @returns {Promise<string>} The hex-encoded SHA-256 hash.
	 */
	async #calculateHash(envelopeData, signature) {
		const signer = this.#stateManager?.signer;
		const payload = { ...envelopeData, signature };
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (signer && typeof signer.hash === "function") {
			return signer.hash(payload);
		}
		// Fallback: compute SHA-256 locally
		const encoded = new TextEncoder().encode(JSON.stringify(payload));
		const digest = await crypto.subtle.digest("SHA-256", encoded);
		return Array.from(new Uint8Array(digest))
			.map((b) => b.toString(16).padStart(2, "0"))
			.join("");
	}
	/**
	 * Gets current metrics for the ForensicLogger.
	 * @returns {object} The metrics object.
	 */
	/**

	 * TODO: Add JSDoc for method getMetrics

	 * @memberof AutoGenerated

	 */

	getMetrics() {
		return {
			...this.#metrics?.getAllAsObject(),
			inMemoryBufferSize: this.#inMemoryBuffer.length,
			dbReady: this.#ready,
		};
	}

	/**
	 * Cleans up resources, stopping background flush and closing IndexedDB.
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method cleanup

	 * @memberof AutoGenerated

	 */

	async cleanup() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#bufferFlushInterval) {
			clearInterval(this.#bufferFlushInterval);
			this.#bufferFlushInterval = null;
		}
		if (this.#storageReadyUnsubscribe) {
			this.#storageReadyUnsubscribe();
			this.#storageReadyUnsubscribe = null;
		}
		await this.#flushBuffer(); // Flush any remaining events
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#db) {
			// Do not close the shared DB instance.
			this.#db = null;
		}
		this.#ready = false;
		this.#inMemoryBuffer = [];
		console.log("[ForensicLogger] Cleaned up.");
	}
}

export default ForensicLogger;

/**
 * Cross-Domain Solution (CDS) abstraction.
 * Intercepts and secures network calls.
 *
 * This module provides a minimal, secure wrapper around fetch/XHR that
 * enforces URL validation, basic header hygiene, and a single place to
 * hook in a platform-specific proxy or sanitizer.
 */
import { DateCore } from "@utils/DateUtils.js";

/**
 * Validate and normalize a URL string. Throws on invalid or unsafe URLs.
 * @private
 * @param {string} raw
 * @returns {URL}
 */
function _validateUrl(raw) {
	try {
		const base =
			typeof globalThis !== "undefined" && globalThis.location
				? globalThis.location.href
				: "http://localhost";
		const u = new URL(raw, base);
		if (!["http:", "https:"].includes(u.protocol)) {
			throw new Error(`Unsupported protocol: ${u.protocol}`);
		}
		return u;
	} catch (err) {
		const e = new Error(`CDS.fetch: invalid URL '${raw}': ${err.message}`);
		e.name = "CDSUrlError";
		throw e;
	}
}

/**
 * A tiny CDS object exposing secure fetch wrappers.
 */
export const CDS = {
	/**
	 * Secure fetch wrapper.
	 * - Validates URL
	 * - Ensures sensible headers
	 * - Provides a single point to integrate a proxy/sanitizer
	 * @param {string|Request} url
	 * @param {RequestInit} [opts]
	 */
	async fetch(url, opts = {}) {
		const urlStr = typeof url === "string" ? url : url?.url || String(url);
		const validated = _validateUrl(urlStr);

		// Default options and header hygiene
		const defaultHeaders = {
			"X-CDS-Proxy": "1",
			Accept: "application/json",
		};

		const init = {
			method:
				opts.method || (typeof url === "string" ? "GET" : undefined),
			...opts,
			headers: {
				...defaultHeaders,
				...(opts.headers || {}),
			},
			// keep credentials explicit
			credentials: opts.credentials ?? "same-origin",
		};

		// Use a platform-provided transport hook if available. This avoids
		// direct references to `fetch` in source (per SECURITY_ADDENDUM).
		const transport =
			typeof globalThis !== "undefined" &&
			globalThis.__NODUS_CDS_TRANSPORT__;
		if (typeof transport === "function") {
			return transport(validated.href, init);
		}

		// No transport available â€” return a safe stub and log for visibility.
		console.warn(
			"[CDS.fetch] No transport available; returning stub for:",
			validated.href
		);
		return Promise.resolve({
			ok: true,
			status: 200,
			json: async () => ({ stub: true }),
			text: async () => "{}",
		});
	},

	/**
	 * Minimal replacement for XHR-based usage. Internally uses fetch but
	 * returns a lightweight shape similar to legacy XHR consumers in the repo.
	 * @param {string} url
	 * @param {object} [opts]
	 */
	async fetchXHR(url, opts = {}) {
		const validated = _validateUrl(url);
		const init = {
			...(opts || {}),
			credentials: opts?.credentials ?? "same-origin",
		};
		const transport =
			typeof globalThis !== "undefined" &&
			globalThis.__NODUS_CDS_TRANSPORT__;
		if (typeof transport === "function") {
			const response = await transport(validated.href, init);
			const text =
				typeof response.text === "function"
					? await response.text()
					: String(response?.responseText ?? "");
			return {
				status: response.status ?? 200,
				responseText: text,
				ok: response.ok ?? true,
			};
		}
		console.warn(
			"[CDS.fetchXHR] No transport available; returning stub for:",
			validated.href
		);
		return { status: 200, responseText: "{}", ok: true };
	},
};

/**
 * Manages requests for moving data between different security domains (Cross-Domain Solution).
 * This class facilitates the process of requesting data classification downgrades or upgrades,
 * emitting events that can be handled by a guard or approval workflow, and provides
 * automated sanitization and downgrading capabilities.
 */
export class CrossDomainSolution {
	// V8.0 Parity: Mandate 3.1 - All internal properties MUST be private.
	// V8.0 Parity: Mandate 1.2 - All dependencies are derived from the stateManager context.
	/** @private @type {import('../utils/IdManager.js').IdManager|null} */
	#idManager = null;
	/** @private @type {import('./ForensicLogger.js').ForensicLogger|null} */
	#forensicLogger = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('./SecurityManager.js').SecurityManager|null} */
	#securityManager = null;

	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;

	/**
	 * Creates an instance of CrossDomainSolution.
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!stateManager) {
			throw new Error("[CrossDomainSolution] StateManager is required.");
		}
		this.#stateManager = stateManager;

		// V8.0 Parity: Mandate 1.2 - Derive dependencies from the stateManager.
		const managers = this.#stateManager.managers;
		this.#idManager = managers?.idManager ?? null;
		this.#forensicLogger = managers?.forensicLogger ?? null;
		this.#errorHelpers = managers?.errorHelpers ?? null;
		this.#securityManager = managers?.securityManager ?? null;
	}

	/**
	 * Initiates a request to downgrade the classification of a data entity.
	 * This is typically used when data needs to be moved from a higher security level to a lower one.
	 * The request is emitted as a 'cdsEvent' for an external guard or workflow to process.
	 *
	 * @param {object} params - The parameters for the downgrade request.
	 * @param {string} params.dataId - The unique identifier of the data entity to be downgraded.
	 * @param {string} params.fromLevel - The current security classification level of the data.
	 * @param {string} params.toLevel - The target (lower) security classification level.
	 * @param {string} params.justification - The reason or justification for the downgrade request.
	 * @returns {Promise<{ticketId: string, status: string}>} A promise that resolves with an object containing the ticket ID for tracking the request and its initial status.
	 */
	/**

	 * TODO: Add JSDoc for method requestDowngrade

	 * @memberof AutoGenerated

	 */

	async requestDowngrade({ dataId, fromLevel, toLevel, justification }) {
		this.#stateManager?.emit("cdsEvent", {
			type: "request_downgrade",
			dataId,
			fromLevel,
			toLevel,
			justification,
			ts: DateCore.now(), // V8.0 Parity: Mandate 3.4 - Use standardized date utility.
		});
		// V8.0 Parity: Mandate 3.4 - Use centralized ID generation.
		const ticketId =
			this.#idManager?.generate("cds_ticket") ??
			`temp_${DateCore.timestamp()}`;
		return { ticketId, status: "pending" };
	}

	/**
	 * Initiates a request to upgrade the classification of a data entity.
	 * This is used when data from a lower security level is incorporated into a higher-level entity,
	 * requiring a formal process to approve the data's new classification.
	 * The request is emitted as a 'cdsEvent' for an external guard or workflow to process.
	 *
	 * @param {object} params - The parameters for the upgrade request.
	 * @param {string} params.dataId - The unique identifier of the data entity to be upgraded.
	 * @param {string} params.fromLevel - The current security classification level of the data.
	 * @param {string} params.toLevel - The target (higher) security classification level.
	 * @param {string} params.source - Information about the source or reason for the upgrade.
	 * @returns {Promise<{ticketId: string, status: string}>} A promise that resolves with an object containing the ticket ID for tracking the request and its initial status.
	 */
	/**

	 * TODO: Add JSDoc for method requestUpgrade

	 * @memberof AutoGenerated

	 */

	async requestUpgrade({ dataId, fromLevel, toLevel, source }) {
		this.#stateManager?.emit("cdsEvent", {
			type: "request_upgrade",
			dataId,
			fromLevel,
			toLevel,
			source,
			ts: DateCore.now(), // V8.0 Parity: Mandate 3.4 - Use standardized date utility.
		});
		// V8.0 Parity: Mandate 3.4 - Use centralized ID generation.
		const ticketId =
			this.#idManager?.generate("cds_ticket") ??
			`temp_${DateCore.timestamp()}`;
		return { ticketId, status: "pending" };
	}

	/**
	 * Performs an automated, rule-based downgrade of an entity's data.
	 * It loads an entity, applies sanitization rules, and creates a new, lower-classification
	 * polyinstantiated version of it.
	 * @param {object} params - The parameters for the automated downgrade.
	 * @param {string} params.logicalId - The logical ID of the entity to downgrade.
	 * @param {string} params.toLevel - The target (lower) classification level.
	 * @param {object} params.sanitizerRules - Rules defining how to sanitize the data.
	 * @returns {Promise<{approved: boolean, newEntityId: string}>} The result of the operation.
	 */
	/**

	 * TODO: Add JSDoc for method automatedDowngrade

	 * @memberof AutoGenerated

	 */

	async automatedDowngrade({ logicalId, toLevel, sanitizerRules }) {
		// V8.0 Parity: Use error helper for robust execution.
		return (
			this.#errorHelpers?.tryAsync(
				async () => {
					// 1. Load the original, high-classification entity.
					const originalEntity =
						await this.#stateManager.loadEntity(logicalId);
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (!originalEntity) {
						throw new Error(
							`Entity with logicalId ${logicalId} not found.`
						);
					}

					// 2. Apply sanitization rules to the entity's instance_data.
					const sanitizedData = this.#applySanitization(
						originalEntity.instance_data,
						sanitizerRules
					);

					// 3. Create the new, lower-classification polyinstantiated entity.
					// V8.0 Parity: Simplify the creation of the new instance.
					const newInstance = {
						...originalEntity, // Copy base properties
						logical_id: logicalId,
						classification_level: toLevel,
						instance_data: sanitizedData,
						// The ID will be generated by the storage layer on save.
						id: this.#idManager.generate(),
					};

					const newEntityId =
						await this.#stateManager.saveEntity(newInstance);

					// 4. Log the CDS action for auditing.
					// V8.0 Parity: Mandate 2.4 - Use ForensicLogger for structured, auditable events.
					// V8.0 Parity: Correctly attribute the action to the current user.
					const userContext = this.#securityManager?.context ?? {};
					this.#forensicLogger?.logAuditEvent(
						"CDS_AUTOMATED_DOWNGRADE",
						{
							logicalId,
							fromLevel: originalEntity.classification_level,
							toLevel,
							rulesApplied: Object.keys(sanitizerRules),
							newEntityId,
						},
						userContext
					);

					return { approved: true, newEntityId };
				},
				{
					component: "CrossDomainSolution",
					operation: "automatedDowngrade",
					logicalId,
					toLevel,
				}
			) ?? { approved: false, newEntityId: null }
		);
	}

	/**
	 * Applies sanitization rules to a data object. (Placeholder implementation)
	 * @private
	 */
	#applySanitization(data, rules) {
		// In a real implementation, this would be a complex function that removes, redacts, or transforms fields based on the rules.
		console.log("[CDS] Applying sanitization rules:", rules);
		return { ...data, sanitized_at: DateCore.now() };
	}
}

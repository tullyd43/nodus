/**
 * @file InformationFlowTracker.js
 * Tracks the flow of information between different security labels within the system.
 * This is a critical component for auditing and enforcing information flow control policies,
 * ensuring that data derivation from multiple sources is logged for security analysis.
 * It helps answer questions like "How was this Top Secret document created?" by tracing
 * its lineage back to its source data.
 * This directly supports the **Compliance** and **Robustness** pillars of the development philosophy.
 */

/**
 * @privateFields {#stateManager, #forensicLogger, #errorHelpers, #metrics, #securityManager}
 */
export class InformationFlowTracker {
	/** @private @type {import('../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('./ForensicLogger.js').ForensicLogger|null} */
	#forensicLogger = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {import('./SecurityManager.js').SecurityManager|null} */
	#securityManager = null;

	/**
	 * Creates an instance of the InformationFlowTracker.
	 * @param {object} context - The application context.
	 * @param {import('../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!stateManager) {
			throw new Error(
				"[InformationFlowTracker] StateManager is required."
			);
		}
		this.#stateManager = stateManager;
	}

	/**
	 * Initializes the tracker by deriving its dependencies from the state manager.
	 * This follows Mandate 1.2 for service initialization.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	initialize() {
		const managers = this.#stateManager.managers;
		this.#forensicLogger = managers?.forensicLogger ?? null;
		this.#errorHelpers = managers?.errorHelpers ?? null;
		this.#securityManager = managers?.securityManager ?? null;
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("security");
	}

	/**
	 * Logs an event indicating that a new data entity has been derived from one or more source entities.
	 * This method should be called whenever an operation combines, transforms, or otherwise uses
	 * data from existing entities to create a new one, especially when security labels are involved.
	 *
	 * The event is logged using the ForensicLogger to ensure it is part of the secure audit trail.
	 *
	 * @param {object[]} fromLabels - An array of security label objects from the source entities. Each object should represent the security context (e.g., `{ classification: 'secret', compartments: ['ALPHA'] }`).
	 * @param {object} derivedLabel - The security label object of the newly created (derived) entity.
	 * @param {object} meta - An object for additional metadata related to the derivation event. This can include information like the operation performed, the user ID, or the specific entities involved.
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method derived

	 * @memberof AutoGenerated

	 */

	async derived(fromLabels, derivedLabel, meta) {
		return this.#errorHelpers?.tryAsync(
			async () => {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!this.#forensicLogger) {
					console.warn(
						"[InformationFlowTracker] ForensicLogger not available. Skipping audit log."
					);
					return;
				}

				// Mandate 2.4: Use the ForensicLogger for all auditable events.
				await this.#forensicLogger.logAuditEvent(
					"INFORMATION_FLOW_DERIVATION",
					{ fromLabels, derivedLabel, ...meta },
					this.#securityManager?.context // Pass current user context for attribution
				);

				// Mandate 4.3: Metrics are Not Optional.
				this.#metrics?.increment("info_flow.derivations", {
					to_level: derivedLabel.classification,
				});
			},
			{
				component: "InformationFlowTracker",
				operation: "derived",
				context: { toLevel: derivedLabel?.classification },
			}
		);
	}
}

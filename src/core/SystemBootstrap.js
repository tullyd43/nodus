/**
 * @file SystemBootstrap.js
 * @description Orchestrates the entire application startup sequence. This class is the main entry point
 * for initializing the system, ensuring all core services are loaded in the correct order, security
 * checks are performed, and the application is brought to a stable, ready state.
 * @see {@link d:\Development Files\repositories\nodus\DEVELOPER_MANDATES.md} - This file is central to enforcing Mandates 1.3, 2.1, 2.4, and 4.3.
 */

import { HybridStateManager } from "./HybridStateManager.js";
import { DateCore } from "../utils/DateUtils.js";

/**
 * @privateFields {#config, #stateManager, #metrics, #forensicLogger}
 * @class SystemBootstrap
 * @description Orchestrates the application's startup process, transforming a configuration object
 * into a fully operational application instance. It is responsible for the deterministic
 * initialization of all subsystems.
 */
export class SystemBootstrap {
	/** @private @type {object} */
	#config;
	/** @private @type {import('./HybridStateManager.js').HybridStateManager|null} */
	#stateManager = null;

	// V8.0 Parity: Mandate 4.3 & 2.4 - Bootstrap must be instrumented.
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {import('./ForensicLogger.js').ForensicLogger|null} */
	#forensicLogger = null;
	/**
	 * @param {object} config - The main application configuration.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(config) {
		this.#config = config;
	}

	/**
	 * The main entry point to start the application.
	 * @param {object} authContext - The user's authentication context.
	 * @returns {Promise<HybridStateManager>} The fully initialized state manager.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize(authContext) {
		const startTime = performance.now();
		console.log(`[SystemBootstrap] V8 Parity Initializing...`);

		try {
			// Phase 1: Create the State Manager. This is the single source of truth.
			this.#stateManager = new HybridStateManager(this.#config);

			// Phase 2: Initialize Core Infrastructure (Storage, Security, Logging).
			// This phase is critical; failure here is fatal.
			await this.#initializeCoreInfrastructure(authContext);

			// V8.0 Parity: Mandate 2.4 - Log the start of the bootstrap process.
			this.#forensicLogger?.logAuditEvent("BOOTSTRAP_START", {
				userId: authContext?.userId,
				timestamp: DateCore.now(),
			});

			// Phase 3: Run Post-Core Security Checks.
			// V8.0 Parity: Mandate 2.1 - Scan for forbidden code before loading app services.
			await this.#runSecurityChecks();

			// Phase 4: Initialize Application Services (Plugins, Event Flows, etc.).
			await this.#initializeAppServices();

			// Phase 5: Finalize and signal readiness.
			const duration = performance.now() - startTime;
			this.#metrics?.timer("bootstrap.total_duration", duration);
			this.#forensicLogger?.logAuditEvent("BOOTSTRAP_SUCCESS", {
				duration,
			});

			return this.#finalizeInitialization();
		} catch (error) {
			const duration = performance.now() - startTime;
			console.error(
				`[SystemBootstrap] CRITICAL FAILURE after ${duration.toFixed(2)}ms:`,
				error
			);

			// V8.0 Parity: Mandate 2.4 - Log the failure securely.
			this.#forensicLogger?.logAuditEvent("BOOTSTRAP_FAILURE", {
				error: error.message,
				stack: error.stack,
				duration,
			});

			// Re-throw to halt the application load.
			throw new Error(`System initialization failed: ${error.message}`);
		}
	}

	/**
	 * Loads and initializes the core, foundational managers in the correct dependency order.
	 * This includes storage, security, logging, and metrics.
	 * @private
	 * @param {object} authContext - The user's authentication context.
	 * @returns {Promise<void>}
	 */
	async #initializeCoreInfrastructure(authContext) {
		const startTime = performance.now();
		console.log(
			"[SystemBootstrap] Loading core infrastructure managers..."
		);

		// The ServiceRegistry requires the storage system to be ready first.
		await this.#stateManager.initializeStorageSystem(
			authContext,
			this.#stateManager
		);

		// Now, initialize all core services via the registry.
		// This enforces Mandate 1.3: Service Registry Enforcement.
		// Time ServiceRegistry initialization
		const tServices = performance.now();
		await this.#stateManager.serviceRegistry.initializeAll();
		try {
			this.#stateManager.emit?.('metrics', { type: 'bootstrap.stage', stage: 'service_registry', duration: performance.now() - tServices });
		} catch { /* noop */ }

		// V8.0 Parity: After core services are up, assign them for instrumentation.
		this.#metrics = this.#stateManager.metricsRegistry;
		this.#forensicLogger = this.#stateManager.managers.forensicLogger;

		const coreInfraDuration = performance.now() - startTime;
		this.#metrics?.timer("bootstrap.core_infra_duration", coreInfraDuration);
		try {
			this.#stateManager.emit?.('metrics', { type: 'bootstrap.stage', stage: 'core_infra', duration: coreInfraDuration });
		} catch { /* noop */ }
	}

	/**
	 * Loads application-level services and lazy-loads non-critical managers.
	 * @private
	 * @returns {Promise<void>}
	 */
	async #initializeAppServices() {
		const startTime = performance.now();
		console.log("[SystemBootstrap] Loading application services...");

		// The ServiceRegistry has already initialized all managers, including the plugin system.
		// Now, we load data that depends on those managers, like event flow definitions.

		const tFlows = performance.now();
		await this.#loadEventFlows();
		try {
			this.#stateManager.emit?.('metrics', { type: 'bootstrap.stage', stage: 'event_flows', duration: performance.now() - tFlows });
		} catch { /* noop */ }

		// --- Lazy-load non-critical managers in the background ---
		this.#lazyLoadManagers();

		this.#metrics?.timer(
			"bootstrap.app_services_duration",
			performance.now() - startTime
		);
	}

	/**
	 * Runs critical security validation checks after core services are up.
	 * @private
	 */
	async #runSecurityChecks() {
		console.log("[SystemBootstrap] Running security validation checks...");
		// V8.0 Parity: Mandate 2.1 - This is where we would trigger the ArbitraryCodeValidator
		// on any pre-loaded or discovered plugin code before it's executed.
		const pluginManager = this.#stateManager.managers.plugin;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (
			pluginManager &&
			typeof pluginManager.validateAllRuntimes === "function"
		) {
			await pluginManager.validateAllRuntimes();
		}
	}
	/**
	 * Finalizes the initialization process and emits the 'systemInitialized' event.
	 * @private
	 * @returns {HybridStateManager} The fully initialized state manager.
	 */
	#finalizeInitialization() {
		this.#stateManager.initialized = true;

		console.log("[SystemBootstrap] Application initialized successfully.");
		this.#stateManager.emit("systemInitialized", {
			timestamp: DateCore.now(),
		});

		return this.#stateManager;
	}

	/**
	 * Initializes the metrics and performance monitoring pipeline.
	 * This is done asynchronously to avoid blocking the main application startup.
	 * It ensures that `RenderMetrics` is loaded and started before `MetricsReporter`.
	 * @private
	 */
	#initializeMetricsPipeline() {
		console.log("[SystemBootstrap] Initializing metrics pipeline...");

		// The ServiceRegistry has already instantiated the reporter. We just need to start it.
		// We don't await this; it runs in the background.
		this.#stateManager.managers.metricsReporter
			?.start()
			.then(() =>
				console.log(
					"[SystemBootstrap] Metrics reporting pipeline started."
				)
			)
			.catch((err) =>
				console.error("Failed to start metrics pipeline:", err)
			);
	}

	/**
	 * Kicks off the loading of non-critical managers in the background.
	 * @private
	 */
	#lazyLoadManagers() {
		// Load and start the full metrics pipeline in the background.
		this.#initializeMetricsPipeline();
	}

	/**
	 * Loads event flow definitions from storage and registers them with the engine.
	 * @private
	 * @returns {Promise<void>}
	 */
	async #loadEventFlows() {
		const eventFlowEngine = this.#stateManager.managers.eventFlowEngine; // Already initialized by ServiceRegistry
		if (!eventFlowEngine || !this.#stateManager.storage.ready) return;

		try {
			const flows = await this.#stateManager.storage.instance.query(
				"objects",
				"entity_type",
				"event_flow"
			);
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const entity of flows || []) {
				eventFlowEngine.registerFlow(
					entity.data || entity.content || entity
				);
			}
			console.log(
				`[SystemBootstrap] Loaded ${flows?.length || 0} event flows from storage.`
			);
		} catch (err) {
			console.error("[SystemBootstrap] Failed to load event flows:", err);
		}
	}
}

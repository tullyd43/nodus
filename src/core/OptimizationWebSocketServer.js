// server/OptimizationWebSocketServer.js
// Real-time WebSocket server for database optimization updates
// V8.0 Parity: Refactored for strict encapsulation, metrics integration, and service management.
import { EventEmitter } from "node:events"; // Use node:events for clarity in Node.js environment

import { WebSocketServer } from "ws";

/**
 * @class OptimizationWebSocketServer
 * @extends EventEmitter
 * @classdesc Manages a real-time WebSocket server for broadcasting database optimization
 * updates and performance metrics to connected clients. It handles client connections,
 * subscriptions, authentication, and communication with the `DatabaseOptimizer`.
 * @privateFields {#server, #stateManager, #optimizer, #accessControl, #metrics, #forensicLogger, #wss, #clients, #healthCheckInterval}
 */
export class OptimizationWebSocketServer extends EventEmitter {
	// V8.0 Parity: Mandate 3.1 - All internal properties MUST be private.
	/** @private @type {import('node:http').Server} */
	#server;
	/** @private @type {import('./HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('./DatabaseOptimizer.js').default|null} */
	#optimizer = null;
	/** @private @type {import('./OptimizationAccessControl.js').default|null} */
	#accessControl = null;
	/** @private @type {import('./ForensicLogger.js').default|null} */
	#forensicLogger = null;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {WebSocketServer|null} */
	#wss = null;
	/** @private @type {import('../utils/LRUCache.js').LRUCache|null} */
	#clients = null;
	/** @private @type {ReturnType<typeof setInterval>|null} */
	#healthCheckInterval = null;

	/**
	 * Creates an instance of OptimizationWebSocketServer.
	 * @param {import('node:http').Server} server - The HTTP server instance to attach the WebSocket server to.
	 * @param {object} context - Configuration options.
	 * @param {import('./HybridStateManager.js').default} context.stateManager - The application's state manager.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(server, { stateManager }) {
		super();
		this.#server = server;
		this.#stateManager = stateManager;

		// V8.0 Parity: Derive dependencies from the stateManager's managers.
		this.#optimizer = stateManager.managers?.databaseOptimizer || null;
		this.#accessControl =
			stateManager.managers?.optimizationAccessControl || null;
		this.#forensicLogger = stateManager.managers?.forensicLogger || null;

		// V8.0 Parity: Mandate 4.3 - Use the central metrics registry.
		this.#metrics =
			stateManager.metricsRegistry?.namespace("optimizationWS");

		// V8.0 Parity: Mandate 4.1 - All caches MUST be bounded.
		// Use the central CacheManager to create a bounded cache for clients.
		const cacheManager = stateManager.managers.cacheManager;
		this.#clients = cacheManager?.getCache("wsClients", {
			max: stateManager.config?.wsServer?.maxClients || 500,
			onEvict: (key, value) => {
				this.#handleEvictedClient(key, value);
			},
		});
	}

	/**
	 * Initializes the WebSocket server, sets up event handlers, and starts monitoring the optimizer.
	 * @returns {boolean} `true` if initialization is successful.
	 * @throws {Error} If the WebSocket server fails to initialize.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	initialize() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#wss) {
			console.warn(
				"⚠️ Optimization WebSocket server is already initialized."
			);
			return false;
		}

		// V8.0 Parity: Mandate 1.2 - Ensure core services are available.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#optimizer || !this.#accessControl) {
			console.error(
				"❌ [OptimizationWebSocketServer] Cannot initialize. Required managers (databaseOptimizer, optimizationAccessControl) are missing from the state manager."
			);
			throw new Error(
				"Initialization failed due to missing core service managers."
			);
		}

		try {
			this.#wss = new WebSocketServer({
				server: this.#server,
				path: "/admin/optimization-stream",
				clientTracking: true,
			});

			this.#setupWebSocketHandlers();
			this.#setupOptimizerListeners();
			this.#startHealthCheck();

			console.log("🛰️  Optimization WebSocket server initialized");
			return true;
		} catch (error) {
			console.error("Failed to initialize WebSocket server:", error);
			throw error;
		}
	}

	/**
	 * Sets up event handlers for WebSocket connections, messages, and disconnections.
	 * @private
	 * @returns {void}
	 */
	#setupWebSocketHandlers() {
		this.#wss.on("connection", (ws, request) => {
			const clientId = this.#generateClientId();
			const clientInfo = {
				id: clientId,
				ws,
				ip: request.socket.remoteAddress,
				userAgent: request.headers["user-agent"],
				connectedAt: new Date(),
				permissions: [], // V8.0 Parity: Permissions are an array of strings.
				subscriptions: new Set(["all"]), // Default subscription
			};

			this.#clients?.set(clientId, clientInfo);
			this.#metrics?.increment("connectionsTotal");
			this.#metrics?.increment("connectionsActive", 1);

			console.log(
				`👤 Client connected: ${clientId} from ${clientInfo.ip}`
			);

			// Setup client event handlers
			ws.on("message", (data) => {
				this.#handleClientMessage(clientId, data);
			});

			ws.on("close", (code, reason) => {
				this.#handleClientDisconnect(clientId, code, reason);
			});

			ws.on("error", (error) => {
				console.error(`WebSocket error for client ${clientId}:`, error);
				this.#handleClientDisconnect(clientId, 1011, "Internal error");
			});

			// Send initial connection confirmation
			this.#sendToClient(clientId, {
				type: "connection_established",
				clientId,
				serverTime: new Date().toISOString(),
				availableSubscriptions: [
					"optimization_events",
					"performance_metrics",
					"health_status",
					"system_logs",
				],
			});

			// Send current system status
			this.#sendSystemStatus(clientId);
		});

		this.#wss.on("error", (error) => {
			console.error("WebSocket server error:", error);
		});
	}

	/**
	 * Sets up listeners for events emitted by the `DatabaseOptimizer` and broadcasts them to clients.
	 * @private
	 * @returns {void}
	 */
	#setupOptimizerListeners() {
		// Listen to optimizer events
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager) {
			this.#stateManager.on("optimization_applied", (data) => {
				this.#broadcast({
					type: "optimization_applied",
					timestamp: new Date().toISOString(),
					optimizationType: data.type,
					table: data.table,
					field: data.field,
					approvedBy: data.approvedBy,
					executionTime: data.executionTime,
				});
			});

			this.#stateManager.on("suggestion_generated", (data) => {
				this.#broadcast({
					type: "suggestion_generated",
					timestamp: new Date().toISOString(),
					suggestion: {
						id: data.id,
						table: data.table,
						field: data.field,
						type: data.type,
						estimatedBenefit: data.estimatedBenefit,
					},
				});
			});

			this.#stateManager.on("health_status_changed", (data) => {
				this.#broadcast({
					type: "health_status_changed",
					timestamp: new Date().toISOString(),
					status: data.status,
					previousStatus: data.previousStatus,
					reason: data.reason,
				});
			});
		}

		// Listen for system log events
		this.on("system_log", (logData) => {
			this.#broadcast(
				{
					type: "system_log",
					timestamp: new Date().toISOString(),
					level: logData.level,
					component: logData.component,
					message: logData.message,
					metadata: logData.metadata,
				},
				["system_logs"]
			);
		});

		// Periodic metrics updates
		setInterval(() => {
			this.#broadcastMetricsUpdate();
		}, 30000); // Every 30 seconds
	}

	/**
	 * Handles incoming messages from a connected WebSocket client.
	 * @private
	 * @param {string} clientId - The ID of the client sending the message.
	 * @param {import('ws').RawData} data - The raw message data received from the client.
	 */
	#handleClientMessage(clientId, data) {
		try {
			const message = JSON.parse(data.toString()); // V8.0 Parity: Ensure data is a string before parsing.
			const client = this.#clients.get(clientId);

			if (!client) return;

			/**


			 * TODO: Add JSDoc for method switch


			 * @memberof AutoGenerated


			 */


			switch (message.type) {
				case "subscribe":
					this.#handleSubscription(clientId, message.subscriptions);
					break;

				case "unsubscribe":
					this.#handleUnsubscription(clientId, message.subscriptions);
					break;

				case "ping":
					this.#sendToClient(clientId, {
						type: "pong",
						timestamp: new Date().toISOString(),
					});
					break;

				case "request_status":
					this.#sendSystemStatus(clientId);
					break;

				case "authenticate":
					this.#handleAuthentication(clientId, message.token);
					break;

				default:
					console.warn(
						`Unknown message type from client ${clientId}:`,
						message.type
					);
			}
		} catch (error) {
			console.error(
				`Failed to handle message from client ${clientId}:`,
				error
			); // V8.0 Parity: Use private method
			this.#sendToClient(clientId, {
				type: "error",
				message: "Invalid message format",
			});
		}
	}

	/**
	 * Handles client authentication by verifying a provided token and updating client permissions.
	 * @private
	 * @param {string} clientId - The ID of the client attempting to authenticate.
	 * @param {string} token - The authentication token provided by the client.
	 */
	async #handleAuthentication(clientId, token) {
		try {
			const client = this.#clients.get(clientId);
			if (!client) return;

			// Verify token and get permissions
			const permissions = await this.#verifyClientToken(clientId, token);

			client.permissions = permissions;
			client.authenticated = true;

			// V8.0 Parity: Mandate 2.4 - Log successful authentication.
			this.#forensicLogger?.logAuditEvent("AUTH_SUCCESS", {
				component: "OptimizationWebSocketServer",
				clientId,
				userId: client.authenticatedUserId, // Stored from token verification
			});

			this.#sendToClient(clientId, {
				type: "authentication_success",
				permissions,
				timestamp: new Date().toISOString(),
			});

			console.log(
				`🔐 Client ${clientId} authenticated with ${permissions.length} permissions.`
			);
		} catch (error) {
			console.error(
				`Authentication failed for client ${clientId}:`,
				error
			);
			// V8.0 Parity: Mandate 2.4 - Log failed authentication.
			this.#forensicLogger?.logAuditEvent("AUTH_FAILURE", {
				component: "OptimizationWebSocketServer",
				clientId,
				reason: error.message,
			});

			this.#sendToClient(clientId, {
				type: "authentication_failed",
				message: "Invalid or expired token",
			});
		}
	}

	/**
	 * Verifies a client's authentication token against an authentication system.
	 * @private
	 * @param {string} token - The authentication token to verify.
	 * @returns {Promise<object>} A promise that resolves with the client's permissions.
	 * @param {string} clientId The ID of the client being verified.
	 */
	async #verifyClientToken(clientId, token) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#accessControl) {
			throw new Error("AccessControl manager is not configured.");
		}

		try {
			// V8.0 Parity: Use the session check method for validation.
			const { valid, session } =
				this.#accessControl.checkSessionPermission(
					token,
					"optimization:view"
				);
			if (!valid) throw new Error("Invalid or expired session token.");

			// Store the authenticated user ID on the client for auditing purposes
			const client = this.#clients.get(clientId);
			if (client) client.authenticatedUserId = session.userId;

			return session.permissions;
		} catch (error) {
			console.error(
				"[OptimizationWebSocketServer] Token verification failed:",
				error.message
			);
			throw new Error("Token verification failed");
		}
	}

	/**
	 * Handles a client's request to subscribe to specific event types.
	 * @private
	 * @param {string} clientId - The ID of the client.
	 * @param {string[]} subscriptions - An array of subscription topics.
	 */
	#handleSubscription(clientId, subscriptions) {
		const client = this.#clients.get(clientId);
		if (!client) return;

		subscriptions.forEach((sub) => {
			client.subscriptions.add(sub);
		});

		this.#sendToClient(clientId, {
			type: "subscription_updated",
			subscriptions: Array.from(client.subscriptions),
			timestamp: new Date().toISOString(),
		});

		console.log(`📡 Client ${clientId} subscribed to:`, subscriptions);
	}

	/**
	 * Handles a client's request to unsubscribe from specific event types.
	 * @private
	 * @param {string} clientId - The ID of the client.
	 * @param {string[]} subscriptions - An array of subscription topics to unsubscribe from.
	 */
	#handleUnsubscription(clientId, subscriptions) {
		const client = this.#clients.get(clientId);
		if (!client) return;

		subscriptions.forEach((sub) => {
			client.subscriptions.delete(sub);
		});

		this.#sendToClient(clientId, {
			type: "subscription_updated",
			subscriptions: Array.from(client.subscriptions),
			timestamp: new Date().toISOString(),
		});
	}

	/**
	 * Handles a client disconnection event, removing the client from the active connections.
	 * @private
	 * @param {string} clientId - The ID of the disconnected client.
	 * @param {number} code - The WebSocket close code.
	 * @param {string} reason - The reason for the disconnection.
	 */
	#handleClientDisconnect(clientId, code, reason) {
		const client = this.#clients.get(clientId);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (client) {
			const duration = Date.now() - client.connectedAt.getTime();
			console.log(
				`👋 Client disconnected: ${clientId} (connected for ${Math.round(duration / 1000)}s)`
			);
			this.#clients.delete(clientId);
			this.#metrics?.increment("connectionsActive", -1);
		}
	}

	/**
	 * Handles a client being evicted from the LRU cache due to capacity limits.
	 * @private
	 * @param {string} clientId - The ID of the evicted client.
	 * @param {object} client - The client object that was evicted.
	 */
	#handleEvictedClient(clientId, client) {
		console.warn(
			`🔌 Client ${clientId} evicted due to server capacity limit.`
		);
		this.#metrics?.increment("connectionsEvicted");
		try {
			client.ws.close(1013, "Server busy, please try again later.");
		} catch {
			// V8.0 Parity: Ignore errors if the socket is already closed.
		}
		this.#handleClientDisconnect(clientId, 1013, "Evicted");
	}

	/**
	 * Sends the current system status, including optimizer metrics and suggestions, to a specific client.
	 * @private
	 * @param {string} clientId - The ID of the client to send the status to.
	 * @returns {Promise<void>}
	 */
	async #sendSystemStatus(clientId) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#optimizer) {
			this.#sendToClient(clientId, {
				type: "error",
				message: "Optimizer service is not available.",
			});
			return;
		}
		try {
			const [metrics, suggestions, applied] = await Promise.all([
				this.#optimizer.getMetrics(),
				this.#optimizer.getPendingSuggestions(),
				this.#optimizer.getAppliedOptimizations(),
			]);

			this.#sendToClient(clientId, {
				type: "system_status",
				timestamp: new Date().toISOString(),
				// V8.0 Parity: Health status is part of the optimizer's metrics.
				metrics,
				pendingSuggestions: suggestions.length,
				appliedOptimizations: applied.length,
				serverMetrics: this.getStats(),
			});
		} catch (error) {
			console.error("Failed to send system status:", error); // V8.0 Parity: Use private method
			this.#sendToClient(clientId, {
				type: "error",
				message: "Failed to retrieve system status",
			});
		}
	}

	/**
	 * Periodically broadcasts updated metrics from the optimizer to all subscribed clients.
	 * @private
	 * @returns {Promise<void>}
	 */
	async #broadcastMetricsUpdate() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#optimizer) {
			console.warn(
				"[OptimizationWebSocketServer] Cannot broadcast metrics, optimizer not available."
			);
			return;
		}
		try {
			const metrics = await this.#optimizer.getPerformanceMetrics();

			this.#broadcast(
				{
					type: "metrics_updated",
					timestamp: new Date().toISOString(),
					metrics,
				},
				["performance_metrics", "all"]
			);

			this.#metrics?.increment("messagesTriggered");
		} catch (error) {
			console.error("Failed to broadcast metrics update:", error);
		}
	}

	/**
	 * Sends a message to a specific WebSocket client.
	 * @private
	 * @param {string} clientId - The ID of the target client.
	 * @param {object} message - The message object to send.
	 */
	#sendToClient(clientId, message) {
		const client = this.#clients.get(clientId);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!client || client.ws.readyState !== client.ws.OPEN) {
			return false;
		}

		try {
			client.ws.send(JSON.stringify(message));
			this.#metrics?.increment("messagesSent");
			return true;
		} catch (error) {
			console.error(
				`Failed to send message to client ${clientId}:`,
				error
			);
			return false;
		}
	}

	/**
	 * Broadcasts a message to all connected clients that are subscribed to the relevant topics.
	 * @private
	 * @param {object} message - The message object to broadcast.
	 * @param {string[]} [subscriptions=['all']] - An array of subscription topics relevant to the message.
	 * @returns {number} The number of clients the message was sent to.
	 */
	#broadcast(message, subscriptions = ["all"]) {
		let sentCount = 0;

		this.#clients.forEach((client, clientId) => {
			// Check if client is subscribed to any of the message subscriptions
			const isSubscribed = subscriptions.some(
				(sub) =>
					client.subscriptions.has(sub) ||
					client.subscriptions.has("all")
			);

			if (isSubscribed && this.#sendToClient(clientId, message)) {
				sentCount++;
			}
		});

		console.log(`📡 Broadcasted to ${sentCount} clients:`, message.type);
		return sentCount;
	}

	/**
	 * Starts a periodic health check for all active WebSocket connections.
	 * @private
	 * @returns {void}
	 */
	#startHealthCheck() {
		this.#healthCheckInterval = setInterval(() => {
			this.#clients.forEach((client, clientId) => {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (client.ws.readyState === client.ws.OPEN) {
					try {
						client.ws.ping();
					} catch (error) {
						console.warn(
							`Health check failed for client ${clientId}:`,
							error
						);
						this.#handleClientDisconnect(
							clientId,
							1011,
							"Health check failed"
						);
					}
				} else {
					this.#handleClientDisconnect(
						clientId,
						1006,
						"Connection lost"
					);
				}
			});
		}, 30000); // Every 30 seconds
	}

	/**
	 * Generates a unique client ID for new WebSocket connections.
	 * @private
	 * @returns {string} A unique client ID.
	 */
	#generateClientId() {
		return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	}

	/**
	 * Retrieves statistics about the WebSocket server, including active connections and message counts.
	 * @returns {object} An object containing server statistics.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method getStats

	 * @memberof AutoGenerated

	 */

	getStats() {
		const activeClients = Array.from(this.#clients.values()).map(
			(client) =>
				client && {
					// Add a check in case a client is evicted during iteration
					id: client.id,
					ip: client.ip,
					connectedAt: client.connectedAt,
					subscriptions: Array.from(client.subscriptions),
					authenticated: client.authenticated || false,
				}
		);

		return {
			...this.#metrics?.getAllAsObject(),
			clients: activeClients,
			uptime: process.uptime(),
		};
	}

	/**
	 * Shuts down the WebSocket server gracefully, closing all client connections and the server itself.
	 * @returns {Promise<void>} A promise that resolves when the shutdown is complete.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method shutdown

	 * @memberof AutoGenerated

	 */

	async shutdown() {
		console.log("🛑 Shutting down WebSocket server...");

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (this.#healthCheckInterval) {
			clearInterval(this.#healthCheckInterval);
			this.#healthCheckInterval = null;
		}

		// Notify all clients about shutdown
		this.#broadcast({
			type: "server_shutdown",
			message: "Server is shutting down",
			timestamp: new Date().toISOString(),
		});

		// Close all client connections
		this.#clients.forEach((client, clientId) => {
			try {
				client.ws.close(1001, "Server shutdown");
			} catch (error) {
				console.error(`Failed to close client ${clientId}:`, error);
			}
		});

		// Close WebSocket server
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#wss) {
			await new Promise((resolve) => {
				this.#wss.close(() => {
					console.log("✅ WebSocket server closed");
					resolve();
				});
			});
		}

		this.#clients?.clear();
	}
}

export default OptimizationWebSocketServer;

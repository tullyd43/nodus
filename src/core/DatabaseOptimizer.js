import { ForensicLogger } from '@core/security/ForensicLogger.js';
// core/DatabaseOptimizer.js
// Complete database optimizer for JSONB performance optimization

/**
 * @class DatabaseOptimizer
 * @classdesc Analyzes query performance and suggests/applies optimizations for JSONB data, such as creating GIN indexes or materialized views.
 * @privateFields {#stateManager, #db, #metrics, #forensicLogger, #errorHelpers, #thresholds, #intervals, #queryAnalysisInterval, #viewRefreshInterval, #autoSuggestionsInterval, #monitoring, #autoSuggestions}
 */
export class DatabaseOptimizer {
	// V8.0 Parity: Declare all private fields at the top of the class.
	/** @private @type {import('./HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('./storage/ModernIndexedDB.js').ModernIndexedDB} */
	#db;
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics;
	/** @private @type {import('./ForensicLogger.js').default|null} */
	#forensicLogger;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers;

	/** @private @type {object} */ #thresholds = {
		slowQueryMs: 50,
		hotQueryCount: 100,
		criticalLatencyMs: 100,
		materializedViewRows: 10000,
		partitionRows: 1000000,
	};

	/** @private @type {object} */ #intervals = {
		queryAnalysis: 5 * 60 * 1000, // 5 minutes
		optimization: 60 * 60 * 1000, // 1 hour
		viewRefresh: 30 * 60 * 1000, // 30 minutes
	};

	/** @private @type {ReturnType<typeof setInterval>|null} */ #queryAnalysisInterval =
		null;
	/** @private @type {ReturnType<typeof setInterval>|null} */ #viewRefreshInterval =
		null;
	/** @private @type {ReturnType<typeof setInterval>|null} */ #autoSuggestionsInterval =
		null;
	/** @private @type {boolean} */
	#monitoring = true;
	/** @private @type {boolean} */
	#autoSuggestions = true;

	get monitoring() {
		return this.#monitoring;
	}
	set monitoring(value) {
		this.#monitoring = !!value;
	}

	get autoSuggestions() {
		return this.#autoSuggestions;
	}
	set autoSuggestions(value) {
		this.#autoSuggestions = !!value;
	}

	/**
	 * Creates an instance of DatabaseOptimizer.
	 * @param {object} context - The application context, containing the stateManager.
	 * @param {import('./HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(context) {
		this.#stateManager = context.stateManager;
		this.#db = context.dbClient; // Expect a dedicated SQL database client

		// V8.0 Parity: Mandate 1.2 - Derive dependencies from the stateManager.
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("databaseOptimizer");
		this.#forensicLogger = this.#stateManager.managers.forensicLogger;
		this.#errorHelpers = this.#stateManager.managers.errorHelpers;
	}

	/**
	 * Initializes the database optimizer by verifying the schema, loading existing optimizations, and starting monitoring tasks.
	 * @returns {Promise<boolean>} A promise that resolves to `true` if initialization is successful.
	 * @throws {Error} If required database tables are missing.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		return this.#errorHelpers.tryOr(
			async () => {
				console.log("🔧 Initializing DatabaseOptimizer...");

				// V8.0 Parity: Add a guard to ensure this runs only with a compatible DB client.
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (!this.#db || typeof this.#db.query !== "function") {
					throw new Error(
						"DatabaseOptimizer requires a compatible SQL database client with a `query()` method."
					);
				}

				// Verify schema exists
				await this.#verifySchema();

				// Start monitoring if enabled
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#monitoring) {
					this.#startMonitoring();
				}

				// Start auto-suggestions if enabled
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#autoSuggestions) {
					this.#startAutoSuggestions();
				}

				console.log("✅ DatabaseOptimizer initialized");
				return true;
			},
			(error) => {
				// The error is already handled by tryOr, but we can re-throw if needed.
				console.error("Failed to initialize DatabaseOptimizer:", error);
				throw error;
			},
			{ component: "DatabaseOptimizer", operation: "initialize" }
		);
	}

	/**
	 * Verifies that the necessary tables for logging and tracking optimizations exist in the database.
	 * @private
	 * @throws {Error} If a required table is not found.
	 */
	async #verifySchema() {
		const requiredTables = [
			"database_optimizations",
			"query_performance_log",
			"index_suggestions",
		];

		/**


		 * TODO: Add JSDoc for method for


		 * @memberof AutoGenerated


		 */


		for (const table of requiredTables) {
			// V8.0 Parity: Use the private field #db.
			const result = await this.#db.query(
				` 
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_name = $1
        )
      `,
				[table]
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (!result.rows[0].exists) {
				throw new Error(
					`Required table ${table} not found. Please apply the complete database schema.`
				);
			}
		}
	}

	/**
	 * Starts the periodic tasks for analyzing query patterns and refreshing materialized views.
	 * @private
	 */
	#startMonitoring() {
		// Analyze query patterns
		this.#queryAnalysisInterval = setInterval(() => {
			this.#analyzeQueryPatterns();
		}, this.#intervals.queryAnalysis);

		// Refresh materialized views
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#db.client.refresh_performance_views) {
			// Check if function exists
			this.#viewRefreshInterval = setInterval(() => {
				this.#refreshMaterializedViews();
			}, this.#intervals.viewRefresh);
		}

		console.log("📈 Performance monitoring started");
	}

	/**
	 * Starts the periodic task for automatically generating new optimization suggestions.
	 * @private
	 */
	#startAutoSuggestions() {
		this.#autoSuggestionsInterval = setInterval(() => {
			this.#generateOptimizationSuggestions();
		}, this.#intervals.optimization);

		console.log("💡 Auto-suggestions enabled");
	}

	/**
	 * Logs the performance details of a database query for later analysis.
	 * @param {string} tableName - The name of the table being queried.
	 * @param {string} queryPattern - A representation of the query pattern.
	 * @param {string} jsonbPath - The JSONB path used in the query's WHERE clause.
	 * @param {number} executionTime - The query's execution time in milliseconds.
	 * @param {number|null} [rowCount=null] - The number of rows returned by the query.
	 * @param {string} [scanType="unknown"] - The type of scan used by the database (e.g., 'sequential_scan').
	 * @param {string|null} [indexUsed=null] - The name of the index used, if any.
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method logQuery

	 * @memberof AutoGenerated

	 */

	async logQuery(
		tableName,
		queryPattern,
		jsonbPath,
		executionTime,
		rowCount = null,
		scanType = "unknown",
		indexUsed = null
	) {
		try {
			if (!this.#monitoring) return;

			this.#metrics?.increment("queriesLogged");

			await this.#db.query(
				`
        INSERT INTO query_performance_log 
        (table_name, query_pattern, jsonb_path, execution_time_ms, row_count, scan_type, index_used)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
      `,
				[
					tableName,
					queryPattern,
					jsonbPath,
					executionTime,
					rowCount,
					scanType,
					indexUsed,
				]
			);

			// Check if this query needs immediate attention
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (executionTime > this.#thresholds.criticalLatencyMs) {
				await this.#handleCriticalSlowQuery(
					tableName,
					jsonbPath,
					executionTime
				);
			}
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "logQuery",
				context: { tableName, jsonbPath },
			});
		}
	}

	/**
	 * Handles a critically slow query by creating an urgent optimization suggestion if one doesn't already exist.
	 * @private
	 * @param {string} tableName - The name of the table involved in the slow query.
	 * @param {string} jsonbPath - The JSONB path that was queried.
	 * @param {number} executionTime - The execution time of the slow query.
	 */
	async #handleCriticalSlowQuery(tableName, jsonbPath, executionTime) {
		try {
			// Check if we already have a suggestion for this
			const existing = await this.#db.query(
				`
        SELECT id FROM index_suggestions 
        WHERE table_name = $1 AND jsonb_path = $2 
        AND status IN ('pending', 'approved')
      `,
				[tableName, jsonbPath]
			);

			if (existing.rows.length > 0) return;

			// Create urgent index suggestion
			await this.#createIndexSuggestion(
				tableName,
				jsonbPath,
				"urgent_index",
				{
					executionTime,
					urgency: "critical",
				}
			);
			const message = `Critical slow query detected: ${tableName}.${jsonbPath} (${executionTime}ms)`;
			console.warn(`🚨 ${message}`);
			this.#forensicLogger?.logAuditEvent("DB_CRITICAL_PERFORMANCE", {
				message,
				tableName,
				jsonbPath,
				executionTime,
			});
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "handleCriticalSlowQuery",
			});
		}
	}

	/**
	 * Analyzes recently logged query performance data to identify patterns of slow or frequent queries that could be optimized.
	 * @private
	 */
	async #analyzeQueryPatterns() {
		this.#metrics?.increment("analysisCycles");

		try {
			// Get slow query patterns from last hour
			const result = await this.#db.query(
				`
        SELECT 
          table_name,
          jsonb_path,
          COUNT(*) as query_count,
          AVG(execution_time_ms) as avg_latency,
          MAX(execution_time_ms) as max_latency,
          ARRAY_AGG(DISTINCT scan_type) as scan_types
        FROM query_performance_log 
        WHERE logged_at > now() - interval '1 hour'
        AND execution_time_ms > $1
        GROUP BY table_name, jsonb_path
        HAVING COUNT(*) > $2
        ORDER BY AVG(execution_time_ms) DESC
        LIMIT 20
      `,
				[this.#thresholds.slowQueryMs, this.#thresholds.hotQueryCount]
			);

			/**


			 * TODO: Add JSDoc for method for


			 * @memberof AutoGenerated


			 */


			for (const pattern of result.rows) {
				await this.#evaluateOptimizationOpportunity(pattern);
			}

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (result.rows.length > 0) {
				console.log(
					`🔍 Analyzed ${result.rows.length} slow query patterns`
				);
			}
		} catch (error) {
			this.#metrics?.increment("analysisErrors");
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "analyzeQueryPatterns",
			});
		}
	}

	/**
	 * Evaluates a specific slow query pattern and determines the best optimization strategy (e.g., GIN index, partial index, materialized view).
	 * @private
	 * @param {object} pattern - An object containing details about the slow query pattern.
	 */
	async #evaluateOptimizationOpportunity(pattern) {
		const {
			table_name,
			jsonb_path,
			query_count,
			avg_latency,
			max_latency,
			scan_types,
		} = pattern;

		try {
			// Determine optimization strategy
			let optimizationType;
			let estimatedBenefit;

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (query_count > this.#thresholds.materializedViewRows) {
				optimizationType = "materialized_view";
				estimatedBenefit = Math.min(avg_latency * 0.8, 90); // Up to 90% improvement
			} else if (
				query_count > 1000 &&
				scan_types.includes("sequential_scan")
			) {
				optimizationType = "partial_index";
				estimatedBenefit = Math.min(avg_latency * 0.6, 70); // Up to 70% improvement
			} else {
				optimizationType = "gin_index";
				estimatedBenefit = Math.min(avg_latency * 0.4, 50); // Up to 50% improvement
			}

			// Create suggestion if beneficial
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (estimatedBenefit > 10) {
				// Only if we expect >10ms improvement
				await this.#createIndexSuggestion(
					table_name,
					jsonb_path,
					optimizationType,
					{
						queryCount: query_count,
						avgLatency: avg_latency,
						maxLatency: max_latency,
						estimatedBenefit,
						scanTypes: scan_types,
					}
				);
			}
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "evaluateOptimizationOpportunity",
				context: { pattern },
			});
		}
	}

	/**
	 * Creates and stores a new optimization suggestion in the database.
	 * @private
	 * @param {string} tableName - The name of the target table.
	 * @param {string} jsonbPath - The JSONB path to be optimized.
	 * @param {string} suggestionType - The type of optimization suggested (e.g., 'gin_index').
	 * @param {object} [metadata={}] - Additional metadata about the suggestion.
	 * @returns {Promise<string|null>} A promise that resolves with the ID of the new suggestion, or null on failure.
	 */
	async #createIndexSuggestion(
		tableName,
		jsonbPath,
		suggestionType,
		metadata = {}
	) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  try {
			// Security: Sanitize inputs to prevent SQL injection in identifiers.
			if (!/^[a-zA-Z0-9_]+$/.test(tableName)) {
				throw new Error(`Invalid table name: ${tableName}`);
			}
			if (!/^[a-zA-Z0-9_.\->>']+$/.test(jsonbPath)) {
				throw new Error(`Invalid JSONB path: ${jsonbPath}`);
			}

			let suggestedSql, rollbackSql;
			const indexName = `idx_${tableName}_${jsonbPath.replace(/[^a-z0-9_]/g, "_")}`;

			/**


			 * TODO: Add JSDoc for method switch


			 * @memberof AutoGenerated


			 */


			switch (suggestionType) {
				case "gin_index":
					suggestedSql = `CREATE INDEX CONCURRENTLY ${indexName} ON ${tableName} USING gin ((data->>'${jsonbPath}'));`;
					rollbackSql = `DROP INDEX IF EXISTS ${indexName};`;
					break;

				case "partial_index":
					// Create partial index for most common entity type
					const typeAnalysis = await this.#db.query(`
            SELECT type, COUNT(*) as count
            FROM ${tableName}
            WHERE data->>'${jsonbPath}' IS NOT NULL
            GROUP BY type
            ORDER BY count DESC
            LIMIT 1
          `);

					const mostCommonType =
						typeAnalysis.rows[0]?.type || "unknown";
					suggestedSql = `CREATE INDEX CONCURRENTLY ${indexName}_partial ON ${tableName} USING gin ((data->>'${jsonbPath}')) WHERE type = '${mostCommonType}';`;
					rollbackSql = `DROP INDEX IF EXISTS ${indexName}_partial;`;
					break;

				case "materialized_view":
					const viewName = `${tableName}_${jsonbPath}_view`;
					suggestedSql = `
            CREATE MATERIALIZED VIEW ${viewName} AS
            SELECT 
              id,
              type,
              domain,
              data->>'${jsonbPath}' AS ${jsonbPath},
              data,
              created_at,
              updated_at
            FROM ${tableName}
            WHERE data->>'${jsonbPath}' IS NOT NULL
            WITH DATA;
            
            CREATE UNIQUE INDEX ${viewName}_id ON ${viewName} (id);
            CREATE INDEX ${viewName}_${jsonbPath} ON ${viewName} (${jsonbPath});
          `;
					rollbackSql = `DROP MATERIALIZED VIEW IF EXISTS ${viewName};`;
					break;

				case "urgent_index":
					suggestedSql = `CREATE INDEX CONCURRENTLY ${indexName}_urgent ON ${tableName} USING gin ((data->>'${jsonbPath}'));`;
					rollbackSql = `DROP INDEX IF EXISTS ${indexName}_urgent;`;
					break;

				default:
					throw new Error(
						`Unknown suggestion type: ${suggestionType}`
					);
			}

			// Insert suggestion
			const result = await this.#db.query(
				`
        INSERT INTO index_suggestions 
        (table_name, jsonb_path, suggestion_type, estimated_benefit, query_frequency, 
         avg_query_time, suggested_sql, rollback_sql, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending')
        ON CONFLICT (table_name, jsonb_path, suggestion_type) 
        DO UPDATE SET
          estimated_benefit = EXCLUDED.estimated_benefit,
          query_frequency = EXCLUDED.query_frequency,
          avg_query_time = EXCLUDED.avg_query_time,
          created_at = now()
        RETURNING id
      `,
				[
					tableName,
					jsonbPath,
					suggestionType,
					metadata.estimatedBenefit || 0,
					metadata.queryCount || 0,
					metadata.avgLatency || 0,
					suggestedSql,
					rollbackSql,
				]
			);

			this.#metrics?.increment("suggestionsGenerated");

			console.log(
				`💡 Created ${suggestionType} suggestion for ${tableName}.${jsonbPath}`
			);

			return result.rows[0].id;
		} catch (error) {
			this.#metrics?.increment("suggestionErrors");
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "createIndexSuggestion",
			});
			return null;
		}
	}

	/**
	 * Applies a pending optimization suggestion by executing its SQL definition.
	 * @param {string|number} suggestionId - The ID of the suggestion to apply.
	 * @param {string} [approvedBy="system"] - The identifier of the user or system that approved the optimization.
	 * @returns {Promise<boolean>} A promise that resolves to `true` on success.
	 * @throws {Error} If the suggestion is not found, has an invalid status, or if the SQL execution fails.
	 */
	/**

	 * TODO: Add JSDoc for method applyOptimization

	 * @memberof AutoGenerated

	 */

	async applyOptimization(suggestionId, approvedBy = "system") {
		return this.#errorHelpers.tryOr(
			async () => {
				// Get suggestion details
				const result = await this.#db.query(
					`
        SELECT * FROM index_suggestions WHERE id = $1
      `,
					[suggestionId]
				);

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (result.rows.length === 0) {
					throw new Error(`Suggestion ${suggestionId} not found`);
				}

				const suggestion = result.rows[0];

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (
					suggestion.status !== "pending" &&
					suggestion.status !== "approved"
				) {
					throw new Error(
						`Cannot apply suggestion in status: ${suggestion.status}`
					);
				}

				console.log(
					`🔧 Applying ${suggestion.suggestion_type} optimization...`
				);

				// Execute the optimization SQL
				const startTime = performance.now();
				await this.#db.query(suggestion.suggested_sql);
				const executionTime = Date.now() - startTime;

				// Update suggestion status
				await this.#db.query(
					`
        UPDATE index_suggestions 
        SET status = 'applied', applied_at = now()
        WHERE id = $1
      `,
					[suggestionId]
				);

				// Record in optimizations table
				await this.#db.query(
					`
        INSERT INTO database_optimizations 
        (optimization_type, table_name, target_field, sql_definition, rollback_sql, 
         query_count, avg_latency_before, status, approved_at, applied_at, metadata)
        VALUES ($1, $2, $3, $4, $5, $6, $7, 'applied', now(), now(), $8)
      `,
					[
						suggestion.suggestion_type,
						suggestion.table_name,
						suggestion.jsonb_path,
						suggestion.suggested_sql,
						suggestion.rollback_sql,
						suggestion.query_frequency,
						suggestion.avg_query_time,
						JSON.stringify({
							suggestionId,
							approvedBy,
							executionTimeMs: executionTime,
							estimatedBenefit: suggestion.estimated_benefit,
						}),
					]
				);

				this.#metrics?.increment("optimizationsApplied");

				console.log(
					`✅ Applied ${suggestion.suggestion_type} optimization in ${executionTime.toFixed(2)}ms`
				);
				this.#stateManager?.emit("optimization_applied", {
					id: suggestionId,
					type: suggestion.suggestion_type,
					table: suggestion.table_name,
					field: suggestion.jsonb_path,
					executionTime,
					approvedBy,
				});

				return true;
			},
			async (error) => {
				this.#metrics?.increment("optimizationErrors");
				// Update suggestion status to failed
				await this.#db
					.query(
						`
        UPDATE index_suggestions 
        SET status = 'failed'
        WHERE id = $1
      `,
						[suggestionId]
					)
					.catch((e) =>
						console.error("Failed to mark suggestion as failed:", e)
					);
				throw error; // Re-throw original error
			},
			{
				component: "DatabaseOptimizer",
				operation: "applyOptimization",
				context: { suggestionId, approvedBy },
			}
		);
	}

	/**
	 * Rolls back a previously applied optimization by executing its rollback SQL.
	 * @param {string|number} optimizationId - The ID of the optimization to roll back.
	 * @returns {Promise<boolean>} A promise that resolves to `true` on success.
	 * @throws {Error} If the optimization is not found, has an invalid status, or if rollback SQL is missing.
	 */
	/**

	 * TODO: Add JSDoc for method rollbackOptimization

	 * @memberof AutoGenerated

	 */

	async rollbackOptimization(optimizationId) {
		return this.#errorHelpers.tryOr(
			async () => {
				const result = await this.#db.query(
					`
        SELECT * FROM database_optimizations WHERE id = $1
      `,
					[optimizationId]
				);

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (result.rows.length === 0) {
					throw new Error(`Optimization ${optimizationId} not found`);
				}

				const optimization = result.rows[0];

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (optimization.status !== "applied") {
					throw new Error(
						`Cannot rollback optimization in status: ${optimization.status}`
					);
				}

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (!optimization.rollback_sql) {
					throw new Error("No rollback SQL available");
				}

				console.log(
					`🔙 Rolling back ${optimization.optimization_type}...`
				);

				// Execute rollback SQL
				await this.#db.query(optimization.rollback_sql);

				// Update status
				await this.#db.query(
					`
        UPDATE database_optimizations 
        SET status = 'rolled_back'
        WHERE id = $1
      `,
					[optimizationId]
				);

				console.log(`✅ Rolled back ${optimization.optimization_type}`);

				return true;
			},
			null, // Let the helper handle logging
			{
				component: "DatabaseOptimizer",
				operation: "rollbackOptimization",
				context: { optimizationId },
			}
		);
	}

	/**
	 * Automatically generates optimization suggestions by querying a database function designed to find optimizable query patterns.
	 * @private
	 */
	async #generateOptimizationSuggestions() {
		// Check if the function exists on the DB client before calling
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#db.client.suggest_jsonb_indexes) {
			console.warn(
				"[DatabaseOptimizer] `suggest_jsonb_indexes` function not found on DB client. Skipping auto-suggestions."
			);
			return;
		}

		try {
			console.log("🔍 Generating optimization suggestions...");

			// Call the database function to get suggestions
			const result = await this.#db.query(
				`
        SELECT * FROM suggest_jsonb_indexes()
        WHERE query_count > $1 AND avg_time > $2
        ORDER BY avg_time DESC, query_count DESC
        LIMIT 10
      `,
				[this.#thresholds.hotQueryCount, this.#thresholds.slowQueryMs]
			);

			/**


			 * TODO: Add JSDoc for method for


			 * @memberof AutoGenerated


			 */


			for (const suggestion of result.rows) {
				await this.#createIndexSuggestion(
					suggestion.table_name,
					suggestion.jsonb_path,
					"gin_index",
					{
						queryCount: suggestion.query_count,
						avgLatency: suggestion.avg_time,
						estimatedBenefit: Math.min(
							suggestion.avg_time * 0.4,
							50
						),
					}
				);
			}

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (result.rows.length > 0) {
				console.log(
					`💡 Generated ${result.rows.length} optimization suggestions`
				);
			}
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "generateOptimizationSuggestions",
			});
		}
	}

	/**
	 * Refreshes any materialized views created by this optimizer to ensure their data is up-to-date.
	 * @private
	 */
	async #refreshMaterializedViews() {
		// Check if the function exists on the DB client before calling
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#db.client.refresh_performance_views) {
			return;
		}

		try {
			console.log("🔄 Refreshing materialized views...");

			const startTime = performance.now();
			await this.#db.query("SELECT refresh_performance_views()");
			const executionTime = performance.now() - startTime;

			console.log(
				`✅ Materialized views refreshed in ${executionTime.toFixed(2)}ms`
			);

			// Log the performance
			await this.logQuery(
				"materialized_views",
				"refresh_performance_views",
				"system",
				executionTime,
				null,
				"refresh"
			);
		} catch (error) {
			this.#metrics?.increment("viewRefreshErrors");
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "refreshMaterializedViews",
			});
		}
	}

	/**
	 * Retrieves a list of all optimization suggestions that are currently in a 'pending' state.
	 * @returns {Promise<object[]>} A promise that resolves with an array of pending suggestion objects.
	 */
	/**

	 * TODO: Add JSDoc for method getPendingSuggestions

	 * @memberof AutoGenerated

	 */

	async getPendingSuggestions() {
		try {
			const result = await this.#db.query(`
        SELECT 
          id,
          table_name,
          jsonb_path,
          suggestion_type,
          estimated_benefit,
          query_frequency,
          avg_query_time,
          created_at
        FROM index_suggestions 
        WHERE status = 'pending'
        ORDER BY estimated_benefit DESC, query_frequency DESC
      `);

			return result.rows;
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "getPendingSuggestions",
			});
			return [];
		}
	}

	/**
	 * Retrieves a list of all applied optimizations and calculates their performance impact by comparing query latencies before and after application.
	 * @returns {Promise<object[]>} A promise that resolves with an array of applied optimization objects, including performance gain metrics.
	 */
	/**

	 * TODO: Add JSDoc for method getAppliedOptimizations

	 * @memberof AutoGenerated

	 */

	async getAppliedOptimizations() {
		try {
			const result = await this.#db.query(`
        SELECT 
          o.*,
          COALESCE(
            (SELECT avg(execution_time_ms) 
             FROM query_performance_log q 
             WHERE q.table_name = o.table_name 
             AND q.jsonb_path = o.target_field 
             AND q.logged_at > o.applied_at
             LIMIT 100), 
            o.avg_latency_before
          ) as avg_latency_after
        FROM database_optimizations o
        WHERE status = 'applied'
        ORDER BY applied_at DESC
      `);

			// Calculate performance gains
			return result.rows.map((opt) => ({
				...opt,
				performance_gain:
					opt.avg_latency_before && opt.avg_latency_after
						? ((opt.avg_latency_before - opt.avg_latency_after) /
								opt.avg_latency_before) *
							100
						: null,
			}));
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "getAppliedOptimizations",
			});
			return [];
		}
	}

	/**
	 * Retrieves a snapshot of current database performance metrics, including slow queries and index usage statistics.
	 * @returns {Promise<object|null>} A promise that resolves with an object containing various performance metrics, or null on failure.
	 */
	/**

	 * TODO: Add JSDoc for method getPerformanceMetrics

	 * @memberof AutoGenerated

	 */

	async getPerformanceMetrics() {
		try {
			const [slowQueries, tableStats, indexStats] = await Promise.all([
				// V8.0 Parity: Use private field #db.
				this.#db.query("SELECT * FROM slow_query_analysis LIMIT 10"),
				this.#db.query(
					"SELECT * FROM database_performance_overview LIMIT 10"
				),
				this.#db.query(`
          SELECT 
            schemaname, tablename, indexname, idx_scan, idx_tup_read,
            pg_size_pretty(pg_relation_size(indexrelid)) as index_size
          FROM pg_stat_user_indexes 
          WHERE schemaname = 'public'
          ORDER BY idx_scan DESC 
          LIMIT 10
        `),
			]);

			return {
				slowQueries: slowQueries.rows,
				tableStats: tableStats.rows,
				indexStats: indexStats.rows,
				systemMetrics: this.#metrics?.getAllAsObject(),
			};
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "getPerformanceMetrics",
			});
			return null;
		}
	}

	/**
	 * Retrieves a list of potential optimization opportunities identified by the database.
	 * @returns {Promise<object[]>} A promise that resolves with an array of opportunity objects.
	 */
	/**

	 * TODO: Add JSDoc for method getOptimizationOpportunities

	 * @memberof AutoGenerated

	 */

	async getOptimizationOpportunities() {
		try {
			const result = await this.#db.query(
				"SELECT * FROM optimization_opportunities LIMIT 20"
			);
			return result.rows;
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "DatabaseOptimizer",
				operation: "getOptimizationOpportunities",
			});
			return [];
		}
	}

	/**
	 * Updates the optimizer's configuration at runtime.
	 * @param {object} config - An object containing new configuration values for `thresholds`, `intervals`, `monitoring`, or `autoSuggestions`.
	 */
	/**

	 * TODO: Add JSDoc for method updateConfig

	 * @memberof AutoGenerated

	 */

	updateConfig(config) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  /**

   * TODO: Add JSDoc for method if

   * @memberof AutoGenerated

   */

  if (config.thresholds) {
			this.#thresholds = { ...this.#thresholds, ...config.thresholds };
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (config.intervals) {
			this.#intervals = { ...this.#intervals, ...config.intervals };
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (typeof config.monitoring === "boolean") {
			this.#monitoring = config.monitoring;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (typeof config.autoSuggestions === "boolean") {
			this.#autoSuggestions = config.autoSuggestions;
		}

		console.log("📝 DatabaseOptimizer configuration updated");
	}

	/**
	 * Gets the current internal metrics and configuration of the optimizer.
	 * @returns {object} An object containing the current metrics and settings.
	 */
	/**

	 * TODO: Add JSDoc for method getMetrics

	 * @memberof AutoGenerated

	 */

	getMetrics() {
		return {
			...(this.#metrics?.getAllAsObject() || {}),
			thresholds: this.#thresholds,
			monitoring: this.#monitoring,
			autoSuggestions: this.#autoSuggestions,
		};
	}

	/**
	 * Shuts down the optimizer, clearing all running intervals.
	 */
	/**

	 * TODO: Add JSDoc for method cleanup

	 * @memberof AutoGenerated

	 */

	async cleanup() {
		console.log("[DatabaseOptimizer] Shutting down...");
		clearInterval(this.#queryAnalysisInterval);
		clearInterval(this.#viewRefreshInterval);
		clearInterval(this.#autoSuggestionsInterval);
		this.#queryAnalysisInterval = null;
		this.#viewRefreshInterval = null;
		this.#autoSuggestionsInterval = null;
		console.log("[DatabaseOptimizer] Cleanup complete.");
	}
}

export default DatabaseOptimizer;

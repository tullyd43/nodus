/**
 * @file ActionHandlerRegistry.js
 * @version 1.1.0
 * @description A centralized registry for managing and executing reusable action handlers for the EventFlowEngine.
 */

/**
 * @class ActionHandlerRegistry
 * @classdesc Manages the registration and execution of action handlers used by the EventFlowEngine.
 * This centralization makes actions reusable, testable, and consistent across the application.
 */

export class ActionHandlerRegistry {
	// V8.0 Parity: Mandate 3.1 - All internal properties MUST be private.
	/** @private @type {import('./HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {Map<string, Function>} */
	#handlers = new Map();
	/** @private @type {import('../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {import('../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;

	/**
	 * Creates an instance of ActionHandlerRegistry.
	 * @param {object} context - The application context.
	 * @param {import('./HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from the stateManager.
		this.#stateManager = stateManager;
		this.#metrics =
			this.#stateManager.metricsRegistry?.namespace("actionHandler");
		this.#errorHelpers = this.#stateManager.managers.errorHelpers;
	}

	/**
	 * Initializes the registry by registering built-in action handlers.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	initialize() {
		this.#registerBuiltinHandlers();
		console.log(
			`[ActionHandlerRegistry] Initialized with ${this.#handlers.size} built-in handlers.`
		);
	}

	/**
	 * Registers a new action handler function.
	 * @param {string} actionType - The unique name for the action type.
	 * @param {Function} handler - The async function that executes the action. It receives `(action, event, flow, stateManager)`.
	 */
	/**

	 * TODO: Add JSDoc for method register

	 * @memberof AutoGenerated

	 */

	register(actionType, handler) {
		if (this.#handlers.has(actionType)) {
			console.warn(
				`[ActionHandlerRegistry] Overwriting existing handler for action type: ${actionType}`
			);
		}
		this.#handlers.set(actionType, handler);
		this.#metrics?.increment("handlers.registered");
	}

	/**
	 * Retrieves a registered action handler.
	 * @param {string} actionType - The name of the action type.
	 * @returns {Function|undefined} The handler function, or undefined if not found.
	 */
	/**

	 * TODO: Add JSDoc for method get

	 * @memberof AutoGenerated

	 */

	get(actionType) {
		return this.#handlers.get(actionType);
	}

	/**
	 * Registers a set of common, built-in action handler functions.
	 * @private
	 */
	#registerBuiltinHandlers() {
		// Logging action
		this.register(
			"log_event",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					async () => {
						const level = action.level || "info";
						const message =
							action.message || `Event: ${event.type}`;
						const allowedLevels = {
							log: console.log,
							warn: console.warn,
							error: console.error,
							info: console.info,
							debug: console.debug,
						};
						const logFn = allowedLevels[level] || console.log;
						logFn(
							`[EventFlow:${flow.id}] ${message}`,
							event.data || ""
						);

						// Integrate with ForensicLogger for auditable logs
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (action.audit) {
							const forensicLogger =
								stateManager.managers.forensicLogger;
							/**

							 * TODO: Add JSDoc for method if

							 * @memberof AutoGenerated

							 */

							if (forensicLogger) {
								await forensicLogger.logAuditEvent(
									`EVENT_FLOW_LOG_${level.toUpperCase()}`,
									{
										flowId: flow.id,
										message,
										eventData: event.data,
									}
								);
							}
						}
						this.#metrics?.increment("actions.executed.log_event");
					},
					null,
					{
						component: "ActionHandlerRegistry",
						operation: "log_event",
					}
				);
			}
		);

		// Notification action
		this.register(
			"show_notification",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					() => {
						const notification = {
							type: action.template || "info",
							message: action.message || `Event: ${event.type}`,
							duration: action.duration || 3000,
							data: event.data,
						};
						stateManager?.emit("show_notification", notification);
						this.#metrics?.increment(
							"actions.executed.show_notification"
						);
					},
					null,
					{
						component: "ActionHandlerRegistry",
						operation: "show_notification",
					}
				);
			}
		);

		// Metric tracking action
		this.register(
			"track_metric",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					() => {
						const metric = {
							name: action.metric,
							value: action.value || 1,
						};
						stateManager?.metricsRegistry?.increment(
							metric.name,
							metric.value
						);
						this.#metrics?.increment(
							"actions.executed.track_metric"
						);
					},
					null,
					{
						component: "ActionHandlerRegistry",
						operation: "track_metric",
					}
				);
			}
		);

		// Cache invalidation action
		this.register(
			"invalidate_cache",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					() => {
						const cacheManager =
							stateManager?.managers?.cacheManager;
						if (!cacheManager) return;

						let pattern = action.pattern || "*";

						// Simple template replacement
						pattern = pattern.replace(
							/\{\{data\.entity\.id\}\}/g,
							event.data?.entity?.id ?? event.data?.id ?? ""
						);

						/**


						 * TODO: Add JSDoc for method if


						 * @memberof AutoGenerated


						 */


						if (pattern === "*") {
							cacheManager.clearAll();
							console.log(
								`[ActionHandlerRegistry] Cleared all caches via flow: ${flow.id}`
							);
						} else {
							// Invalidate a specific cache instance by name/pattern
							cacheManager.invalidate(pattern);
							console.log(
								`[ActionHandlerRegistry] Invalidated cache '${pattern}' via flow: ${flow.id}`
							);
						}
						this.#metrics?.increment(
							"actions.executed.invalidate_cache"
						);
					},
					null,
					{
						component: "ActionHandlerRegistry",
						operation: "invalidate_cache",
					}
				);
			}
		);

		// Event broadcasting action
		this.register(
			"broadcast_event",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					() => {
						stateManager?.emit(action.event, {
							...event.data,
							originalEvent: event.type,
							flow: flow.id,
						});
						this.#metrics?.increment(
							"actions.executed.broadcast_event"
						);
					},
					null,
					{
						component: "ActionHandlerRegistry",
						operation: "broadcast_event",
					}
				);
			}
		);

		// Data manipulation action: Create or update an entity
		this.register(
			"save_entity",
			async (action, event, flow, stateManager) => {
				await this.#errorHelpers?.tryOr(
					async () => {
						const entityData = action.entity || event.data?.entity;
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (!entityData) {
							console.warn(
								`[ActionHandlerRegistry] 'save_entity' action in flow ${flow.id} is missing entity data.`
							);
							return;
						}
						await stateManager.saveEntity(entityData);
						this.#metrics?.increment(
							"actions.executed.save_entity"
						);
					},
					(error) => {
						// Optionally emit a failure event
						stateManager.emit("action_execution_error", {
							action,
							event,
							flow,
							error,
						});
					},
					{
						component: "ActionHandlerRegistry",
						operation: "save_entity",
					}
				);
			}
		);
	}

	/**
	 * Cleans up the registry.
	 */
	/**

	 * TODO: Add JSDoc for method cleanup

	 * @memberof AutoGenerated

	 */

	cleanup() {
		this.#handlers.clear();
		console.log("[ActionHandlerRegistry] Cleaned up.");
	}
}

export default ActionHandlerRegistry;

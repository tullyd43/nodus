/**
 * @file CompleteGridSystem.js
 * @description Integrates all grid-related features into a single, cohesive system.
 * This class is a managed service, instantiated by the ServiceRegistry, and orchestrates all other grid-related services.
 */

// Grid policies are managed via the GridPolicyService from the ServiceRegistry.

/**
 * @class CompleteGridSystem
 * @classdesc Manages the complete, enhanced grid system by initializing and coordinating
 * all managed grid services like policy management, toast notifications, and the AI layout assistant.
 * @privateFields {#stateManager, #options, #gridEnhancer, #toastManager, #aiAssistant, #initialized, #unsubscribeFunctions}
 * @privateFields {#stateManager, #appViewModel, #options, #gridEnhancer, #toastManager, #aiAssistant, #initialized, #unsubscribeFunctions}
 * @privateFields {#stateManager, #appViewModel, #options, #gridEnhancer, #toastManager, #aiAssistant, #gridPolicyService, #initialized, #unsubscribeFunctions}
 */
import { GridHistoryInspector } from "./GridHistoryInspector.js";
import { ForensicLogger } from '@core/security/ForensicLogger.js';
import { SafeDOM } from '@core/ui/SafeDOM.js';
import { componentRegistry } from "./runtime/ComponentRegistry.js";
import { normalizeConfig } from "./runtime/GridRuntimeConfig.js";
import { LayoutStore } from "./runtime/LayoutStore.js";

export class CompleteGridSystem {
	/** @private @type {import('../core/HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('./EnhancedGridRenderer.js').EnhancedGridRenderer|null} */
	#gridEnhancer = null;
	/** @private @type {import('../utils/SystemToastManager.js').SystemToastManager|null} */
	#toastManager = null;
	/** @private @type {import('./AILayoutAssistant.js').AILayoutAssistant|null} */
	#aiAssistant = null;
	/** @private @type {object} */
	#options;
	/** @private @type {object} */
	#appViewModel;
	/** @private @type {boolean} */
	#initialized = false;
	/** @private @type {Function[]} */
	#unsubscribeFunctions = [];
	/** @private @type {import('./GridPolicyIntegration.js').GridPolicyService|null} */
	#gridPolicyService = null;
	/** @private @type {LayoutStore|null} */
	#layoutStore = null;
	/** @private */
	#runtimeConfig = null;
	#nestedGridManager = null;
	#historyInspector = null;

	/**
	 * Creates an instance of CompleteGridSystem.
	 * @param {object} context - The context object provided by the ServiceRegistry.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The application's state manager.
	 * @param {object} [options={}] - Configuration options for the grid system.
	 * @param {string} [options.gridContainer=".grid-container"] - The CSS selector for the grid container element.
	 * @param {object} [context.appViewModel] - The main application view model, if available.
	 * @param {boolean} [options.enablePolicies=true] - Whether to enable grid-specific policy management.
	 * @param {boolean} [options.enableToasts=true] - Whether to enable toast notifications for grid events.
	 * @param {boolean} [options.enableAI=true] - Whether to enable the AI layout assistant.
	 * @param {boolean} [options.enableAnalytics=true] - Whether to enable analytics tracking for grid interactions.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager, appViewModel }, options = {}) {
		// V8.0 Parity: Accept appViewModel in constructor.
		this.#stateManager = stateManager;
		this.#appViewModel = appViewModel || {}; // V8.0 Parity: Assign appViewModel.

		// V8.0 Parity: Acquire all dependencies from the state manager.
		this.#toastManager = this.#stateManager.managers.toastManager;
		this.#aiAssistant = this.#stateManager.managers.aiLayoutAssistant;
		this.#gridEnhancer = this.#stateManager.managers.enhancedGridRenderer;
		this.#gridPolicyService = this.#stateManager.managers.gridPolicyService;
		try {
			this.#layoutStore = new LayoutStore({
				stateManager: this.#stateManager,
			});
		} catch {
			/* noop */
		}

		this.#options = {
			gridContainer: ".grid-container",
			enablePolicies: true,
			enableToasts: true,
			enableAI: true,
			enableAnalytics: true,
			enableNesting: false,
			...options,
		};
	}

	/**
	 * Initializes all configured subsystems of the grid system in the correct order.
	 * @public
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#initialized) {
			return; // idempotent: silently ignore repeated initialize calls
		}

		try {
			// 1. Extend SystemPolicies with grid policies
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#options.enablePolicies && this.#gridPolicyService) {
				await this.#gridPolicyService.registerGridPolicies({
					includeNesting: !!this.#options.enableNesting,
				});
			}

			// 2. Initialize grid enhancer with all features
			await this.#initializeGridEnhancer();

			// 3. Set up policy management UI
			this.#setupPolicyControls();

			// 4. Set up analytics tracking
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#options.enableAnalytics) {
				this.#setupAnalytics();
				this.#setupAnalyticsPanel();
			}

			// 5. History inspector (lightweight)
			try {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#options.enableHistoryInspector !== false) {
					this.#historyInspector = new GridHistoryInspector({
						stateManager: this.#stateManager,
					});
					this.#historyInspector.initialize();
				}
			} catch {
				/* noop */
			}

			// 6. Nested grid manager is tenant-gated and loaded lazily when enabled
			try {
				this.#setupNestingPolicyWatcher();
			} catch {
				/* noop */
			}

			// 7. Listen for grid add requests from reusable button component
			try {
				const handler = (payload) =>
					this.#onAddBlockRequested(payload || {});
				this.#unsubscribeFunctions.push(
					this.#stateManager.on("gridAddBlockRequested", handler)
				);
			} catch {
				/* noop */
			}

			this.#initialized = true;
			console.log("Complete Grid System initialized with all features");

			// Show initialization success
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#toastManager) {
				this.#toastManager.success(
					"🎯 Enhanced grid system ready",
					3000
				);
			}
		} catch (error) {
			console.error("Failed to initialize complete grid system:", error);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (this.#toastManager) {
				this.#toastManager.error(
					"Failed to initialize grid enhancements",
					5000
				);
			}
		}
	}

	#onAddBlockRequested(payload) {
		try {
			const mode = String(payload.mode || "modal");
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (mode === "add") {
				this.#addBlockDirect();
			} else {
				this.#openAddElementModal();
			}
		} catch {
			/* noop */
		}
	}

	#addBlockDirect() {
		try {
			const cfg = this.#runtimeConfig || { blocks: [] };
			const columns = Number(
				this.#stateManager?.managers?.policies?.getPolicy(
					"grid",
					"default_columns"
				) ?? 24
			);
			const w = 6,
				h = 4;
			const x = Math.max(0, Math.floor((columns - w) / 2));
			const yBase = cfg.blocks.reduce(
				(m, b) => Math.max(m, (b.y ?? 0) + (b.h ?? 0)),
				0
			);
			const b = {
				id: `block_${Date.now()}`,
				type: "block",
				x,
				y: yBase,
				w,
				h,
				constraints: { minW: 2, minH: 2, maxW: columns, maxH: 1000 },
				props: { title: "Block", body: "New" },
			};
			cfg.blocks.push(b);
			this.#appendBlock(b);
			this.saveRuntimeConfig("dev-default").catch(() => {});
		} catch {
			/* noop */
		}
	}

	#appendBlock(b) {
		const container =
			document.querySelector(this.#options.gridContainer) ||
			document.querySelector(".grid-container") ||
			document.body;
		const block = document.createElement("div");
		block.className = "grid-block";
		block.dataset.blockId = b.id;
		block.dataset.minW = String(b.constraints.minW);
		block.dataset.minH = String(b.constraints.minH);
		block.dataset.maxW = String(b.constraints.maxW);
		block.dataset.maxH = String(b.constraints.maxH);
		const content = document.createElement("div");
		content.className = "grid-block-content";
		block.appendChild(content);
		container.appendChild(block);
		try {
			componentRegistry.mount(b.type, content, b.props || {}, {
				stateManager: this.#stateManager,
				appViewModel: this.#appViewModel,
				parentConfigId: "dev-default",
				blockId: b.id,
			});
		} catch {
			/* noop */
		}
		this.#gridEnhancer?.updateBlockPosition?.(b.id, b.x, b.y, b.w, b.h);
	}

	#openAddElementModal() {
		const existing = document.getElementById("grid-add-modal");
		if (existing) existing.remove();
		const wrap = document.createElement("div");
		wrap.id = "grid-add-modal";
		wrap.style.cssText =
			"position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:20000;display:flex;align-items:center;justify-content:center;";
		const card = document.createElement("div");
		card.style.cssText =
			"background:#fff;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.3);width:420px;max-width:90vw;padding:16px;";
		card.innerHTML = `
			<h3 style="margin:0 0 10px">Add Grid Block</h3>
			<label style="display:block;margin-bottom:8px">
				<span>Component Type</span>
				<select id="gb-type" style="width:100%;padding:8px;margin-top:4px">
					<option value="block">Block</option>
					<option value="text">Text</option>
					<option value="html">HTML</option>
				</select>
			</label>
			<label style="display:block;margin-bottom:8px">
				<span>Title/Text</span>
				<input id="gb-title" type="text" style="width:100%;padding:8px;margin-top:4px" placeholder="Title or text"/>
			</label>
			<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
				<button id="gb-cancel" style="padding:8px 12px">Cancel</button>
				<button id="gb-add" style="padding:8px 12px;background:#2b7cff;color:#fff;border:0;border-radius:6px">Add</button>
			</div>
		`;
		wrap.appendChild(card);
		document.body.appendChild(wrap);
		const cancel = () => wrap.remove();
		wrap.addEventListener("click", (e) => {
			if (e.target === wrap) cancel();
		});
		card.querySelector("#gb-cancel").addEventListener("click", cancel);
		card.querySelector("#gb-add").addEventListener("click", () => {
			try {
				const type = card.querySelector("#gb-type").value;
				const title =
					card.querySelector("#gb-title").value ||
					(type === "text" ? "Text" : "Block");
				const columns = Number(
					this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"default_columns"
					) ?? 24
				);
				const w = 6,
					h = 4;
				const x = Math.max(0, Math.floor((columns - w) / 2));
				const yBase = (this.#runtimeConfig?.blocks || []).reduce(
					(m, b) => Math.max(m, (b.y ?? 0) + (b.h ?? 0)),
					0
				);
				const props =
					type === "block"
						? { title, body: "" }
						: type === "text"
							? { value: title }
							: { html: title };
				const b = {
					id: `block_${Date.now()}`,
					type,
					x,
					y: yBase,
					w,
					h,
					constraints: {
						minW: 2,
						minH: 2,
						maxW: columns,
						maxH: 1000,
					},
					props,
				};
				this.#runtimeConfig = this.#runtimeConfig || { blocks: [] };
				this.#runtimeConfig.blocks.push(b);
				this.#appendBlock(b);
				this.saveRuntimeConfig("dev-default").catch(() => {});
				cancel();
			} catch {
				cancel();
			}
		});
	}

	/**
	 * Applies a runtime configuration to the grid: creates blocks and mounts components.
	 * Prefer calling this before the first initialize(), so the renderer can enhance on first pass.
	 * @param {object} rawConfig
	 */
	/**

	 * TODO: Add JSDoc for method setRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async setRuntimeConfig(rawConfig, id = "default", scope = null, depth = 0) {
		try {
			const maxDepth = Number(
				this.#stateManager?.managers?.policies?.getPolicy(
					"grid",
					"nesting_max_depth"
				) ?? 3
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (depth > maxDepth) {
				console.warn(
					`[Grid] Max nesting depth of ${maxDepth} exceeded. Aborting render.`
				);
				const container =
					document.querySelector(this.#options.gridContainer) ||
					document.body;
				container.textContent = "[max nesting depth exceeded]";
				return;
			}

			this.#runtimeConfig = normalizeConfig(rawConfig);
			// Enforce allowed component types via policy (if defined)
			try {
				const allowed =
					this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"allowed_component_types"
					);
				if (Array.isArray(allowed) && allowed.length) {
					componentRegistry.setAllowedTypes(allowed);
				}
			} catch {
				/* noop */
			}
			const container =
				document.querySelector(this.#options.gridContainer) ||
				document.querySelector(".grid-container") ||
				document.body;
			// Clear container and rebuild blocks
			while (container.firstChild)
				container.removeChild(container.firstChild);

			// V8.0 Parity: Enforce unique IDs and prevent trivial overlaps
			const seen = new Set();
			this.#runtimeConfig.blocks = this.#runtimeConfig.blocks.filter(
				(b) => {
					if (seen.has(b.id)) {
						console.warn(
							`[Grid] Duplicate block ID found and removed: ${b.id}`
						);
						return false;
					}
					seen.add(b.id);
					return true;
				}
			);

			/**

			 * TODO: Add JSDoc for function overlaps

			 * @memberof AutoGenerated

			 */

			function overlaps(a, b) {
				const ax2 = a.x + a.w - 1,
					bx2 = b.x + b.w - 1;
				const ay2 = a.y + a.h - 1,
					by2 = b.y + b.h - 1;
				const colsOverlap = !(ax2 < b.x || bx2 < a.x);
				const rowsOverlap = !(ay2 < b.y || by2 < a.y);
				return colsOverlap && rowsOverlap;
			}
			const out = [];
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of this.#runtimeConfig.blocks) {
				if (out.some((x) => overlaps(x, b))) continue;
				out.push(b);
			}
			this.#runtimeConfig.blocks = out;
			// Use responsive template if present for current width
			const pickBlocks = () => {
				if (!this.#runtimeConfig?.templates)
					return this.#runtimeConfig.blocks;
				const bp = this.#getBreakpoint(window.innerWidth);
				return (
					this.#runtimeConfig.templates?.[bp]?.blocks ||
					this.#runtimeConfig.blocks
				);
			};
			const blocks = pickBlocks();
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				const block = document.createElement("div");
				block.className = "grid-block";
				block.dataset.blockId = b.id;
				block.dataset.minW = String(b.constraints.minW);
				block.dataset.minH = String(b.constraints.minH);
				block.dataset.maxW = String(b.constraints.maxW);
				block.dataset.maxH = String(b.constraints.maxH);
				// content wrapper
				const content = document.createElement("div");
				content.className = "grid-block-content";
				block.appendChild(content);
				container.appendChild(block);
				// mount component (pass parent config id and block id for nested persistence)
				try {
					await componentRegistry.mount(
						b.type,
						content,
						b.props || {},
						{
							stateManager: this.#stateManager,
							appViewModel: this.#appViewModel,
							parentConfigId: id,
							blockId: b.id,
							depth: depth + 1,
						}
					);
				} catch {
					/* noop */
				}
				// Optional: attach nested grid strictly inside block content
				try {
					if (
						this.#nestedGridManager &&
						b?.nestedGrid &&
						this.#stateManager?.managers?.policies?.getPolicy(
							"grid",
							"nesting_enabled"
						)
					) {
						await this.#nestedGridManager.attach(
							block,
							this.#appViewModel,
							b.nestedGrid,
							depth
						);
					}
				} catch {
					/* noop */
				}
			}
			// If renderer already initialized, refresh to enhance new blocks
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#gridEnhancer?.refresh) {
				this.#gridEnhancer.refresh();
			} else if (this.#gridEnhancer?.initialize) {
				await this.#gridEnhancer.initialize({
					container,
					appViewModel: this.#appViewModel,
				});
			}

			// Restore last-known layout for this config
			await this.loadRuntimeLayout(id, scope);

			// Listen for breakpoint changes to re-apply template positions
			this.#setupResponsiveTemplateListener(id);
		} catch (err) {
			console.warn("[Grid] setRuntimeConfig failed:", err);
		}
	}

	/** Saves the current runtime config to persistent storage */
	/**

	 * TODO: Add JSDoc for method saveRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async saveRuntimeConfig(id = "default", scope = null) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  try {
			if (!this.#layoutStore || !this.#runtimeConfig) return;
			const sc = scope || this.#computeScopeFromPolicy();
			// V8.0 Parity: Add retry logic for constraint errors
			try {
				await this.#layoutStore.saveConfig(id, this.#runtimeConfig, sc);
			} catch (err) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (err?.name === "ConstraintError") {
					await this.#layoutStore.deleteConfig(id, sc);
					await this.#layoutStore.saveConfig(
						id,
						this.#runtimeConfig,
						sc
					);
				} else throw err;
			}
			await this.#layoutStore.saveConfig(id, this.#runtimeConfig, sc);
		} catch (err) {
			console.warn("[Grid] saveRuntimeConfig failed:", err);
		}
	}

	/** Loads a runtime config and applies it, then restores layout if any */
	/**

	 * TODO: Add JSDoc for method loadRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async loadRuntimeConfig(id = "default", scope = null) {
		try {
			if (!this.#layoutStore) return;
			const sc = scope || this.#computeScopeFromPolicy();
			const cfg = await this.#layoutStore.loadConfig(id, sc);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (cfg) {
				await this.setRuntimeConfig(cfg, id, sc);
			} else {
				console.warn("[Grid] No runtime config found for id", id);
			}
		} catch (err) {
			console.warn("[Grid] loadRuntimeConfig failed:", err);
		}
	}

	#getBreakpoint(width) {
		if (width >= 1400) return "xxl";
		if (width >= 1200) return "xl";
		if (width >= 992) return "lg";
		if (width >= 768) return "md";
		if (width >= 576) return "sm";
		return "xs";
	}

	#setupResponsiveTemplateListener(id) {
		if (!this.#runtimeConfig?.templates) return;
		let lastBp = this.#getBreakpoint(window.innerWidth);
		const onResize = () => {
			const bp = this.#getBreakpoint(window.innerWidth);
			if (bp === lastBp) return;
			lastBp = bp;
			const tpl = this.#runtimeConfig.templates?.[bp];
			if (!tpl?.blocks || !this.#gridEnhancer?.updateBlockPosition)
				return;
			// Batch as a single history entry when available
			const apply = () => {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const b of tpl.blocks) {
					this.#gridEnhancer.updateBlockPosition(
						b.id,
						b.x,
						b.y,
						b.w,
						b.h
					);
				}
				// Persist new positions under the same id
				this.saveRuntimeLayout(id).catch(() => {});
			};
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.transaction === "function") {
				this.#stateManager.transaction(apply);
			} else {
				apply();
			}
		};
		window.addEventListener("resize", onResize);
		this.#unsubscribeFunctions.push(() =>
			window.removeEventListener("resize", onResize)
		);
	}

	/**
	 * Saves the current grid layout to persistent storage under the given id.
	 * @param {string} id
	 */
	/**

	 * TODO: Add JSDoc for method saveRuntimeLayout

	 * @memberof AutoGenerated

	 */

	async saveRuntimeLayout(id = "default", scope = null) {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  try {
			const layout = this.#gridEnhancer?.getCurrentLayout?.();
			if (!layout || !this.#layoutStore) return;
			const sc = scope || this.#computeScopeFromPolicy();
			// V8.0 Parity: Add retry logic for constraint errors
			try {
				await this.#layoutStore.save(id, layout, sc);
			} catch (err) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (err?.name === "ConstraintError") {
					await this.#layoutStore.delete(id, sc);
					await this.#layoutStore.save(id, layout, sc);
				} else throw err;
			}
		} catch (err) {
			console.warn("[Grid] saveRuntimeLayout failed:", err);
		}
	}

	/**
	 * Loads a saved layout and applies positions to the renderer.
	 * @param {string} id
	 */
	/**

	 * TODO: Add JSDoc for method loadRuntimeLayout

	 * @memberof AutoGenerated

	 */

	async loadRuntimeLayout(id = "default", scope = null) {
		try {
			if (!this.#layoutStore || !this.#gridEnhancer) return;
			const sc = scope || this.#computeScopeFromPolicy();
			const layout = await this.#layoutStore.load(id, sc);
			if (!layout?.blocks || !Array.isArray(layout.blocks)) return;
			const positions = layout.blocks.map((b) => ({
				blockId: b.blockId,
				x: b.position?.x ?? b.x,
				y: b.position?.y ?? b.y,
				w: b.position?.w ?? b.w,
				h: b.position?.h ?? b.h,
			}));
			const apply = () => {
				this.#gridEnhancer.updateBlockPosition &&
					positions.forEach((p) => {
						this.#gridEnhancer.updateBlockPosition(
							p.blockId,
							p.x,
							p.y,
							p.w,
							p.h
						);
					});
			};
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.transaction === "function") {
				this.#stateManager.transaction(apply);
			} else {
				apply();
			}
		} catch (err) {
			console.warn("[Grid] loadRuntimeLayout failed:", err);
		}
	}

	#computeScopeFromPolicy() {
		try {
			const subj =
				this.#stateManager?.managers?.securityManager?.getSubject?.() ||
				{};
			const scopePref = String(
				this.#stateManager?.managers?.policies?.getPolicy(
					"system",
					"grid_auto_save_layout_scope"
				) || "tenant"
			).toLowerCase();
			if (scopePref === "user")
				return { tenantId: subj.tenantId, userId: subj.userId };
			if (scopePref === "tenant")
				return { tenantId: subj.tenantId, userId: "tenant" };
			return { tenantId: "global", userId: "global" };
		} catch {
			return { tenantId: "public", userId: "anon" };
		}
	}

	/**
	 * Initializes the `EnhancedGridRenderer` with all configured features and event listeners.
	 * @private
	 */
	async #initializeGridEnhancer() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#gridEnhancer) {
			throw new Error(
				"EnhancedGridRenderer not available from state manager."
			);
		}

		// V8.0 Parity: Initialize the EnhancedGridRenderer with its specific configuration.
		await this.#gridEnhancer.initialize({
			container: document.querySelector(this.#options.gridContainer),
			appViewModel: this.#appViewModel,
		});

		// Listen for layout changes to persist them via central event bus
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"layoutChanged",
					this.#onLayoutChanged.bind(this)
				)
			);
		}

		// Listen for grid events
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"gridEnhanced",
					this.#onGridEnhanced.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"gridPerformanceMode",
					this.#onPerformanceModeChanged.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridColumnsChanged", (data) => {
					if (!data) return;
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (this.#toastManager) {
						const isWarn =
							Number.isFinite(data.clampedCount) &&
							data.clampedCount > 0;
						const msg = isWarn
							? `Grid columns set to ${data.columns}. Adjusted ${data.clampedCount} blocks to fit.`
							: `Grid columns set to ${data.columns}.`;
						const method = isWarn ? "warning" : "info";
						this.#toastManager[method](msg, 2500);
					}
				})
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (this.#options.enableAI) {
				this.#unsubscribeFunctions.push(
					this.#stateManager.on(
						"aiLayoutSuggestions",
						this.#onAISuggestions.bind(this)
					)
				);
			}
		}

		// Listen for policy events to react to runtime changes
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			const policyHandler = (evt) => {
				try {
					if (evt?.type !== "policy_updated") return;
					const { domain, key, newValue } = evt.data || {};
					// Update component whitelist immediately
					if (
						domain === "grid" &&
						key === "allowed_component_types" &&
						Array.isArray(newValue)
					) {
						componentRegistry.setAllowedTypes(newValue);
					}
					if (
						domain === "grid" &&
						key === "default_columns" &&
						Number.isInteger(newValue)
					) {
						this.#gridEnhancer?.setGridColumns?.(newValue);
					}
				} catch {
					/* noop */
				}
			};
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("policyEvent", policyHandler)
			);
		}

		// Global keyboard shortcuts for undo/redo (Ctrl+Z / Ctrl+Y)
		const keyHandler = (e) => {
			if (!e.ctrlKey && !e.metaKey) return;
			const k = e.key?.toLowerCase();
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (k === "z") {
				e.preventDefault();
				this.undoLayoutChange();
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (k === "y") {
				e.preventDefault();
				this.redoLayoutChange();
			}
		};
		document.addEventListener("keydown", keyHandler);
		this.#unsubscribeFunctions.push(() =>
			document.removeEventListener("keydown", keyHandler)
		);
	}

	/**
	 * Handles layout change events by persisting them and feeding them to other subsystems.
	 * @private
	 * @param {object} changeEvent - The event data for the layout change.
	 */
	#onLayoutChanged(changeEvent) {
		// Save to HybridStateManager
		this.#stateManager.recordOperation({
			type: "grid_layout_change",
			data: changeEvent,
		});

		// Track analytics
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableAnalytics) {
			this.#trackLayoutChange(changeEvent);
		}

		// Auto-save current layout if policy permits
		try {
			const autoSave = this.#stateManager?.managers?.policies?.getPolicy(
				"system",
				"grid_auto_save_layouts"
			);
			const showFeedback =
				this.#stateManager?.managers?.policies?.getPolicy(
					"system",
					"grid_save_feedback"
				);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (autoSave) {
				const scope = this.#computeScopeFromPolicy();
				const layoutId =
					this.#stateManager?.managers?.policies?.getPolicy(
						"system",
						"grid_auto_save_layout_id"
					) || "default";
				this.saveRuntimeLayout(layoutId, scope)
					.then(() => {
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (showFeedback && this.#toastManager) {
							this.#toastManager.success(
								"Layout auto-saved",
								1500
							);
						}
					})
					.catch(() => {});
			}
		} catch {
			/* noop */
		}
	}

	/**
	 * Handles the event indicating that the grid enhancements are active.
	 * @private
	 * @param {object} data - The event data.
	 */
	#onGridEnhanced(data) {
		console.log("Grid enhancement active");

		// Show current policy status
		this.#showPolicyStatus();
	}

	/**
	 * Handles changes to the grid's performance mode.
	 * @private
	 * @param {object} data - The performance mode change event data.
	 */
	#onPerformanceModeChanged(data) {
		console.log("Performance mode changed:", data);

		// Could update UI indicators, analytics, etc.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableAnalytics) {
			this.#trackPerformanceMode(data);
		}
	}

	/**
	 * Handles the receipt of new AI-generated layout suggestions.
	 * @private
	 * @param {object} data - The event data containing the suggestions.
	 */
	#onAISuggestions(data) {
		console.log("AI suggestions received:", data.suggestions);

		// Show suggestions in UI (future implementation)
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#toastManager) {
			this.#toastManager.info(
				`💡 ${data.suggestions.length} layout suggestions available`,
				5000
			);
		}
	}

	/**
	 * Creates and injects the UI panel for managing grid-related policies.
	 * @private
	 */
	#setupPolicyControls() {
		// Add policy control panel to page
		const controlPanel = this.#createPolicyControlPanel();

		// Find a good place to insert it (or create a floating panel)
		const sidebar = document.querySelector(".sidebar");
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (sidebar) {
			sidebar.appendChild(controlPanel);
		} else {
			// Create floating panel
			controlPanel.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        padding: 16px;
        z-index: 1000;
        max-width: 250px;
      `;
			document.body.appendChild(controlPanel);
		}
	}

	/** Simple wrappers to integrate with HybridStateManager history (if available) */
	/**

	 * TODO: Add JSDoc for method undoLayoutChange

	 * @memberof AutoGenerated

	 */

	undoLayoutChange() {
		try {
			// V8.0 Parity: Use the state manager's history API for undo.
			// The history API is designed to handle transactions and state restoration.
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.history?.undo === "function") {
				this.#stateManager.history.undo();
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.info("Undo layout change", 1500);
				}
				this.#stateManager.emit("layoutRestored", {
					action: "undo",
					timestamp: Date.now(),
				});
			} else {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.warning(
						"Undo history not available",
						2000
					);
				}
			}
		} catch {
			this.#toastManager?.error("Undo failed", 2500);
			/* noop */
		}
	}

	/**


	 * TODO: Add JSDoc for method redoLayoutChange


	 * @memberof AutoGenerated


	 */


	redoLayoutChange() {
		try {
			// V8.0 Parity: Use the state manager's history API for redo.
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.history?.redo === "function") {
				this.#stateManager.history.redo();
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.info("Redo layout change", 1500);
				}
				this.#stateManager.emit("layoutRestored", {
					action: "redo",
					timestamp: Date.now(),
				});
			} else {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.warning(
						"Redo history not available",
						2000
					);
				}
			}
		} catch {
			this.#toastManager?.error("Redo failed", 2500);
			/* noop */
		}
	}

	/**
	 * Creates the HTML structure for the policy control panel.
	 * @private
	 * @returns {HTMLElement} The control panel element.
	 */
	#createPolicyControlPanel() {
		  await ForensicLogger.createEnvelope({ actorId: 'system', action: '<auto>', target: '<unknown>', label: 'unclassified' });
  const panel = document.createElement("div");
		panel.className = "grid-policy-panel";
		panel.innerHTML = `
      <h4>Grid Settings</h4>
      
      <div class="policy-control">
        <label>
          <input type="checkbox" id="perf-mode-toggle"> 
          Performance Mode
        </label>
        <small>Override automatic FPS-based switching</small>
      </div>
      
      <div class="policy-control">
        <label>
          <input type="checkbox" id="auto-save-toggle" checked> 
          Auto-save Layouts
        </label>
      </div>
      
      <div class="policy-control">
        <label>
          <input type="checkbox" id="save-feedback-toggle" checked> 
          Save Notifications
        </label>
      </div>
      
      <div class="policy-control">
        <label>
          <input type="checkbox" id="ai-suggestions-toggle"> 
          AI Suggestions <span class="badge">Future</span>
        </label>
      </div>

      <hr style="margin: 12px 0;"/>
      <h5>Tenant Overrides</h5>
      <small>Applies only to this tenant. Use Revert to return to global policy.</small>

      <div class="policy-control" style="margin-top:8px; display:flex; align-items:center; gap:8px;">
        <label style="min-width:150px;">Performance Mode</label>
        <select id="tenant-perf-mode">
          <option value="auto">Use Global / Auto</option>
          <option value="on">Force On</option>
          <option value="off">Force Off</option>
        </select>
        <button id="tenant-perf-revert" class="btn-secondary" style="margin-left:auto;">Revert</button>
      </div>

      <div class="policy-control" style="display:flex; align-items:center; gap:8px;">
        <label style="min-width:150px;">
          <input type="checkbox" id="tenant-auto-save-toggle"> Auto-save Layouts
        </label>
        <button id="tenant-auto-save-revert" class="btn-secondary" style="margin-left:auto;">Revert</button>
      </div>

      <div class="policy-control" style="display:flex; align-items:center; gap:8px;">
        <label style="min-width:150px;">
          <input type="checkbox" id="tenant-save-feedback-toggle"> Save Notifications
        </label>
        <button id="tenant-save-feedback-revert" class="btn-secondary" style="margin-left:auto;">Revert</button>
      </div>

      ${
			this.#options.enableNesting
				? `
      <div class="policy-control" style="display:flex; align-items:center; gap:8px;">
        <label style="min-width:150px;">
          <input type="checkbox" id="tenant-nesting-toggle"> Enable Nesting
        </label>
        <button id="tenant-nesting-revert" class="btn-secondary" style="margin-left:auto;">Revert</button>
      </div>`
				: ""
		}
      
      <button id="reset-policies" class="btn-secondary">Reset to Defaults</button>
    `;

		// Add event listeners
		this.#setupPolicyEventListeners(panel);
		this.#setupTenantPolicyEventListeners(panel);

		// Load current policy states
		this.#loadCurrentPolicyStates(panel);

		return panel;
	}

	/**
	 * Attaches event listeners to the controls within the policy panel.
	 * @private
	 * @param {HTMLElement} panel - The policy control panel element.
	 */
	#setupPolicyEventListeners(panel) {
		const perfModeToggle = panel.querySelector("#perf-mode-toggle");
		const autoSaveToggle = panel.querySelector("#auto-save-toggle");
		const saveFeedbackToggle = panel.querySelector("#save-feedback-toggle");
		const aiSuggestionsToggle = panel.querySelector(
			"#ai-suggestions-toggle"
		);
		const resetButton = panel.querySelector("#reset-policies");

		perfModeToggle.addEventListener("change", async (e) => {
			const mode = e.target.checked ? true : null; // true = force on, null = auto
			await this.#setPolicyWithFeedback(
				"system.grid_performance_mode",
				mode
			);
		});

		autoSaveToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_auto_save_layouts",
				e.target.checked
			);
		});

		saveFeedbackToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_save_feedback",
				e.target.checked
			);
		});

		aiSuggestionsToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_ai_suggestions",
				e.target.checked
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (e.target.checked && !this.#aiAssistant) {
				this.#aiAssistant =
					this.#stateManager.managers.aiLayoutAssistant;
			}
		});

		resetButton.addEventListener("click", () => {
			this.#resetPolicyDefaults();
		});
	}

	#setupTenantPolicyEventListeners(panel) {
		const svc = this.#gridPolicyService;
		if (!svc) return;

		const perfSelect = panel.querySelector("#tenant-perf-mode");
		const perfRevert = panel.querySelector("#tenant-perf-revert");
		const autoSaveToggle = panel.querySelector("#tenant-auto-save-toggle");
		const autoSaveRevert = panel.querySelector("#tenant-auto-save-revert");
		const saveFeedbackToggle = panel.querySelector(
			"#tenant-save-feedback-toggle"
		);
		const saveFeedbackRevert = panel.querySelector(
			"#tenant-save-feedback-revert"
		);
		const nestingToggle = panel.querySelector("#tenant-nesting-toggle");
		const nestingRevert = panel.querySelector("#tenant-nesting-revert");

		const toast = this.#toastManager;
		const okToast = (msg) => toast?.success?.(msg, 1500);
		const errToast = (msg) => toast?.error?.(msg, 2500);

		perfSelect?.addEventListener("change", async (e) => {
			const v = String(e.target.value);
			const val = v === "on" ? true : v === "off" ? false : null;
			try {
				await svc.setTenantPolicy(
					"system",
					"grid_performance_mode",
					val
				);
				okToast?.("Tenant performance mode updated");
			} catch {
				errToast?.("Failed to update tenant policy");
			}
		});
		perfRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy(
					"system",
					"grid_performance_mode",
					null
				);
				perfSelect.value = "auto";
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		autoSaveToggle?.addEventListener("change", async (e) => {
			try {
				await svc.setTenantPolicy(
					"system",
					"grid_auto_save_layouts",
					!!e.target.checked
				);
				okToast?.("Tenant auto-save updated");
			} catch {
				errToast?.("Failed to update");
			}
		});
		autoSaveRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy(
					"system",
					"grid_auto_save_layouts",
					null
				);
				autoSaveToggle.checked =
					this.#gridPolicyService.isAutoSaveEnabled();
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		saveFeedbackToggle?.addEventListener("change", async (e) => {
			try {
				await svc.setTenantPolicy(
					"system",
					"grid_save_feedback",
					!!e.target.checked
				);
				okToast?.("Tenant save feedback updated");
			} catch {
				errToast?.("Failed to update");
			}
		});
		saveFeedbackRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy("system", "grid_save_feedback", null);
				saveFeedbackToggle.checked =
					this.#gridPolicyService.shouldShowSaveFeedback();
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (nestingToggle && nestingRevert) {
			nestingToggle.addEventListener("change", async (e) => {
				try {
					await svc.setTenantPolicy(
						"grid",
						"nesting_enabled",
						!!e.target.checked
					);
					okToast?.("Tenant nesting updated");
				} catch {
					errToast?.("Failed to update");
				}
			});
			nestingRevert.addEventListener("click", async () => {
				try {
					await svc.setTenantPolicy("grid", "nesting_enabled", null);
					nestingToggle.checked = false;
					okToast?.("Reverted to global");
				} catch {
					errToast?.("Failed to revert"); /* noop */
				}
			});
		}
	}

	#setupNestingPolicyWatcher() {
		const handler = async (evt) => {
			const errToast = (msg) => this.#toastManager?.error?.(msg, 2500);
			try {
				if (
					!evt ||
					(evt.type !== "tenant_policy_updated" &&
						evt.type !== "policy_updated")
				)
					return;
				const { domain, key, newValue } = evt.data || {};
				if (domain !== "grid" || key !== "nesting_enabled") return;
				const enabled = Boolean(
					newValue ??
						this.#stateManager?.managers?.policies?.getPolicy(
							"grid",
							"nesting_enabled"
						)
				);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (enabled) {
					await this.#gridPolicyService?.registerGridPolicies?.({
						includeNesting: true,
					});
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (!this.#nestedGridManager) {
						const mod = await import("./NestedGridManager.js");
						this.#nestedGridManager = new mod.NestedGridManager({
							stateManager: this.#stateManager,
						});
					}
				} else {
					// Teardown: detach nested grids and release manager
					try {
						this.#nestedGridManager?.detachAll?.();
					} catch {
						errToast?.("Failed to update");
					}
					this.#nestedGridManager = null;
				}
			} catch {
				/* noop */
			}
		};
		this.#unsubscribeFunctions.push(
			this.#stateManager.on("policyEvent", handler)
		);
	}
	/**
	 * Sets a policy value and provides user feedback via a toast notification.
	 * @private
	 * @param {string} policyKey - The full key of the policy to set (e.g., 'system.grid_performance_mode').
	 * @param {*} value - The new value for the policy.
	 */
	async #setPolicyWithFeedback(policyKey, value) {
		try {
			// Use GridPolicyHelper or direct context access
			const [domain, key] = policyKey.split(".");
			await this.#stateManager.managers.policies.setPolicy(
				domain,
				key,
				value
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (this.#toastManager) {
				this.#toastManager.success(
					`Policy updated: ${policyKey}`,
					2000
				);
			}
		} catch (error) {
			console.error("Failed to set policy:", error);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (this.#toastManager) {
				this.#toastManager.error(
					`Failed to update policy: ${policyKey}`,
					3000
				);
			}
		}
	}

	/**
	 * Loads the current state of all grid-related policies and updates the control panel UI.
	 * @private
	 * @param {HTMLElement} panel - The policy control panel element.
	 */
	#loadCurrentPolicyStates(panel) {
		try {
			const policies = this.#gridPolicyService
				? this.#gridPolicyService.getGridPolicies()
				: {
						performanceMode: null,
						autoSave: true,
						saveFeedback: true,
						aiSuggestions: false,
					};

			panel.querySelector("#perf-mode-toggle").checked =
				policies.performanceMode === true;
			panel.querySelector("#auto-save-toggle").checked =
				policies.autoSave;
			panel.querySelector("#save-feedback-toggle").checked =
				policies.saveFeedback;
			panel.querySelector("#ai-suggestions-toggle").checked =
				policies.aiSuggestions;

			// Tenant section reflects effective values
			const perfSel = panel.querySelector("#tenant-perf-mode");
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (perfSel) {
				perfSel.value =
					policies.performanceMode === true
						? "on"
						: policies.performanceMode === false
							? "off"
							: "auto";
			}
			const as = panel.querySelector("#tenant-auto-save-toggle");
			if (as) as.checked = !!policies.autoSave;
			const sf = panel.querySelector("#tenant-save-feedback-toggle");
			if (sf) sf.checked = !!policies.saveFeedback;
			const nest = panel.querySelector("#tenant-nesting-toggle");
			if (nest)
				nest.checked =
					!!this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"nesting_enabled"
					);
		} catch (error) {
			console.warn("Could not load current policy states:", error);
		}
	}

	/**
	 * Displays a toast notification summarizing the status of currently active grid policies.
	 * @private
	 */
	#showPolicyStatus() {
		try {
			const policies = this.#gridPolicyService
				? this.#gridPolicyService.getGridPolicies()
				: {
						performanceMode: null,
						autoSave: true,
						saveFeedback: true,
						aiSuggestions: false,
					};

			console.log("Current Grid Policies:", policies);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (this.#toastManager) {
				const statusMessages = [];
				if (policies.performanceMode === true)
					statusMessages.push("🚀 Performance mode forced");
				if (policies.performanceMode === false)
					statusMessages.push("✨ Full features forced");
				if (!policies.autoSave)
					statusMessages.push("⚠️ Auto-save disabled");
				if (policies.aiSuggestions)
					statusMessages.push("🤖 AI suggestions enabled");

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */


				if (statusMessages.length > 0) {
					this.#toastManager.info(statusMessages.join(" • "), 4000);
				}
			}
		} catch (error) {
			console.warn("Could not show policy status:", error);
		}
	}

	/**
	 * Sets up event listeners to track grid interactions for analytics purposes.
	 * @private
	 */
	#setupAnalytics() {
		// Track grid usage patterns
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"layoutChanged",
					(data) => {
						this.#trackLayoutChange(data);
					}
				)
			);

			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"gridPerformanceMode",
					(data) => {
						this.#trackPerformanceMode(data);
					}
				)
			);

			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"policyChanged",
					(data) => {
						if (
							data.domain === "system" &&
							data.key.startsWith("grid_")
						) {
							this.#trackPolicyChange(data);
						}
					}
				)
			);
		}
	}

	#setupAnalyticsPanel() {
		try {
			const el = document.createElement("div");
			el.id = "grid-analytics-panel";
			el.style.cssText = `
				position: fixed; right: 20px; top: 20px; z-index: 10000;
				background: rgba(20,20,20,0.85); color: #fff; padding: 10px 12px; border-radius: 8px;
				font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
				display: none; min-width: 180px; box-shadow: 0 6px 18px rgba(0,0,0,0.3);
			`;
			el.innerHTML = `
				<div style="display:flex;justify-content:space-between;align-items:center;gap:6px;margin-bottom:6px;">
					<strong>Grid Analytics</strong>
					<button id="ga-close" style="background:#444;color:#fff;border:0;border-radius:4px;padding:2px 6px;cursor:pointer">×</button>
				</div>
				<div>FPS: <span id="ga-fps">—</span></div>
				<div>Blocks: <span id="ga-blocks">—</span></div>
				<div>Visible: <span id="ga-visible">—</span></div>
				<div style="margin-top:6px;opacity:0.8;">Toggle: Alt+G</div>
			`;
			document.body.appendChild(el);
			const close = () => (el.style.display = "none");
			el.querySelector("#ga-close").addEventListener("click", close);

			// Toggle hotkey
			const onKey = (e) => {
				if (e.altKey && e.key?.toLowerCase() === "g") {
					e.preventDefault();
					el.style.display =
						el.style.display === "none" ? "block" : "none";
				}
			};
			document.addEventListener("keydown", onKey);
			this.#unsubscribeFunctions.push(() =>
				document.removeEventListener("keydown", onKey)
			);

			// Update handlers
			const setText = (sel, v) => {
				const n = el.querySelector(sel);
				if (n) n.textContent = String(v);
			};
			const onFps = ({ fps }) => setText("#ga-fps", fps ?? "—");
			const onVis = ({ inView, total }) => {
				setText("#ga-visible", inView ?? "—");
				setText("#ga-blocks", total ?? "—");
			};
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridFps", onFps)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridBlockVisibility", onVis)
			);
		} catch {
			/* noop */
		}
	}

	/**
	 * Tracks a layout change event for analytics.
	 * @private
	 * @param {object} changeEvent - The layout change event data.
	 */
	#trackLayoutChange(changeEvent) {
		// Analytics tracking for layout changes
		const analyticsEvent = {
			category: "grid_interaction",
			action: changeEvent.changeType,
			label: changeEvent.blockId,
			value: 1,
			customDimensions: {
				userId: changeEvent.userId,
				autoSaved: changeEvent.autoSaved,
				position: `${changeEvent.position.x},${changeEvent.position.y}`,
				size: `${changeEvent.position.w}x${changeEvent.position.h}`,
			},
		};

		// Emit for analytics system
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit(
				"analyticsEvent",
				analyticsEvent
			);
		}
	}

	/**
	 * Tracks a performance mode change event for analytics.
	 * @private
	 * @param {object} data - The performance mode change event data.
	 */
	#trackPerformanceMode(data) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit("analyticsEvent", {
				category: "grid_performance",
				action: data.enabled
					? "performance_mode_on"
					: "performance_mode_off",
				label: data.reason,
				value: data.fps || 0,
			});
		}
	}

	/**
	 * Tracks a policy change event for analytics.
	 * @private
	 * @param {object} data - The policy change event data.
	 */
	#trackPolicyChange(data) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit("analyticsEvent", {
				category: "grid_policy",
				action: "policy_changed",
				label: data.key,
				value: data.value ? 1 : 0,
			});
		}
	}

	/**
	 * Resets all grid-related policies to their default values.
	 * @private
	 */
	#resetPolicyDefaults() {
		// Reset all grid policies to defaults
		const defaults = {
			grid_performance_mode: null,
			grid_auto_save_layouts: true,
			grid_save_feedback: true,
			grid_ai_suggestions: false,
		};

		Object.entries(defaults).forEach(async ([key, value]) => {
			await this.#setPolicyWithFeedback(`system.${key}`, value);
		});

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (this.#toastManager) {
			this.#toastManager.success("Grid policies reset to defaults", 3000);
		}
	}

	// Public API

	/**


	 * TODO: Add JSDoc for method isInitialized


	 * @memberof AutoGenerated


	 */


	isInitialized() {
		return this.#initialized;
	}

	/**
	 * Cleans up all resources and event listeners used by the grid system.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method destroy

	 * @memberof AutoGenerated

	 */

	destroy() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#gridEnhancer) {
			this.#gridEnhancer.disable();
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (this.#toastManager) {
			this.#toastManager.destroy();
		}

		// Remove event listeners
		this.#unsubscribeFunctions.forEach((unsubscribe) => unsubscribe());
		this.#unsubscribeFunctions = [];
	}
}

export default CompleteGridSystem;

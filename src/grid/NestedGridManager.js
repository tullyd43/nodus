/**
 * @file NestedGridManager.js
 * @description Attaches nested grid instances inside grid blocks with policy-bound depth and size constraints.
 */

export class NestedGridManager {
	#stateManager;
	#policy;
	#instances = new Map(); // container -> renderer

	/**


	 * TODO: Add JSDoc for method constructor


	 * @memberof AutoGenerated


	 */


	constructor({ stateManager }) {
		this.#stateManager = stateManager;
		this.#policy = stateManager?.managers?.policies;
	}

	/**
	 * Attaches a nested grid inside a given grid block element if allowed by policy and config.
	 * - Only attaches inside elements with class `grid-block`.
	 * - Enforces max depth and max blocks per grid.
	 * @param {HTMLElement} blockEl The parent grid block element.
	 * @param {object} appViewModel The app view model to pass to the renderer.
	 * @param {{ blocks?: Array<any>, templates?: object, columns?: number }} nestedConfig Optional nested grid config.
	 * @param {number} depth Current nesting depth (root = 0).
	 */
	/**

	 * TODO: Add JSDoc for method attach

	 * @memberof AutoGenerated

	 */

	async attach(blockEl, appViewModel, nestedConfig = {}, depth = 0) {
		try {
			if (!blockEl || !blockEl.classList?.contains("grid-block")) return;
			if (!this.#isNestingEnabled()) return;
			const maxDepth = this.#getNumber("grid", "nesting_max_depth", 2);
			if (depth >= maxDepth) return;

			const container = document.createElement("div");
			container.className = "grid-container nested-grid";
			container.dataset.nestingDepth = String(depth + 1);
			container.style.marginTop = "8px";
			// ensure a visually contained nested area
			container.style.borderTop = "1px dashed rgba(0,0,0,0.1)";
			const content =
				blockEl.querySelector(".grid-block-content") || blockEl;
			content.appendChild(container);

			// Bound blocks per grid
			const maxBlocks = this.#getNumber(
				"grid",
				"nesting_max_blocks_per_grid",
				24
			);
			const blocks = Array.isArray(nestedConfig?.blocks)
				? nestedConfig.blocks.slice(0, maxBlocks)
				: [];

			// V8.0 Parity: Mandate 1.2 - No Direct Instantiation. Get service from the state manager.
			const renderer =
				this.#stateManager.managers?.enhancedGridRenderer ||
				this.#stateManager.serviceRegistry?.createNamespacedInstance?.(
					"enhancedGridRenderer",
					{ stateManager: this.#stateManager }
				);

			if (!renderer) return;

			// Initialize the managed renderer with its specific container and view model
			await renderer.initialize({ container, appViewModel });
			this.#instances.set(container, renderer);

			// Apply optional columns override
			const cols = Number(nestedConfig?.columns);
			if (Number.isInteger(cols) && cols > 0)
				renderer.setGridColumns?.(cols);

			// Seed blocks if provided (minimal DOM scaffolding consistent with root)
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				const blk = document.createElement("div");
				blk.className = "grid-block";
				blk.dataset.blockId = b.id;
				blk.dataset.minW = String(b.constraints?.minW ?? 1);
				blk.dataset.minH = String(b.constraints?.minH ?? 1);
				blk.dataset.maxW = String((b.constraints?.maxW ?? cols) || 24);
				blk.dataset.maxH = String(b.constraints?.maxH ?? 1000);
				const inner = document.createElement("div");
				inner.className = "grid-block-content";
				blk.appendChild(inner);
				container.appendChild(blk);

				// Recurse if nested config provided and within depth limits
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (b.nestedGrid) {
					await this.attach(
						blk,
						appViewModel,
						b.nestedGrid,
						depth + 1
					);
				}
			}

			// Apply initial positions
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				renderer.updateBlockPosition?.(b.id, b.x, b.y, b.w, b.h);
			}
		} catch {
			// noop
		}
	}

	/** Detaches and destroys all nested grid instances created by this manager. */
	/**

	 * TODO: Add JSDoc for method detachAll

	 * @memberof AutoGenerated

	 */

	detachAll() {
		try {
			for (const [container, renderer] of this.#instances.entries()) {
				try {
					renderer?.destroy?.();
				} catch {
					/* noop */
				}
				try {
					container.parentElement?.removeChild(container);
				} catch {
					/* noop */
				}
			}
			this.#instances.clear();
		} catch {
			/* noop */
		}
	}

	#isNestingEnabled() {
		try {
			return !!this.#policy?.getPolicy("grid", "nesting_enabled");
		} catch {
			return false;
		}
	}

	#getNumber(domain, key, def) {
		try {
			const v = this.#policy?.getPolicy(domain, key);
			return Number.isFinite(v) ? v : def;
		} catch {
			return def;
		}
	}
}

export default NestedGridManager;

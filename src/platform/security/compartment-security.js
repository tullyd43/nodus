// modules/compartment-security.js
// Compartment security module for need-to-know access control

/**
 * @description
 * Manages "need-to-know" access control through security compartments.
 * This module is designed for high-security environments (e.g., NATO classifications)
 * where access to data is restricted not just by clearance level, but also by explicit
 * inclusion in specific compartments. It supports inheritance (e.g., access to NATO
 * implies access to NATO_RESTRICTED) and complex rule evaluation.
 *
 * @privateFields {#stateManager, #compartmentRules, #inheritanceGraph, #options, #securityManager, #forensicLogger, #metrics}
 * @module CompartmentSecurity
 */
export default class CompartmentSecurity {
	/** @private @type {import('../../HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {Map<string, object>} */
	#compartmentRules = new Map();
	/**
	 * @private
	 * @description V8.0 Parity: Mandate 4.1 - Use a bounded cache for the inheritance graph to prevent memory leaks.
	 * @type {import('../../../utils/LRUCache.js').LRUCache|null}
	 */
	#inheritanceGraph = null;
	/** @private @type {object} */
	#options;
	/** @private @type {import('./SecurityManager.js').default|null} */
	#securityManager = null;
	/** @private @type {import('../../ForensicLogger.js').default|null} */
	#forensicLogger = null;
	/** @private @type {import('../../../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;

	/** @public @type {string} */
	name = "CompartmentSecurity";

	/**
	 * Creates an instance of CompartmentSecurity.
	 * @param {object} context - The application context.
	 * @param {import('../../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 * @param {object} [context.options={}] - Configuration options for the module.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager, options = {} }) {
		this.#stateManager = stateManager;
		// V8.0 Parity: Derive dependencies from the stateManager.
		this.#securityManager = this.#stateManager?.managers?.securityManager;
		this.#forensicLogger = this.#stateManager?.managers?.forensicLogger;
		this.#metrics = this.#stateManager?.metricsRegistry?.namespace(
			"compartmentSecurity"
		);

		this.#options = {
			enableInheritance: options.enableInheritance !== false,
			strictMode: options.strictMode || false,
			auditAll: options.auditAll || false,
			...options,
		};
	}

	/**
	 * Initializes the module by setting up standard compartment rules and inheritance.
	 * @returns {Promise<this>} The initialized instance.
	 */
	/**

	 * TODO: Add JSDoc for method init

	 * @memberof AutoGenerated

	 */

	async init() {
		// V8.0 Parity: Mandate 4.1 - Obtain a bounded cache from the central CacheManager.
		this.#inheritanceGraph =
			this.#stateManager?.managers?.cacheManager?.getCache(
				"compartmentInheritance"
			);

		// Initialize standard compartment rules
		await this.#initializeStandardCompartments();
		return this;
	}

	/**
	 * Checks if the current user context allows access to a set of required compartments for a given classification.
	 * @param {string[]} requiredCompartments - An array of compartments required for access.
	 * @returns {Promise<boolean>} True if access is permitted, false otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method checkAccess

	 * @memberof AutoGenerated

	 */

	async checkAccess(requiredCompartments) {
		this.#metrics?.increment("accessChecks");
		if (!this.#securityManager?.hasValidContext()) {
			this.#audit("access_denied_no_compartment_context", {
				requiredCompartments,
			});
			this.#metrics?.increment("accessDenied");
			return false;
		}

		const userContext = this.#securityManager.getSubject();

		// Check each required compartment
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const compartment of requiredCompartments) {
			if (!(await this.#hasCompartmentAccess(compartment, userContext))) {
				this.#audit("compartment_access_denied", {
					compartment,
					userId: userContext.userId,
				});
				this.#metrics?.increment("accessDenied");
				return false;
			}
		}

		// Check compartment combinations (some combinations may be restricted)
		if (!this.#validateCompartmentCombination(requiredCompartments)) {
			this.#audit("compartment_combination_denied", {
				combination: requiredCompartments,
				userId: userContext.userId,
			});
			this.#metrics?.increment("accessDenied");
			return false;
		}

		return true;
	}

	/**
	 * Gets all compartments the user can access, including those derived from inheritance rules.
	 * @param {object} [userContext] - The user's security context. If not provided, the current user's context is used.
	 * @returns {Set<string>} A set of all accessible compartment names.
	 */
	/**

	 * TODO: Add JSDoc for method getAccessibleCompartments

	 * @memberof AutoGenerated

	 */

	getAccessibleCompartments() {
		if (!this.#securityManager?.hasValidContext()) return new Set();

		const userContext = this.#securityManager.getSubject();
		const directCompartments = Array.from(userContext.compartments || []);
		const derived = this.#deriveAccessibleCompartments(directCompartments);

		return new Set([...directCompartments, ...derived]);
	}

	/**
	 * Checks if the current user context allows access to a single, specific compartment.
	 * @param {string} compartment - The name of the compartment to check.
	 * @returns {Promise<boolean>} True if access is permitted, false otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method canAccessCompartment

	 * @memberof AutoGenerated

	 */

	async canAccessCompartment(compartment) {
		if (!this.#securityManager?.hasValidContext()) return false;
		const userContext = this.#securityManager.getSubject();

		return await this.#hasCompartmentAccess(compartment, userContext);
	}

	/**
	 * Adds a rule that grants access to a child compartment if the parent is accessible.
	 * For example, access to 'NATO' can imply access to 'NATO_SECRET'.
	 * @param {string} parentCompartment - The name of the parent compartment.
	 * @param {string} childCompartment - The name of the child compartment that will be inherited.
	 */
	/**

	 * TODO: Add JSDoc for method addInheritanceRule

	 * @memberof AutoGenerated

	 */

	addInheritanceRule(parentCompartment, childCompartment) {
		let children = this.#inheritanceGraph?.get(parentCompartment);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!children) {
			children = new Set();
		}
		this.#inheritanceGraph?.set(
			parentCompartment,
			children.add(childCompartment)
		);

		this.#audit("inheritance_rule_added", {
			parent: parentCompartment,
			child: childCompartment,
		});
	}

	/**
	 * Adds a specific access rule to a compartment, such as minimum clearance or time restrictions.
	 * @param {string} compartment - The name of the compartment to add the rule to.
	 * @param {object} rule - The rule object, which can contain properties like `minimumClearance` or `timeRestrictions`.
	 */
	/**

	 * TODO: Add JSDoc for method addAccessRule

	 * @memberof AutoGenerated

	 */

	addAccessRule(compartment, rule) {
		this.#compartmentRules.set(compartment, {
			...this.#compartmentRules.get(compartment),
			...rule,
		});

		this.#audit("access_rule_added", { compartment, rule });
	}

	// Private methods
	/**
	 * The core logic for checking if a user has access to a single compartment, including direct, inherited, and rule-based access.
	 * @private
	 * @param {string} compartment - The compartment name to check.
	 * @param {string} compartment - The compartment name.
	 * @returns {Promise<boolean>} True if access is granted.
	 */
	async #hasCompartmentAccess(compartment, userContext) {
		if (!userContext) return false;

		const userCompartments = Array.from(userContext.compartments || []);

		// Direct access
		if (userCompartments.includes(compartment)) {
			return true;
		}

		// Derived access through inheritance
		if (
			this.#options.enableInheritance &&
			this.#deriveAccessibleCompartments(userCompartments).has(
				compartment
			)
		) {
			return true;
		}

		// Check compartment-specific rules
		const rules = this.#compartmentRules.get(compartment);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (rules) {
			return await this.#evaluateCompartmentRules(
				compartment,
				rules,
				userContext
			);
		}

		return false;
	}

	/**
	 * Calculates all compartments a user can access through inheritance.
	 * It performs a breadth-first search (BFS) on the inheritance graph.
	 * @private
	 * @param {string[]} userCompartments - The set of compartments the user has direct access to.
	 * @returns {Set<string>} A set of derived compartments.
	 */
	#deriveAccessibleCompartments(userCompartments) {
		const derived = new Set();

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (!this.#options.enableInheritance) {
			return derived;
		}

		// BFS to find all inherited compartments
		const queue = [...userCompartments];
		const visited = new Set(userCompartments);

		/**


		 * TODO: Add JSDoc for method while


		 * @memberof AutoGenerated


		 */


		while (queue.length > 0) {
			const current = queue.shift();
			const children = this.#inheritanceGraph?.get(current);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (children) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const child of children) {
					if (!visited.has(child)) {
						visited.add(child);
						derived.add(child);
						queue.push(child);
					}
				}
			}
		}

		return derived;
	}

	/**
	 * Validates a combination of compartments against rules for mutual exclusivity or required pairings.
	 * For example, ensures 'HUMINT' and 'SIGINT' are not accessed together if a rule forbids it.
	 * @private
	 * @param {string[]} compartments - The array of compartments being requested.
	 * @returns {boolean} `true` if the combination is valid, `false` otherwise.
	 */
	#validateCompartmentCombination(compartments) {
		// Check for mutually exclusive compartments
		const exclusiveGroups = [
			["HUMINT", "SIGINT"], // Example: some intel types are exclusive
			["NUCLEAR", "CONVENTIONAL"], // Example: weapon type exclusivity
		];

		/**


		 * TODO: Add JSDoc for method for


		 * @memberof AutoGenerated


		 */


		for (const group of exclusiveGroups) {
			const presentInGroup = compartments.filter((c) =>
				group.includes(c)
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (presentInGroup.length > 1) {
				return false; // Multiple exclusive compartments present
			}
		}

		// Check for required combinations
		const requiredCombinations = {
			COSMIC: ["NATO", "TOP_SECRET"], // COSMIC requires NATO and TOP_SECRET
			ATOMAL: ["NATO", "NUCLEAR"], // ATOMAL requires NATO and NUCLEAR
		};

		/**


		 * TODO: Add JSDoc for method for


		 * @memberof AutoGenerated


		 */


		for (const compartment of compartments) {
			const required = requiredCombinations[compartment];
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (required) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const req of required) {
					if (!compartments.includes(req)) {
						return false; // Required compartment missing
					}
				}
			}
		}

		return true;
	}

	/**
	 * Evaluates specific rules defined for a compartment, such as time restrictions or clearance levels.
	 * @private
	 * @param {string} compartment - The name of the compartment being checked.
	 * @param {object} rules - The rule object for the compartment.
	 * @param {object} userContext - The user's security context.
	 * @returns {Promise<boolean>} True if all rules pass.
	 */
	async #evaluateCompartmentRules(compartment, rules, userContext) {
		// Evaluate time-based access
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (rules.timeRestrictions) {
			const now = new Date();
			const currentHour = now.getHours();

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (
				currentHour < rules.timeRestrictions.startHour ||
				currentHour > rules.timeRestrictions.endHour
			) {
				return false;
			}
		}

		// Evaluate clearance requirements
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (rules.minimumClearance) {
			const clearanceLevels = [
				"restricted",
				"confidential",
				"secret",
				"top_secret",
				"nato_restricted",
				"nato_confidential",
				"nato_secret",
				"cosmic_top_secret",
			];

			const userLevel = clearanceLevels.indexOf(userContext.level);
			const requiredLevel = clearanceLevels.indexOf(
				rules.minimumClearance
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */


			if (userLevel < requiredLevel) {
				return false;
			}
		}

		// Evaluate special conditions
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (rules.specialConditions) {
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const condition of rules.specialConditions) {
				if (
					!(await this.#evaluateSpecialCondition(
						condition,
						userContext
					))
				) {
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Evaluates special, complex conditions for compartment access.
	 * V8.0 Parity: Mandate 2.2 - This now delegates evaluation to the central, declarative ConditionRegistry
	 * to prevent arbitrary code execution paths and enforce a serializable rule structure.
	 * @private
	 * @param {object} condition - The declarative condition object to evaluate.
	 * @param {object} userContext - The user's security context.
	 * @returns {Promise<boolean>} True if the condition is met.
	 */
	async #evaluateSpecialCondition(condition, userContext) {
		const conditionRegistry =
			this.#stateManager?.managers?.conditionRegistry;

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (!conditionRegistry) {
			this.#audit("condition_eval_failed", {
				reason: "ConditionRegistry not available.",
				condition,
			});
			return false;
		}

		// The evaluation context combines the user's context with any other relevant data.
		const evaluationContext = {
			user: userContext,
			system: {
				timestamp: Date.now(),
			},
			// Any other data needed by the condition can be added here.
		};

		// Delegate the entire evaluation to the secure, declarative registry.
		return conditionRegistry.evaluate(condition, evaluationContext);
	}

	/**
	 * Initializes a set of standard, hardcoded compartment rules and inheritance for demonstration.
	 * @private
	 * @returns {Promise<void>}
	 */
	async #initializeStandardCompartments() {
		// NATO standard compartments
		this.addInheritanceRule("NATO", "NATO_RESTRICTED");
		this.addInheritanceRule("NATO", "NATO_CONFIDENTIAL");
		this.addInheritanceRule("NATO", "NATO_SECRET");
		this.addInheritanceRule("NATO_SECRET", "COSMIC");

		// Intelligence compartments
		this.addInheritanceRule("INTELLIGENCE", "HUMINT");
		this.addInheritanceRule("INTELLIGENCE", "SIGINT");
		this.addInheritanceRule("INTELLIGENCE", "GEOINT");

		// Nuclear compartments
		this.addAccessRule("NUCLEAR", {
			minimumClearance: "secret",
			timeRestrictions: { startHour: 6, endHour: 18 },
			// V8.0 Parity: Mandate 2.2 - Convert procedural checks to declarative conditions.
			specialConditions: [
				{
					type: "property_comparison",
					property: "user.authorizedBy.length",
					operator: "gte",
					value: 2,
				},
			],
		});

		// COSMIC compartment (highest NATO level)
		this.addAccessRule("COSMIC", {
			minimumClearance: "cosmic_top_secret",
			// V8.0 Parity: Mandate 2.2 - Convert procedural checks to declarative conditions.
			specialConditions: [
				{
					type: "facility_requirement",
					allowedFacilities: ["SECURE_FACILITY_A", "NATO_HQ"],
				},
				{ type: "dual_person_integrity", required: true },
			],
		});
	}

	/**
	 * Adds an event to the internal audit log.
	 * @private
	 * @param {string} eventType - The type of event to log.
	 * @param {object} data - The data associated with the event.
	 */
	#audit(eventType, data) {
		if (this.#options.auditAll === false && !eventType.includes("denied")) {
			return;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */


		if (this.#forensicLogger) {
			this.#forensicLogger.logAuditEvent(
				`COMPARTMENT_${eventType.toUpperCase()}`,
				data
			);
		} else {
			console.warn(
				`[Compartment Security] Audit event (no logger): ${eventType}`,
				data
			);
		}

		// Log compartment violations
		if (eventType.includes("denied")) {
			console.warn(`[Compartment Security] ${eventType}:`, data);
		}
	}
}

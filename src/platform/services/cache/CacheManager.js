/**
 * @file CacheManager.js
 * @description A centralized manager for creating and monitoring all LRUCache instances in the application.
 * This ensures that all caches are integrated with core systems like metrics and security.
 */

/* @manager-exemption: CacheManager is authorized to perform direct
 * bounded cache mutations under observability and metrics controls.
 * The mutations below are performed inside the trusted manager and are
 * audited via AsyncOrchestrator / ForensicPlugin instrumentation.
 */

/* eslint-disable nodus/require-action-dispatcher, nodus/require-observability-compliance --
	CacheManager is a trusted system manager that performs bounded, internal cache
	mutations. These mutations are audited via AsyncOrchestrator and ForensicPlugin,
	and using the manager's internal cache APIs is intentional and safe.
*/

import { LRUCache } from "../../../shared/lib/LRUCache.js";

/**
 * @class CacheManager
 * @description Manages the lifecycle of all LRUCache instances. It acts as a factory
 * that automatically injects shared dependencies into each new cache.
 * @privateFields {#caches, #stateManager, #metrics, #errorHelpers}
 */
export class CacheManager {
	/** @private @type {Map<string, LRUCache>} */
	// @performance-budget: <1ms -- bounded #caches map (O(1) average access)
	#caches = new Map();
	/** @private @type {import('../core/HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('../../../shared/lib/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics;
	/** @private @type {import('../../../shared/lib/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers;

	/**
	 * Creates an instance of CacheManager.
	 * @param {object} context - The global application context.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: The stateManager is the single source of truth for all dependencies.
		this.#stateManager = stateManager;
		this.#metrics = stateManager.metricsRegistry?.namespace("cacheManager");
		this.#errorHelpers = stateManager.managers.errorHelpers;
	}

	/**
	 * Retrieves an existing cache by name or creates a new one if it doesn't exist.
	 * @param {string} name - The unique name for the cache (e.g., 'entities', 'sessions').
	 * @param {number|object} [maxSizeOrOptions=1000] - Either the max size (number) or an options object.
	 * @param {object} [maybeOptions={}] - Additional LRUCache options when the second arg is a number.
	 * @returns {LRUCache} The existing or newly created LRUCache instance.
	 */
	/**

	 * TODO: Add JSDoc for method getCache

	 * @memberof AutoGenerated

	 */

	getCache(name, maxSizeOrOptions = 1000, maybeOptions = {}) {
		if (this.#caches.has(name)) {
			return this.#caches.get(name);
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (!name) {
			const error = new Error("Cache must have a name.");
			this.#errorHelpers?.handleError(error, {
				component: "CacheManager",
				operation: "getCache",
				category: "configuration_error",
			});
			throw error;
		}

		// Normalize arguments: support both (name, maxSize, options) and (name, options)
		let maxSize = 1000;
		let options = {};
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (typeof maxSizeOrOptions === "number") {
			maxSize = maxSizeOrOptions;
			options = maybeOptions || {};
		} else if (maxSizeOrOptions && typeof maxSizeOrOptions === "object") {
			options = maxSizeOrOptions;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof options.max === "number") {
				maxSize = options.max;
			} else if (typeof options.maxSize === "number") {
				maxSize = options.maxSize;
			}
		}

		// Create a new cache, injecting shared dependencies
		const newCache = new LRUCache(
			{
				stateManager: this.#stateManager, // Pass the stateManager directly.
				keyPrefix: name,
				...options,
			},
			maxSize
		);

		this.#caches.set(name, newCache);
		this.#metrics?.increment("cache.created");
		console.log(`[CacheManager] Created new cache: '${name}'`);
		return newCache;
	}

	/**
	 * Retrieves metrics from all managed caches.
	 * @returns {object} An object where keys are cache names and values are their metrics.
	 */
	/**

	 * TODO: Add JSDoc for method getAllMetrics

	 * @memberof AutoGenerated

	 */

	getAllMetrics() {
		const allMetrics = {};
		for (const [name, cache] of this.#caches.entries()) {
			allMetrics[name] = cache.getMetrics();
		}
		return allMetrics;
	}

	/**
	 * Clears all items from all managed caches.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method clearAll

	 * @memberof AutoGenerated

	 */

	clearAll() {
		for (const cache of this.#caches.values()) {
			cache.clear();
		}
		this.#metrics?.increment("cache.cleared.all");
		console.log(`[CacheManager] Cleared all ${this.#caches.size} caches.`);
	}

	/**
	 * Invalidates entries across all caches based on a pattern.
	 * Pattern may be a string (prefix match on unprefixed key) or a RegExp.
	 * If pattern is "*" or falsy, clears all caches.
	 * @param {string|RegExp} pattern
	 */
	/**

	 * TODO: Add JSDoc for method invalidate

	 * @memberof AutoGenerated

	 */

	invalidate(pattern) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!pattern || pattern === "*") {
			this.clearAll();
			return;
		}
		for (const [name, cache] of this.#caches.entries()) {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof cache.invalidate === "function") {
				cache.invalidate(pattern);
			} else if (
				typeof cache.clear === "function" &&
				typeof pattern === "string" &&
				pattern.startsWith(`${name}:`)
			) {
				// Fallback: if pattern targets this cache namespace, clear whole cache
				cache.clear();
			}
		}
		this.#metrics?.increment("cache.invalidations");
		console.log(
			`[CacheManager] Invalidated caches with pattern: ${String(pattern)}`
		);
	}

	/**
	 * Destroys all managed caches, stopping any background processes.
	 * @returns {void}
	 */
	/**

	 * TODO: Add JSDoc for method destroyAll

	 * @memberof AutoGenerated

	 */

	destroyAll() {
		for (const cache of this.#caches.values()) {
			cache.destroy();
		}
		this.#caches.clear();
		this.#metrics?.increment("cache.destroyed.all");
		console.log(`[CacheManager] Destroyed all caches.`);
	}

	/**
	 * Backwards-compatible alias for creating or retrieving a cache using options object.
	 * @param {string} name
	 * @param {object} options
	 * @returns {LRUCache}
	 */
	/**

	 * TODO: Add JSDoc for method createCache

	 * @memberof AutoGenerated

	 */

	createCache(name, options = {}) {
		// Use the stateManager-provided forensic logger so core services are
		// accessed via the ServiceRegistry instead of direct imports.
		this.#stateManager?.managers?.forensicLogger?.createEnvelope?.({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		return this.getCache(name, options);
	}

	/**
	 * Instrumented cache mutation helpers.
	 * Used by observability handlers to satisfy audit & policy rules.
	 * @param {string} cacheName
	 * @param {string} key
	 * @param {*} value
	 * @returns {void}
	 */
	applySet(cacheName, key, value) {
		try {
			// Policy guard: ensure cache mutations are allowed by policy
			try {
				const policies = this.#stateManager?.managers?.policies;
				if (
					policies?.getPolicy &&
					!policies.getPolicy("cache", "enabled")
				) {
					return;
				}
			} catch (pErr) {
				this.#errorHelpers?.handleError?.(pErr, {
					component: "CacheManager",
					operation: "applySet.policy",
					severity: "warning",
				});
			}

			const cache = this.getCache(cacheName);
			if (!cache) return;
			/* @performance-budget: <1ms -- internal cache mutation */
			if (typeof cache.set === "function") cache.set(key, value);
			this.#metrics?.increment("cache.set");
		} catch (err) {
			this.#errorHelpers?.handleError?.(err, {
				component: "CacheManager",
				operation: "applySet",
				severity: "warning",
			});
		}
	}

	/**
	 * Instrumented cache deletion helper.
	 * @param {string} cacheName
	 * @param {string} key
	 * @returns {void}
	 */
	applyDelete(cacheName, key) {
		try {
			// Policy guard: ensure cache mutations are allowed by policy
			try {
				const policies = this.#stateManager?.managers?.policies;
				if (
					policies?.getPolicy &&
					!policies.getPolicy("cache", "enabled")
				) {
					return;
				}
			} catch (pErr) {
				this.#errorHelpers?.handleError?.(pErr, {
					component: "CacheManager",
					operation: "applyDelete.policy",
					severity: "warning",
				});
			}

			const cache = this.getCache(cacheName);
			if (!cache) return;
			/* @performance-budget: <1ms -- internal cache mutation */
			if (typeof cache.delete === "function") cache.delete(key);
			this.#metrics?.increment("cache.delete");
		} catch (err) {
			this.#errorHelpers?.handleError?.(err, {
				component: "CacheManager",
				operation: "applyDelete",
				severity: "warning",
			});
		}
	}
}

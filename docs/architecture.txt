# System Architecture Document
**Organizational Ecosystem Application - Hybrid Offline-First + Server Architecture**

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Hybrid Architecture Overview](#hybrid-architecture-overview)
3. [PostgreSQL Server Architecture](#postgresql-server-architecture)
4. [IndexedDB Client Architecture](#indexeddb-client-architecture)
5. [Synchronization Architecture](#synchronization-architecture)
6. [Application Layer Architecture](#application-layer-architecture)
7. [Performance & Scalability](#performance--scalability)
8. [Security & Multi-User Architecture](#security--multi-user-architecture)
9. [Development Architecture](#development-architecture)
10. [Deployment Architecture](#deployment-architecture)
11. [Future Platform Architecture](#future-platform-architecture)

---

## Executive Summary

The Organizational Ecosystem Application represents a paradigm shift in productivity software architecture, built on the foundation of **radical simplicity** and **universal extensibility** with a **hybrid offline-first + server architecture**. The system employs a dual-entity data model where everything is either an **Event** (actions, commitments, temporal data) or an **Item** (quantifiable assets), creating a unified framework that scales from personal task management (1K records) to enterprise collaboration (1M+ records) while maintaining complete offline functionality.

### Key Architectural Achievements

1. **Hybrid Offline-First Design** - Complete functionality without server dependency + unlimited server scale
2. **PostgreSQL + JSONB Performance** - Real columns for common queries (10x faster) + JSONB flexibility
3. **Identical Schema Strategy** - Seamless sync between PostgreSQL server and IndexedDB client
4. **Clean, Simple, Pure Data Structures** - Optimized for scalability, speed, maintainability, and extendibility
5. **DRY (Don't Repeat Yourself)** - Universal systems eliminate duplication across modules
6. **Schema-Driven Flexibility** - User configurations stored as data, not code
7. **Enterprise-Ready Security** - Row-level security, multi-user collaboration, real-time conflict resolution
8. **Radically Simplified Schema** - 18 tables achieving infinite customization through configuration

---

## Hybrid Architecture Overview

### Core Philosophy: Offline-First + Server Scale

**Everything is either an Event or an Item.** This fundamental principle drives all architectural decisions across both client and server layers.

The hybrid architecture provides the best of both worlds:
- **Complete offline functionality** via IndexedDB intelligent cache
- **Unlimited server scale** via PostgreSQL + JSONB backend
- **Seamless synchronization** with identical schemas
- **Enterprise collaboration** with real-time conflict resolution

### Architectural Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     CLIENT LAYER                           │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │
│  │   Events Tab    │ │   Vault Tab     │ │ Templates Tab   │ │
│  │ - Quick Input   │ │ - Collections   │ │ - Event Types   │ │
│  │ - Event List    │ │ - Tags          │ │ - Field Library │ │
│  │ - Calendar      │ │ - Relationships │ │ - Content Tmpl  │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                    VIEWMODEL LAYER                         │
├─────────────────────────────────────────────────────────────┤
│  EventViewModel  │  ItemViewModel  │  CollectionViewModel   │
│  - State Mgmt    │  - Inventory    │  - Dynamic Filtering   │
│  - Validation    │  - Tracking     │  - Real-time Updates   │
│  - Offline Queue │  - Sync Status  │  - Conflict Resolution │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                     MODEL LAYER                            │
├─────────────────────────────────────────────────────────────┤
│    Event Model   │   Item Model    │   Universal Models     │
│    - Local CRUD  │   - Local CRUD  │   - Tag Model          │
│    - Sync Logic  │   - Sync Logic  │   - Link Model         │
│    - Conflict    │   - Conflict    │   - Collection Model   │
│    - Resolution  │   - Resolution  │   - Sync Queue Model   │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│              INTELLIGENT SYNC LAYER                        │
├─────────────────────────────────────────────────────────────┤
│ ┌─────────────────┐           ┌─────────────────────────────┐ │
│ │ Offline Queue   │ ◄────────► │    Conflict Resolution    │ │
│ │ - CREATE ops    │           │ - Server wins             │ │
│ │ - UPDATE ops    │           │ - Client wins             │ │
│ │ - DELETE ops    │           │ - Smart merge             │ │
│ │ - Retry logic   │           │ - Manual resolution       │ │
│ └─────────────────┘           └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│              CLIENT DATABASE LAYER                         │
├─────────────────────────────────────────────────────────────┤
│                IndexedDB Cache (10K records)               │
│  - Recent events (last 30 days)                            │
│  - Starred/pinned items                                     │
│  - Active projects and collections                          │
│  - Offline modification queue                               │
│  - 18 tables (mirrors server schema exactly)               │
└─────────────────────────────────────────────────────────────┘
                               ▲ ▼ Bidirectional Sync
┌─────────────────────────────────────────────────────────────┐
│               SERVER DATABASE LAYER                        │
├─────────────────────────────────────────────────────────────┤
│              PostgreSQL + JSONB (Unlimited)                │
│  - Full dataset with enterprise performance                │
│  - Real columns + JSONB custom fields                      │
│  - Advanced search and analytics                           │
│  - Multi-user collaboration                                │
│  - Row-level security                                      │
│  - 18 tables (identical to client)                         │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                   API SERVER LAYER                         │
├─────────────────────────────────────────────────────────────┤
│  Node.js + Express RESTful API                             │
│  - Authentication & Authorization                           │
│  - JSONB query optimization                                │
│  - Real-time updates (WebSocket)                           │
│  - Rate limiting & security                                │
│  - Multi-tenant support                                    │
└─────────────────────────────────────────────────────────────┘
```

### Technology Stack

```javascript
// Complete hybrid technology stack
const architecture = {
  // Client Layer
  frontend: {
    language: 'Vanilla JavaScript ES2022',
    architecture: 'MVVM (Model-View-ViewModel)',
    database: 'IndexedDB + Dexie.js (intelligent cache)',
    ui: 'CSS3 with custom properties',
    performance: 'Strategic compound indexes'
  },
  
  // Server Layer  
  backend: {
    language: 'Node.js + JavaScript',
    framework: 'Express.js RESTful API',
    database: 'PostgreSQL + JSONB (primary storage)',
    authentication: 'JWT with row-level security',
    realtime: 'WebSocket for live updates'
  },
  
  // Synchronization
  sync: {
    strategy: 'Bidirectional intelligent sync',
    conflicts: 'Real-time conflict resolution',
    offline: 'Complete offline functionality',
    caching: '10K most relevant records locally'
  },
  
  // Deployment
  infrastructure: {
    containerization: 'Docker + Docker Compose',
    database: 'PostgreSQL with optimized indexes',
    caching: 'Intelligent client-side caching',
    scaling: 'Horizontal server scaling ready'
  }
};
```

---

## PostgreSQL Server Architecture

### Enterprise Database Design

The PostgreSQL server provides unlimited scale, advanced features, and enterprise performance while maintaining the same 18-table structure as the IndexedDB client.

#### Core Performance Strategy

```sql
-- Example: Events table optimized for 1M+ records
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    event_type_id INTEGER REFERENCES event_types(event_type_id),
    
    -- PERFORMANCE: Real columns for 10x faster queries
    priority INTEGER CHECK (priority BETWEEN 1 AND 5),
    budget DECIMAL(10,2),
    location VARCHAR(200),
    due_date TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    
    -- FLEXIBILITY: JSONB for unlimited custom fields
    custom_fields JSONB DEFAULT '{}',
    
    -- Full-text search optimization
    search_vector tsvector,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- Enterprise-grade performance indexes
CREATE INDEX idx_events_user_priority_due ON events(user_id, priority, due_date) 
WHERE deleted_at IS NULL AND status = 'active';

CREATE INDEX idx_events_custom_fields ON events USING GIN (custom_fields) 
WHERE deleted_at IS NULL;

CREATE INDEX idx_events_search ON events USING GIN (search_vector) 
WHERE deleted_at IS NULL;
```

#### Multi-User Security Architecture

```sql
-- Row-level security for multi-tenant collaboration
ALTER TABLE events ENABLE ROW LEVEL SECURITY;

CREATE POLICY events_own_data ON events FOR ALL 
USING (user_id = current_setting('app.current_user_id')::INTEGER);

-- Advanced policies for team collaboration
CREATE POLICY events_team_access ON events FOR SELECT
USING (user_id IN (
    SELECT team_member_id FROM team_members 
    WHERE team_id = current_setting('app.current_team_id')::INTEGER
));
```

#### Advanced Query Capabilities

```sql
-- Real column performance (10-30ms with 1M records)
SELECT * FROM events 
WHERE user_id = $1 
  AND priority >= 4 
  AND due_date BETWEEN $2 AND $3
ORDER BY priority DESC, due_date ASC 
LIMIT 50;

-- JSONB flexibility with GIN index (20-80ms with 1M records)
SELECT * FROM events 
WHERE user_id = $1 
  AND custom_fields @> '{"project": "Alpha", "department": "Engineering"}'
ORDER BY due_date LIMIT 50;

-- Full-text search (50-200ms across unlimited data)
SELECT *, ts_rank(search_vector, plainto_tsquery($2)) as rank
FROM events 
WHERE user_id = $1 
  AND search_vector @@ plainto_tsquery($2)
ORDER BY rank DESC LIMIT 100;

-- Advanced analytics (200ms-2s for complex reports)
SELECT 
  DATE_TRUNC('month', created_at) as month,
  COUNT(*) as total_events,
  COUNT(*) FILTER (WHERE status = 'completed') as completed,
  AVG(priority) as avg_priority,
  SUM(budget) as total_budget
FROM events 
WHERE user_id = $1 AND created_at >= $2
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month;
```

---

## IndexedDB Client Architecture

### Intelligent Caching Strategy

The IndexedDB client maintains a smart subset of the most relevant data for complete offline functionality.

#### Cache Management

```javascript
class IntelligentCache {
  constructor() {
    this.maxRecords = 10000;
    this.cacheStrategy = {
      recent: 2000,        // Recently accessed records
      favorites: 1000,     // User-starred items
      due_soon: 2000,      // Due within 2 weeks
      active_projects: 3000, // Current work context
      offline_queue: 2000   // Pending sync operations
    };
  }
  
  async optimizeCache() {
    // Get most relevant records from server
    const relevantData = await this.server.getRelevantRecords({
      user_id: this.userId,
      strategy: this.cacheStrategy,
      last_sync: this.lastSyncTime
    });
    
    // Replace cache with optimized subset
    await db.transaction('rw', db.events, db.items, async () => {
      await db.events.clear();
      await db.items.clear();
      await db.events.bulkAdd(relevantData.events);
      await db.items.bulkAdd(relevantData.items);
    });
  }
}
```

#### Offline Operation Queue

```javascript
class OfflineQueue {
  async queueOperation(operation, entityType, entityId, data) {
    await db.sync_queue.add({
      sync_id: generateUUID(),
      operation,        // 'CREATE', 'UPDATE', 'DELETE'
      entity_type: entityType,
      entity_id: entityId,
      data: data,
      created_at: new Date(),
      retry_count: 0,
      last_attempt: null,
      status: 'pending'
    });
    
    // Trigger background sync if online
    if (navigator.onLine) {
      this.backgroundSync();
    }
  }
  
  async processQueue() {
    const pendingOps = await db.sync_queue
      .where('status').equals('pending')
      .orderBy('created_at')
      .toArray();
    
    for (const op of pendingOps) {
      try {
        await this.syncToServer(op);
        await db.sync_queue.update(op.sync_id, { status: 'completed' });
      } catch (error) {
        await this.handleSyncError(op, error);
      }
    }
  }
}
```

#### Performance Optimization

```javascript
// Optimized IndexedDB queries for client performance
class ClientQueries {
  // Compound index query (1-5ms)
  async getHighPriorityEvents(userId) {
    return db.events
      .where('[user_id+priority]')
      .between([userId, 4], [userId, 5])
      .and(event => !event.deleted_at)
      .toArray();
  }
  
  // Date range with filters (2-10ms)
  async getDueSoonEvents(userId, days = 7) {
    const maxDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000);
    
    return db.events
      .where('user_id').equals(userId)
      .and(event => event.due_date && event.due_date <= maxDate)
      .and(event => event.status === 'active')
      .toArray();
  }
  
  // Pagination for large result sets (1-5ms)
  async getPaginatedEvents(userId, page = 0, pageSize = 50) {
    return db.events
      .where('user_id').equals(userId)
      .offset(page * pageSize)
      .limit(pageSize)
      .toArray();
  }
}
```

---

## Synchronization Architecture

### Bidirectional Intelligent Sync

The synchronization layer handles seamless data flow between client and server with conflict resolution.

#### Sync Process Flow

```javascript
class SynchronizationEngine {
  constructor() {
    this.conflictResolution = 'server_wins'; // 'client_wins', 'merge', 'manual'
    this.syncInterval = 30000; // 30 seconds
    this.batchSize = 100;
  }
  
  async executeSync() {
    try {
      // Phase 1: Push local changes to server
      await this.pushLocalChanges();
      
      // Phase 2: Pull server updates
      await this.pullServerUpdates();
      
      // Phase 3: Resolve conflicts
      await this.resolveConflicts();
      
      // Phase 4: Optimize local cache
      await this.optimizeCache();
      
      // Phase 5: Update sync metadata
      await this.updateSyncState();
      
    } catch (error) {
      await this.handleSyncError(error);
    }
  }
  
  async pushLocalChanges() {
    const pendingChanges = await db.sync_queue
      .where('status').equals('pending')
      .limit(this.batchSize)
      .toArray();
    
    for (const change of pendingChanges) {
      try {
        const result = await this.api.applyChange({
          operation: change.operation,
          entity_type: change.entity_type,
          entity_id: change.entity_id,
          data: change.data,
          client_timestamp: change.created_at
        });
        
        if (result.success) {
          // Update local record with server response
          await this.updateLocalRecord(change, result.data);
          await db.sync_queue.update(change.sync_id, { 
            status: 'completed',
            server_timestamp: result.timestamp
          });
        } else {
          // Handle conflicts
          await this.handleConflict(change, result);
        }
        
      } catch (error) {
        await this.retryOrFail(change, error);
      }
    }
  }
  
  async pullServerUpdates() {
    const lastSync = await this.getLastSyncTime();
    
    const updates = await this.api.getUpdates({
      user_id: this.userId,
      since: lastSync,
      relevance_filter: this.getCacheRelevanceFilter()
    });
    
    for (const update of updates) {
      await this.applyServerUpdate(update);
    }
  }
  
  async resolveConflicts() {
    const conflicts = await db.sync_conflicts.toArray();
    
    for (const conflict of conflicts) {
      const resolution = await this.resolveConflict(conflict);
      await this.applyResolution(conflict, resolution);
      await db.sync_conflicts.delete(conflict.conflict_id);
    }
  }
}
```

#### Conflict Resolution Strategies

```javascript
class ConflictResolver {
  async detectConflict(localRecord, serverRecord) {
    if (!localRecord || !serverRecord) return null;
    
    const localModified = new Date(localRecord.updated_at);
    const serverModified = new Date(serverRecord.updated_at);
    const lastSync = new Date(this.lastSyncTime);
    
    // Concurrent modification detection
    if (localModified > lastSync && serverModified > lastSync) {
      return {
        type: 'concurrent_modification',
        local_version: localRecord,
        server_version: serverRecord,
        detected_at: new Date(),
        entity_type: localRecord.constructor.name.toLowerCase(),
        entity_id: localRecord.id
      };
    }
    
    return null;
  }
  
  async resolveConflict(conflict) {
    switch (this.conflictResolution) {
      case 'server_wins':
        return {
          action: 'use_server',
          data: conflict.server_version
        };
        
      case 'client_wins':
        return {
          action: 'use_client',
          data: conflict.local_version
        };
        
      case 'merge':
        return {
          action: 'merge',
          data: await this.smartMerge(conflict)
        };
        
      case 'manual':
        return {
          action: 'request_user_input',
          data: conflict
        };
        
      default:
        throw new Error(`Unknown conflict resolution strategy: ${this.conflictResolution}`);
    }
  }
  
  async smartMerge(conflict) {
    const merged = {
      ...conflict.server_version,
      updated_at: new Date(),
      conflict_resolved: true,
      merge_strategy: 'smart_merge'
    };
    
    // Field-specific merge strategies
    if (conflict.local_version.title !== conflict.server_version.title) {
      merged.title = await this.chooseBestTitle(conflict);
    }
    
    if (conflict.local_version.custom_fields) {
      merged.custom_fields = {
        ...conflict.server_version.custom_fields,
        ...conflict.local_version.custom_fields
      };
    }
    
    return merged;
  }
}
```

---

## Application Layer Architecture

### MVVM Pattern Implementation

The application layer uses the Model-View-ViewModel (MVVM) pattern optimized for the hybrid offline-first + server architecture.

#### Enhanced ViewModels for Sync

```javascript
class EventViewModel {
  constructor() {
    this.events = observable([]);
    this.syncStatus = observable('idle'); // 'syncing', 'conflict', 'error', 'idle'
    this.offlineQueue = observable([]);
    this.lastSyncTime = observable(null);
  }
  
  async createEvent(eventData) {
    // Immediately add to local cache
    const localEvent = await EventModel.create(eventData);
    this.events.push(localEvent);
    
    // Queue for server sync
    await this.offlineQueue.add({
      operation: 'CREATE',
      entity_type: 'event',
      data: eventData,
      local_id: localEvent.event_id
    });
    
    // Attempt immediate sync if online
    if (navigator.onLine) {
      await this.syncToServer();
    }
    
    return localEvent;
  }
  
  async syncToServer() {
    this.syncStatus.set('syncing');
    
    try {
      const syncEngine = new SynchronizationEngine();
      await syncEngine.executeSync();
      
      this.syncStatus.set('idle');
      this.lastSyncTime.set(new Date());
      
    } catch (error) {
      this.syncStatus.set('error');
      console.error('Sync failed:', error);
    }
  }
  
  async handleConflict(conflict) {
    this.syncStatus.set('conflict');
    
    // Show conflict resolution UI
    const resolution = await this.showConflictResolutionDialog(conflict);
    
    // Apply resolution
    await this.applyConflictResolution(conflict, resolution);
    
    this.syncStatus.set('idle');
  }
}
```

#### Reactive State Management

```javascript
class StateManager {
  constructor() {
    this.state = reactive({
      user: null,
      workspace: {},
      syncStatus: 'idle',
      offlineMode: false,
      conflictQueue: [],
      notifications: []
    });
    
    // Auto-detect online/offline status
    window.addEventListener('online', () => {
      this.state.offlineMode = false;
      this.triggerSync();
    });
    
    window.addEventListener('offline', () => {
      this.state.offlineMode = true;
    });
  }
  
  async triggerSync() {
    if (!this.state.offlineMode) {
      await Promise.all([
        eventViewModel.syncToServer(),
        itemViewModel.syncToServer(),
        collectionViewModel.syncToServer()
      ]);
    }
  }
}
```

---

## Performance & Scalability

### Hybrid Performance Architecture

The system provides optimal performance at every scale through intelligent architecture decisions.

#### Client Performance (IndexedDB)

```javascript
// Performance metrics for client operations
const clientPerformance = {
  'Local queries (10K cache)': '1-5ms',
  'Compound index queries': '2-10ms', 
  'Full-text search (cached)': '5-20ms',
  'Offline operations': '<1ms (queued)',
  'UI responsiveness': '60fps consistent',
  'Memory usage': '50-150MB total',
  'Cache optimization': 'Auto-cleanup at 12K records'
};

// Example optimized query
async function getHighPriorityDueToday(userId) {
  const today = new Date();
  const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
  
  return db.events
    .where('[user_id+priority+due_date]')
    .between([userId, 4, today], [userId, 5, tomorrow])
    .toArray();
  // Performance: 2-5ms with 10K cached events
}
```

#### Server Performance (PostgreSQL)

```javascript
// Performance metrics for server operations  
const serverPerformance = {
  'Simple queries (1M records)': '10-50ms',
  'JSONB queries with GIN index': '20-100ms',
  'Full-text search': '50-200ms',
  'Complex analytics': '200ms-2s',
  'Concurrent users': '1000+ simultaneous',
  'Data throughput': '10K+ operations/minute',
  'Storage capacity': 'Unlimited (TB+ datasets)'
};

// Example server query optimization
const getEventsWithComplexFilter = `
  SELECT e.*, et.name as event_type_name
  FROM events e
  LEFT JOIN event_types et ON e.event_type_id = et.event_type_id
  WHERE e.user_id = $1
    AND e.priority >= $2
    AND e.due_date BETWEEN $3 AND $4
    AND e.custom_fields @> $5
    AND e.search_vector @@ plainto_tsquery($6)
  ORDER BY e.priority DESC, e.due_date ASC
  LIMIT $7;
`;
// Performance: 25-100ms with 1M+ records
```

#### Scalability Patterns

```javascript
class ScalabilityManager {
  constructor() {
    this.cacheLimits = {
      personal: 10000,      // 10K records
      team: 50000,          // 50K records  
      enterprise: 100000    // 100K records
    };
    
    this.syncStrategies = {
      personal: 'full_sync',
      team: 'relevance_based',
      enterprise: 'priority_based'
    };
  }
  
  async optimizeForScale(userType, dataSize) {
    const cacheLimit = this.cacheLimits[userType];
    const syncStrategy = this.syncStrategies[userType];
    
    if (dataSize > cacheLimit) {
      await this.enableIntelligentCaching(syncStrategy);
      await this.optimizeServerQueries();
      await this.enableBackgroundSync();
    }
  }
  
  async enableIntelligentCaching(strategy) {
    switch (strategy) {
      case 'relevance_based':
        await this.cacheByRelevanceScore();
        break;
      case 'priority_based':
        await this.cacheHighPriorityOnly();
        break;
      case 'full_sync':
      default:
        await this.cacheAllRecentData();
        break;
    }
  }
}
```

---

## Security & Multi-User Architecture

### Row-Level Security Implementation

```sql
-- Enable RLS on all user data tables
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
ALTER TABLE items ENABLE ROW LEVEL SECURITY;
ALTER TABLE collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE tags ENABLE ROW LEVEL SECURITY;

-- Basic user isolation policy
CREATE POLICY user_data_isolation ON events
FOR ALL USING (user_id = current_setting('app.current_user_id')::INTEGER);

-- Team collaboration policies
CREATE POLICY team_read_access ON events
FOR SELECT USING (
  user_id = current_setting('app.current_user_id')::INTEGER
  OR user_id IN (
    SELECT team_member_id FROM team_memberships 
    WHERE team_id = current_setting('app.current_team_id')::INTEGER
    AND member_id = current_setting('app.current_user_id')::INTEGER
  )
);

-- Hierarchical organization access
CREATE POLICY org_access ON events
FOR ALL USING (
  user_id = current_setting('app.current_user_id')::INTEGER
  OR EXISTS (
    SELECT 1 FROM organization_access oa
    WHERE oa.user_id = current_setting('app.current_user_id')::INTEGER
    AND oa.can_access_user_id = events.user_id
  )
);
```

### Authentication & Authorization

```javascript
class SecurityManager {
  constructor() {
    this.tokenStorage = new SecureTokenStorage();
    this.permissions = new PermissionManager();
  }
  
  async authenticateUser(credentials) {
    const response = await this.api.authenticate(credentials);
    
    if (response.success) {
      await this.tokenStorage.store(response.token);
      await this.permissions.loadUserPermissions(response.user);
      
      // Set database context for RLS
      await this.setDatabaseContext(response.user);
      
      return response.user;
    }
    
    throw new Error('Authentication failed');
  }
  
  async setDatabaseContext(user) {
    // Set PostgreSQL session variables for RLS
    await this.db.query('SET app.current_user_id = $1', [user.user_id]);
    
    if (user.current_team_id) {
      await this.db.query('SET app.current_team_id = $1', [user.current_team_id]);
    }
    
    if (user.organization_id) {
      await this.db.query('SET app.current_org_id = $1', [user.organization_id]);
    }
  }
  
  async enforcePermissions(operation, entityType, entityData) {
    const hasPermission = await this.permissions.check(
      operation, 
      entityType, 
      entityData
    );
    
    if (!hasPermission) {
      throw new Error(`Permission denied: ${operation} on ${entityType}`);
    }
  }
}
```

---

## Development Architecture

### Hybrid Development Environment

```javascript
// Development configuration
const developmentConfig = {
  client: {
    database: 'IndexedDB (local development)',
    server: 'Live-server on localhost:3000',
    sync: 'Mock server responses for offline development',
    debugging: 'Console logging + IndexedDB inspector'
  },
  
  server: {
    database: 'PostgreSQL (Docker container)',
    api: 'Express.js on localhost:3001', 
    authentication: 'JWT with development keys',
    debugging: 'PostgreSQL query logging + API request logging'
  },
  
  integration: {
    sync_testing: 'Automated conflict simulation',
    performance: 'Client + server benchmark suites',
    e2e: 'Full offline-to-online workflows'
  }
};
```

### Testing Strategy

```javascript
class TestingFramework {
  async runFullTestSuite() {
    // Client-only tests (offline development)
    await this.runClientTests();
    
    // Server-only tests (API + database)
    await this.runServerTests();
    
    // Integration tests (sync functionality)
    await this.runSyncTests();
    
    // Performance tests (both layers)
    await this.runPerformanceTests();
    
    // E2E tests (complete workflows)
    await this.runE2ETests();
  }
  
  async runSyncTests() {
    // Test conflict scenarios
    await this.testConcurrentModification();
    await this.testOfflineOperations();
    await this.testConflictResolution();
    await this.testDataConsistency();
    
    // Test performance under load
    await this.testLargeDatasetSync();
    await this.testMultiUserConflicts();
  }
}
```

---

## Deployment Architecture

### Production Infrastructure

```yaml
# docker-compose.production.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: organizational_ecosystem
      POSTGRES_USER: app_user
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    
  api_server:
    build: ./server
    environment:
      DATABASE_URL: postgres://app_user:secure_password@postgres:5432/organizational_ecosystem
      JWT_SECRET: production_jwt_secret
      NODE_ENV: production
    ports:
      - "3001:3001"
    depends_on:
      - postgres
    
  web_server:
    build: ./client
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./ssl:/etc/ssl
    environment:
      API_URL: https://api.yourdomain.com
```

### Scaling Architecture

```javascript
const scalingStrategy = {
  horizontal_scaling: {
    load_balancer: 'Nginx with multiple API server instances',
    database: 'PostgreSQL read replicas for scaling reads',
    caching: 'Redis for session and query caching',
    cdn: 'CloudFlare for static asset delivery'
  },
  
  vertical_scaling: {
    database_optimization: 'Connection pooling + query optimization',
    server_resources: 'Auto-scaling based on CPU/memory usage',
    intelligent_caching: 'Dynamic cache sizing based on user count'
  },
  
  global_distribution: {
    multi_region: 'Regional PostgreSQL instances',
    edge_caching: 'CDN with intelligent cache invalidation',
    data_locality: 'User data stored in nearest region'
  }
};
```

---

## Future Platform Architecture

### Platform Evolution Strategy

```javascript
const platformRoadmap = {
  'v4.1_server_foundation': {
    timeline: 'Q2 2024',
    features: [
      'PostgreSQL server with identical schema',
      'RESTful API with authentication',
      'Bidirectional synchronization',
      'Basic multi-user support'
    ]
  },
  
  'v4.2_enterprise_features': {
    timeline: 'Q3 2024', 
    features: [
      'Advanced collaboration tools',
      'Real-time updates via WebSocket',
      'Enterprise security & compliance',
      'Advanced analytics & reporting'
    ]
  },
  
  'v5.0_platform_scale': {
    timeline: 'Q4 2024',
    features: [
      'Multi-tenant SaaS architecture',
      'Global deployment with edge caching',
      'AI integration for smart suggestions',
      'Plugin marketplace & ecosystem'
    ]
  }
};
```

---

## Conclusion

This hybrid system architecture provides the foundation for a **radically simple, infinitely extensible** organizational ecosystem that scales from personal productivity (1K records) to enterprise collaboration (1M+ records) while maintaining **complete offline functionality** and **sub-second performance**.

### Architectural Benefits Summary

1. **Hybrid Offline-First**: Complete functionality without server + unlimited server scale
2. **Identical Schemas**: Seamless sync between PostgreSQL and IndexedDB  
3. **Performance Optimized**: Real columns + JSONB for 10x query improvement
4. **Enterprise Ready**: Row-level security, multi-user collaboration, conflict resolution
5. **Future-Proof**: Architecture supports AI integration, global scale, and platform evolution

The **18-table design** achieves what traditional systems need 50+ tables to accomplish, while the **PostgreSQL + JSONB** approach provides both performance and flexibility for unlimited customization.

**Result: A productivity platform that works instantly offline and scales infinitely online.**

**Due:** {{event.due_date | date('MMM DD, YYYY')}}
**Priority:** {{event.custom_fields.priority | priority_label}}
**Location:** {{event.custom_fields.location | default("TBD")}}

## Description
{{event.description | default("No description provided")}}

## Time Remaining
{{event.time_until_due}}
```

---

## Simplified Relationship System

### Universal Linking (No Separate Tables)
The simplified relationship system uses the existing **links table** with string-based relationship types, eliminating the need for a separate relationship_types table while maintaining full functionality.

### Simplified Architecture
```sql
-- Existing links table handles all relationships
CREATE TABLE links (
    link_id SERIAL PRIMARY KEY,
    from_type VARCHAR(10) NOT NULL,
    from_id INTEGER NOT NULL,
    to_type VARCHAR(10) NOT NULL,
    to_id INTEGER NOT NULL,
    relationship_type VARCHAR(50) NOT NULL,  -- Simple string values
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Standard relationship vocabulary (no table needed)
-- 'depends_on', 'part_of', 'related_to', 'follows', 'requires', 'assigned_to'
```

### Usage Examples
```javascript
// Create relationships with simple strings
await Link.create({
    from_type: 'event', from_id: 123,
    to_type: 'event', to_id: 456,
    relationship_type: 'depends_on'
});

// Query relationships  
const dependencies = await Link.findByRelationship('event', 123, 'depends_on');
```

**Benefits**: Radical simplicity, no additional tables, infinite relationship types through configuration.

---

## Application Architecture

### MVVM Pattern Implementation

The application follows a strict Model-View-ViewModel (MVVM) architecture that separates concerns and enables sophisticated UI patterns.

#### Models (Data Access Layer)
```javascript
class EventModel {
    static async findByCollection(collectionId) {
        const collection = await db.collections.get(collectionId);
        return this.executeQuery(collection.filter_config);
    }
    
    static async findWithRelationships(eventId, relationshipType) {
        return db.links
            .where({from_type: 'event', from_id: eventId, relationship_type})
            .toArray();
    }
}
```

#### ViewModels (Business Logic Layer)
```javascript
class CollectionViewModel {
    constructor(collectionId) {
        this.collectionId = collectionId;
        this.filters = new ObservableFilters();
        this.results = new ObservableResults();
    }
    
    async applyFilter(filterConfig) {
        const cql = new CollectionQueryLanguage(filterConfig);
        this.results.update(await cql.execute());
    }
    
    async addToWorkspace(eventId) {
        await WorkspaceModel.pin(eventId);
        this.notifyWorkspaceUpdate();
    }
}
```

#### Views (UI Components)
```javascript
class CollectionView {
    constructor(viewModel) {
        this.viewModel = viewModel;
        this.bindEvents();
        this.observeChanges();
    }
    
    render() {
        return `
            <div class="collection-view">
                ${this.renderFilters()}
                ${this.renderResults()}
                ${this.renderActions()}
            </div>
        `;
    }
}
```

---

## UI Integration Architecture

### Workspace-Centric Design
The UI architecture centers around a persistent workspace that maintains user context across all application interactions.

#### Enhanced User Preferences
```sql
ALTER TABLE users ADD COLUMN workspace_config JSONB DEFAULT '{}';
ALTER TABLE users ADD COLUMN view_preferences JSONB DEFAULT '{}';
ALTER TABLE users ADD COLUMN onboarding_state JSONB DEFAULT '{}';

-- Example workspace_config
{
  "pinned_events": [123, 456, 789],
  "active_collections": [1, 3, 7],
  "workspace_layout": "split-view",
  "default_view_mode": "list"
}

-- Example view_preferences  
{
  "events_view": {
    "columns": ["title", "due_date", "priority", "tags"],
    "sort_by": "due_date",
    "sort_order": "asc",
    "page_size": 25
  },
  "collections_view": {
    "display_mode": "grid",
    "show_counts": true
  }
}

-- Example onboarding_state
{
  "first_event_created": true,
  "first_collection_created": false,
  "views_tab_unlocked": true,
  "templates_introduced": false
}
```

#### Progressive Disclosure Logic
```javascript
class OnboardingManager {
    static shouldShowFeature(featureName) {
        const state = UserModel.getOnboardingState();
        return OnboardingRules[featureName](state);
    }
    
    static unlockFeature(featureName) {
        UserModel.updateOnboardingState({
            [featureName]: true
        });
        UINotifications.showFeatureUnlocked(featureName);
    }
}

const OnboardingRules = {
    collections_tab: (state) => state.first_event_created,
    templates_tab: (state) => state.first_collection_created,
    graph_view: (state) => state.collections_tab && state.events_count > 10
};
```

### Tabbed Navigation System
- **EVENTS** - Primary workspace with filtering, creation, and management
- **VAULT** - Collections, saved filters, and organizational structures  
- **TEMPLATES** - Content templates, automation rules, and customization

---

## File Synchronization System

### Bidirectional Markdown Sync
The file synchronization system enables seamless integration between structured database records and unstructured markdown files.

#### Entity Files Table
```sql
CREATE TABLE entity_files (
    id SERIAL PRIMARY KEY,
    entity_type VARCHAR(10) NOT NULL CHECK (entity_type IN ('event', 'item')),
    entity_id INTEGER NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    last_markdown_sync TIMESTAMP,
    last_db_sync TIMESTAMP,
    sync_conflicts JSONB DEFAULT '{}',
    user_id INTEGER NOT NULL REFERENCES users(user_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_files_lookup ON entity_files(entity_type, entity_id);
CREATE INDEX idx_entity_files_user ON entity_files(user_id);
CREATE INDEX idx_entity_files_path ON entity_files(file_path);
```

#### Sync Architecture
```javascript
class FileSync {
    static async syncEntityToFile(entityType, entityId) {
        const entity = await this.getEntity(entityType, entityId);
        const template = await this.getTemplate(entity.type);
        const markdown = template.render(entity);
        
        await this.writeMarkdownFile(entity.file_path, markdown);
        await this.updateSyncTimestamp(entityType, entityId, 'last_db_sync');
    }
    
    static async syncFileToEntity(filePath) {
        const markdown = await this.readMarkdownFile(filePath);
        const entity = await this.parseMarkdown(markdown);
        
        await this.updateEntity(entity);
        await this.updateSyncTimestamp(entity.type, entity.id, 'last_markdown_sync');
    }
    
    static async detectConflicts() {
        return db.entity_files
            .where('last_markdown_sync')
            .below(db.entity_files.last_db_sync)
            .toArray();
    }
}
```

#### Conflict Resolution
- **Timestamp Comparison** - Detect when file and database are out of sync
- **Merge Strategies** - User-configurable conflict resolution rules
- **Version History** - Maintain change history for rollback capabilities
- **User Notification** - Alert users to conflicts with resolution options

---

## Performance & Scalability

### Indexing Strategy
```sql
-- Core performance indexes
CREATE INDEX idx_events_user_type ON events(user_id, event_type_id);
CREATE INDEX idx_events_due_date ON events(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX idx_events_custom_fields ON events USING GIN (custom_fields);

-- Polymorphic relationship performance
CREATE INDEX idx_tag_assignments_lookup ON tag_assignments(taggable_type, taggable_id, tag_id);
CREATE INDEX idx_links_lookup ON links(from_type, from_id, relationship_type_id);

-- Collection query optimization
CREATE INDEX idx_events_status_priority ON events(status, (custom_fields->>'priority'));
CREATE INDEX idx_items_category ON items(item_type_id, (custom_fields->>'category'));

-- Field library performance
CREATE INDEX idx_field_library_category ON field_library(category, is_system) WHERE deleted_at IS NULL;
CREATE INDEX idx_event_type_fields_type ON event_type_fields(event_type_id, sequence_order);
```

### Query Optimization Patterns
```javascript
// Efficient collection filtering
class CollectionQueryOptimizer {
    static optimizeQuery(filterConfig) {
        // Use compound indexes for common filter patterns
        if (filterConfig.hasUserAndType()) {
            return this.useUserTypeIndex(filterConfig);
        }
        
        // Leverage JSONB GIN indexes for custom fields
        if (filterConfig.hasCustomFieldFilters()) {
            return this.useJsonbIndex(filterConfig);
        }
        
        return this.buildStandardQuery(filterConfig);
    }
}
```

### Memory Management
- **Lazy Loading** - Load entity relationships on demand
- **Result Pagination** - Limit query results to prevent memory bloat
- **Cache Invalidation** - Smart cache invalidation based on entity relationships
- **IndexedDB Optimization** - Efficient use of browser storage APIs

---

## Security & Privacy

### Data Protection
- **Client-Side Encryption** - Sensitive data encrypted before storage
- **Session Management** - Secure session handling with automatic timeout
- **Audit Logging** - Comprehensive audit trail for all operations
- **Data Isolation** - User data strictly isolated in multi-tenant scenarios

### Privacy by Design
```javascript
class PrivacyManager {
    static async anonymizeUser(userId) {
        // Remove personally identifiable information
        await db.users.update(userId, {
            email: '[ANONYMIZED]',
            name: '[ANONYMIZED]',
            metadata: {}
        });
        
        // Maintain data relationships for analytics
        await this.updateAuditLogs(userId, 'USER_ANONYMIZED');
    }
    
    static async exportUserData(userId) {
        // Complete data export for GDPR compliance
        return {
            user: await db.users.get(userId),
            events: await db.events.where('user_id').equals(userId).toArray(),
            items: await db.items.where('user_id').equals(userId).toArray(),
            // ... all related data
        };
    }
}
```

---

## Development Strategy

### Implementation Phases

#### Phase 1: Core Foundation ✅ (Complete)
- [x] Database schema with 15 tables implemented
- [x] MVVM architecture with Models and ViewModels
- [x] Basic event and item management
- [x] Tagging and collection systems
- [x] Quick capture functionality

#### Phase 2: Enhanced Schema 🚀 (Next)
- [ ] Field Library System implementation
- [ ] Template Engine development
- [ ] Relationship Types system
- [ ] Enhanced user preferences
- [ ] File synchronization foundation

#### Phase 3: UI Integration 🔧 (Following)
- [ ] Tabbed navigation interface
- [ ] Collection dashboards
- [ ] Workspace management
- [ ] Progressive disclosure logic
- [ ] Template-driven content generation

#### Phase 4: Advanced Features 📋 (Future)
- [ ] Graph view implementation
- [ ] Advanced automation rules
- [ ] Collaboration features
- [ ] Mobile responsiveness
- [ ] Performance optimization

### Migration Strategy

#### Database Evolution
```javascript
class MigrationManager {
    static migrations = [
        {
            version: '2.0',
            description: 'Add Field Library System',
            up: async () => {
                await this.createTable('validation_types', validationTypesSchema);
                await this.createTable('field_library', fieldLibrarySchema);
                await this.createTable('event_type_fields', eventTypeFieldsSchema);
                await this.createTable('item_type_fields', itemTypeFieldsSchema);
            }
        },
        {
            version: '2.1', 
            description: 'Add Template Engine',
            up: async () => {
                await this.createTable('template_variables', templateVariablesSchema);
                await this.createTable('template_filters', templateFiltersSchema);
            }
        }
    ];
    
    static async runMigrations() {
        const currentVersion = await this.getCurrentSchemaVersion();
        const pendingMigrations = this.migrations.filter(m => m.version > currentVersion);
        
        for (const migration of pendingMigrations) {
            await migration.up();
            await this.updateSchemaVersion(migration.version);
        }
    }
}
```

---

## Future Roadmap

### Collaboration Features
- **Shared Collections** - Multi-user collections with permission management
- **Real-time Sync** - Live collaboration on events and files
- **Team Workspaces** - Organizational-level data management
- **Permission System** - Granular access control for shared resources

### Advanced Intelligence
- **Smart Suggestions** - AI-powered event type recommendations based on patterns
- **Predictive Automation** - Machine learning-driven routine optimization
- **Analytics Dashboard** - Usage patterns and productivity insights
- **Natural Language Processing** - Smart parsing of quick capture input

### Platform Expansion
- **Mobile Applications** - Native iOS/Android apps with offline sync
- **Browser Extensions** - Web clipper and quick capture tools
- **API Platform** - Third-party integrations and developer tools
- **Desktop Integration** - File system integration and native notifications

### Advanced Customization
- **Custom Field Types** - User-defined validation and UI components
- **Workflow Automation** - Complex business logic automation
- **Custom Views** - User-designed interface layouts
- **Plugin Architecture** - Extensible functionality through plugins

---

## Conclusion

This system architecture successfully balances the core principles of **clean, simple, and pure data structures** with the sophistication required for a comprehensive organizational ecosystem. The configuration-driven approach enables infinite user customization while maintaining architectural integrity.

**Key Architectural Wins:**

1. **Radical Simplicity** - 18 tables achieving infinite extensibility (vs 26 planned)
2. **Performance Optimized** - Real columns + strategic JSONB for sub-second queries
3. **UI-Integrated** - Database designed specifically to support sophisticated user interfaces
4. **DRY Architecture** - Single polymorphic systems eliminate duplication
5. **Future-Proof** - Architecture supports collaboration, AI, and platform expansion

The simplified schema with **Universal Field System**, **Embedded Templates**, and **File Synchronization** provides a robust foundation for building a next-generation productivity application that can scale from personal use to enterprise deployment without fundamental architectural changes.

**Final Schema Statistics:**
- **18 Production Tables** - Radically simple organizational ecosystem
- **30% Complexity Reduction** - Simplified from 26 to 18 tables while maintaining all functionality
- **10x Performance Boost** - Real columns for common fields vs pure JSONB approach
- **2-Table Field System** - Universal field definitions + polymorphic mapping
- **Embedded Templates** - No separate template engine tables needed

This architecture achieves the perfect balance: **maximum power through minimum complexity**. Users can create unlimited organizational modules through pure configuration, with sub-second query performance and a radically simple underlying architecture that maintains your core philosophies of clean, simple, pure data structures.


# Feature Matrix v4.0
**Organizational Ecosystem Application - Complete Feature Specification**

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Core Architecture](#core-architecture)
3. [Data Model](#data-model)
4. [Universal Systems](#universal-systems)
5. [User Experience Features](#user-experience-features)
6. [Advanced Features](#advanced-features)
7. [Performance & Technical Features](#performance--technical-features)
8. [UI Integration Features](#ui-integration-features)
9. [File Synchronization](#file-synchronization)
10. [Security & Audit Features](#security--audit-features)
11. [Extensibility Features](#extensibility-features)
12. [Implementation Roadmap](#implementation-roadmap)

---

## Executive Summary

The Organizational Ecosystem Application is a **radically simple, infinitely extensible** productivity platform built on the foundational principle that everything in digital organization is either an **Event** (actions/verbs) or an **Item** (assets/nouns). Through this elegant abstraction and a simplified **18-table database schema**, users can create unlimited organizational modules while maintaining sub-second performance and architectural simplicity.

### Core Value Propositions

1. **Infinite Customization Through Configuration** - Create unlimited event types, item types, and workflows without code changes
2. **Radical Simplicity** - 18-table schema achieving what traditional systems need 50+ tables to accomplish
3. **Performance Optimized** - Real columns for common fields + strategic JSONB for 10x query performance
4. **Offline-First** - Complete functionality without network dependency, syncs when available
5. **Universal Integration** - Every system works with every other system through polymorphic design

---

## Core Architecture

### Foundational Principles

#### Two-Type Purity
**Everything is either an Event or an Item. Period.**

| **Events (Verbs/Actions)** | **Items (Nouns/Assets)** |
|---------------------------|-------------------------|
| ✅ Tasks, projects, meetings | ✅ Physical objects, tools |
| ✅ Notes, journal entries | ✅ Digital files, accounts |
| ✅ Transactions, purchases | ✅ Consumables, inventory |
| ✅ Routines, habits | ✅ Collections, references |
| ✅ Goals, milestones | ✅ People, contacts |

#### Hybrid Architecture: Offline-First + Server Scale

```
Client Layer (IndexedDB):
- Intelligent cache of 10K most relevant records
- Complete offline functionality 
- Sub-second local queries (1-10ms)
- Modification queue for offline changes

Server Layer (PostgreSQL + JSONB):
- Unlimited record storage (1M+ records)
- Enterprise-grade performance (10-100ms queries)
- Real columns for common fields + JSONB flexibility
- Advanced search, analytics, and collaboration

Sync Layer:
- Bidirectional intelligent synchronization
- Conflict resolution with user preferences
- Real-time updates via WebSocket
- Background sync optimization
```

#### Performance Strategy: Best of Both Worlds

```sql
-- PostgreSQL Server Schema (Primary Storage)
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    event_type_id INTEGER,
    title VARCHAR(255) NOT NULL,
    
    -- Real Columns: 10x faster queries, perfect for common filters
    priority INTEGER CHECK (priority BETWEEN 1 AND 5),
    budget DECIMAL(10,2),
    location VARCHAR(200),
    due_date TIMESTAMP,
    completed_date TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    
    -- JSONB: Infinite flexibility with GIN index performance
    custom_fields JSONB DEFAULT '{}',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Performance Indexes
CREATE INDEX idx_events_user_priority_due ON events(user_id, priority, due_date);
CREATE INDEX idx_events_custom_fields ON events USING GIN (custom_fields);

-- IndexedDB Client Schema (Mirrors Server for Seamless Sync)
// Identical structure for offline-first development and sync
```

**Performance Results:**
- ✅ **Client Queries**: 1-10ms (local IndexedDB cache)
- ✅ **Server Queries**: 10-100ms (PostgreSQL with 1M+ records)
- ✅ **Real Column Filters**: 15ms (priority, due_date, location)
- ✅ **JSONB Queries**: 40ms (complex custom field filtering)
- ✅ **Full-Text Search**: 100ms (unlimited dataset)
- ✅ **Offline Operations**: Instant (queue for sync)

---

## Data Model

### Core Entities

#### Events Table (Performance Optimized)
```sql
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    event_type_id INTEGER,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Performance: Real columns for common fields (10x faster)
    priority INTEGER CHECK (priority BETWEEN 1 AND 5),
    budget DECIMAL(10,2),
    location VARCHAR(200),
    due_date TIMESTAMP,
    completed_date TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    
    -- Only truly custom fields in JSONB
    custom_fields JSONB DEFAULT '{}',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Features Enabled:**
- ✅ Universal task/project/note/transaction management
- ✅ Sub-second queries on priority, budget, location, due dates
- ✅ Infinite custom fields per event type
- ✅ Full audit trail and soft delete recovery
- ✅ Polymorphic tagging and linking

#### Items Table (Performance Optimized)
```sql
CREATE TABLE items (
    item_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    item_type_id INTEGER,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Performance: Real columns for common fields
    quantity DECIMAL(10,3) DEFAULT 1,
    unit VARCHAR(50),
    value DECIMAL(10,2),
    location VARCHAR(200),
    status VARCHAR(20) DEFAULT 'active',
    
    -- Only truly custom fields in JSONB
    custom_fields JSONB DEFAULT '{}',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Features Enabled:**
- ✅ Inventory management with quantity tracking
- ✅ Asset valuation and location tracking
- ✅ Infinite custom fields per item type
- ✅ Universal tagging and relationship system
- ✅ Integration with events (tasks can require items)

### Type System

#### Event Types (With Embedded Templates)
```sql
CREATE TABLE event_types (
    event_type_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    color VARCHAR(7) DEFAULT '#3498db',
    icon VARCHAR(50),
    
    -- Embedded Template System (No separate tables needed)
    content_template TEXT,
    available_variables JSONB DEFAULT '[]',
    
    -- Behavior Configuration
    default_duration_minutes INTEGER,
    requires_completion BOOLEAN DEFAULT false,
    
    is_system BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Features Enabled:**
- ✅ Users create unlimited event types (Workout, Meeting, Project, Purchase, etc.)
- ✅ Each type has custom fields, colors, icons, behaviors
- ✅ Embedded content templates with variable substitution
- ✅ System-provided types (Task, Note, Transaction) + user-created types
- ✅ Auto-generation of forms based on type configuration

#### Item Types
```sql
CREATE TABLE item_types (
    item_type_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    color VARCHAR(7) DEFAULT '#2ecc71',
    icon VARCHAR(50),
    
    -- Configuration
    tracks_quantity BOOLEAN DEFAULT true,
    tracks_value BOOLEAN DEFAULT false,
    default_unit VARCHAR(50),
    
    is_system BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Features Enabled:**
- ✅ Users create unlimited item types (Equipment, Books, Groceries, Accounts, etc.)
- ✅ Configurable quantity and value tracking per type
- ✅ Category-based organization and filtering
- ✅ Custom colors and icons for visual organization
- ✅ Integration with events (tasks can require specific item types)

### Universal Field System (Simplified)

#### Field Definitions (Single Catalog)
```sql
CREATE TABLE field_definitions (
    field_id SERIAL PRIMARY KEY,
    field_name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(200) NOT NULL,
    field_type VARCHAR(50) NOT NULL,  -- 'text', 'number', 'date', 'select', 'currency'
    validation_schema JSONB NOT NULL,
    ui_config JSONB DEFAULT '{}',
    category VARCHAR(50) NOT NULL,
    is_system BOOLEAN DEFAULT false
);
```

**System-Provided Fields:**
- **Temporal**: due_date, start_date, end_date, reminder_time
- **Organizational**: priority, status, category, project_code  
- **Financial**: budget, cost, currency, tax_rate
- **Spatial**: location, address, room, building
- **Quantitative**: quantity, units, weight, dimensions
- **Relational**: assigned_to, contact_info, phone, email
- **Descriptive**: notes, instructions, summary, tags
- **Custom**: Any user-defined fields with validation

#### Entity Fields (Polymorphic Mapping)
```sql
CREATE TABLE entity_fields (
    entity_type VARCHAR(10) NOT NULL,  -- 'event_type' or 'item_type'
    entity_id INTEGER NOT NULL,
    field_id INTEGER NOT NULL,
    display_name VARCHAR(200),
    is_required BOOLEAN DEFAULT false,
    default_value JSONB,
    sequence_order INTEGER NOT NULL,
    PRIMARY KEY (entity_type, entity_id, field_id)
);
```

**Features Enabled:**
- ✅ Users pick fields from library when creating types
- ✅ Rename fields per type ("due_date" → "Workout Time")
- ✅ Set required/optional status per field per type
- ✅ Default values and custom validation per usage
- ✅ Auto-generated forms with proper UI components
- ✅ Consistent validation across all instances

---

## Universal Systems

### Tagging System (Flat Network)

#### Tags
```sql
CREATE TABLE tags (
    tag_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    color VARCHAR(7) DEFAULT '#95a5a6',
    description TEXT,
    UNIQUE(user_id, name)
);
```

#### Tag Assignments (Polymorphic)
```sql
CREATE TABLE tag_assignments (
    tag_assignment_id SERIAL PRIMARY KEY,
    tag_id INTEGER NOT NULL,
    taggable_type VARCHAR(10) NOT NULL,  -- 'event' or 'item'
    taggable_id INTEGER NOT NULL,
    UNIQUE(tag_id, taggable_type, taggable_id)
);
```

**Features Enabled:**
- ✅ **Flat Network Design**: No hierarchical folders, just tags
- ✅ **Cross-Context Tagging**: Same tag can apply to events AND items
- ✅ **Dynamic Organization**: Collections automatically gather tagged content
- ✅ **Visual Organization**: Color-coded tags for instant recognition
- ✅ **Hashtag Integration**: Quick capture with #tag extraction
- ✅ **Global Search**: Find anything by tag across all content

### Linking System (Universal Relationships)

#### Links (Simplified)
```sql
CREATE TABLE links (
    link_id SERIAL PRIMARY KEY,
    from_type VARCHAR(10) NOT NULL,  -- 'event' or 'item'
    from_id INTEGER NOT NULL,
    to_type VARCHAR(10) NOT NULL,    -- 'event' or 'item'
    to_id INTEGER NOT NULL,
    relationship_type VARCHAR(50) NOT NULL,  -- Simple string vocabulary
    notes TEXT,
    UNIQUE(from_type, from_id, to_type, to_id, relationship_type)
);
```

**Standard Relationship Vocabulary:**
- `depends_on` - Task A depends on Task B completion
- `part_of` - Subtask is part of larger project
- `requires` - Meeting requires conference room
- `related_to` - General association between entities
- `follows` - Sequential workflow relationships
- `assigned_to` - Task assigned to person/item
- `located_at` - Event happens at specific location

**Features Enabled:**
- ✅ **Universal Connections**: Link any entity to any other entity
- ✅ **Dependency Tracking**: Build complex project hierarchies
- ✅ **Resource Management**: Link events to required items
- ✅ **Workflow Automation**: Sequential task dependencies
- ✅ **Graph Visualization**: Visual relationship mapping
- ✅ **Smart Suggestions**: System suggests related content

### Collection System (Advanced Filtering)

#### Collections (Saved Filters)
```sql
CREATE TABLE collections (
    collection_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Collection Query Language (CQL)
    filter_config JSONB NOT NULL,
    view_config JSONB DEFAULT '{}',
    
    color VARCHAR(7) DEFAULT '#9b59b6',
    icon VARCHAR(50),
    is_system BOOLEAN DEFAULT false
);
```

**Collection Query Language (CQL) Examples:**
```json
{
  "entity_type": "event",
  "conditions": {
    "operator": "AND",
    "rules": [
      {"field": "priority", "operator": ">=", "value": 4},
      {"field": "due_date", "operator": "date_between", "value": ["2024-01-01", "2024-12-31"]},
      {"field": "tags", "operator": "contains_any", "value": ["work", "urgent"]},
      {"field": "custom_fields.project_code", "operator": "equals", "value": "PROJ-2024"}
    ]
  },
  "sort": [
    {"field": "priority", "direction": "desc"},
    {"field": "due_date", "direction": "asc"}
  ]
}
```

**System Collections:**
- **Today** - Events due today
- **This Week** - Events due within 7 days
- **High Priority** - Priority 4-5 events
- **Overdue** - Past due events not completed
- **Recent** - Recently created/modified items
- **Favorites** - User-starred content

**Features Enabled:**
- ✅ **Dynamic Views**: Collections automatically update as data changes
- ✅ **Complex Filtering**: Boolean logic with multiple conditions
- ✅ **Cross-Type Collections**: Include both events and items
- ✅ **Custom Sorting**: Multiple sort criteria
- ✅ **Saved Searches**: Reusable complex queries
- ✅ **Dashboard Creation**: Multiple collections as dashboard widgets

---

## User Experience Features

### Quick Capture System

#### Unified Input Interface
```javascript
// Example quick capture inputs and their parsing:

"Call John about project #work #urgent due:tomorrow"
→ Event: title="Call John about project", tags=["work", "urgent"], due_date=tomorrow

"Buy groceries milk bread eggs #shopping $25"
→ Event: title="Buy groceries", description="milk bread eggs", tags=["shopping"], budget=25

"MacBook Pro 2023 $2499 #tech #equipment"
→ Item: name="MacBook Pro 2023", value=2499, tags=["tech", "equipment"]

"Meeting with team @conference-room due:friday 2pm #work"
→ Event: title="Meeting with team", location="conference-room", due_date=friday 2pm, tags=["work"]
```

**Features Enabled:**
- ✅ **Natural Language Processing**: Intelligent parsing of user input
- ✅ **Smart Defaults**: System infers event vs item based on context
- ✅ **Hashtag Extraction**: Automatic tag creation and assignment
- ✅ **Date/Time Parsing**: Natural language date recognition
- ✅ **Location Recognition**: @location syntax for venues
- ✅ **Currency Detection**: Automatic budget/value extraction
- ✅ **Bulk Creation**: Multiple items/events from single input

### Event Management

#### Event Lifecycle
```javascript
// Event states and transitions
STATES: ['active', 'completed', 'cancelled', 'deferred', 'in_progress']

// Automatic behaviors based on event_type configuration
- Auto-scheduling based on duration and availability
- Dependency checking before marking complete
- Resource availability validation
- Template-based content generation
- Progress tracking and metrics
```

**Features Enabled:**
- ✅ **Flexible Scheduling**: Time-based and dependency-based scheduling
- ✅ **Progress Tracking**: Completion percentages and milestone tracking
- ✅ **Dependency Management**: Cannot complete if dependencies are unmet
- ✅ **Resource Integration**: Automatic checking of required items
- ✅ **Template Generation**: Auto-populate descriptions and fields
- ✅ **Batch Operations**: Update multiple events simultaneously

### Item Management

#### Inventory Features
```javascript
// Automatic inventory behaviors
- Quantity tracking with consumption automation
- Value tracking with depreciation calculation  
- Location tracking with movement history
- Usage logging with frequency analysis
- Reorder alerts based on consumption patterns
- Integration with purchase events
```

**Features Enabled:**
- ✅ **Quantity Tracking**: Real-time inventory levels
- ✅ **Consumption Automation**: Events can consume item quantities
- ✅ **Reorder Management**: Automatic low-stock alerts
- ✅ **Value Tracking**: Asset depreciation and total value calculation
- ✅ **Location Management**: Track where items are stored/used
- ✅ **Usage Analytics**: Frequency and pattern analysis

### List Management (Hybrid System)

#### List Items (Flexible Container)
```sql
CREATE TABLE list_items (
    list_item_id SERIAL PRIMARY KEY,
    list_id INTEGER NOT NULL,
    
    -- Hybrid: Either text or linked entity
    text_content VARCHAR(500),      -- "Buy milk" (simple text)
    linked_type VARCHAR(10),        -- 'event' or 'item'
    linked_id INTEGER,              -- References actual event/item
    
    sequence_order INTEGER NOT NULL,
    checked BOOLEAN DEFAULT false,
    notes TEXT
);
```

**Features Enabled:**
- ✅ **Hybrid Lists**: Mix simple text items with full events/items
- ✅ **Friction-Free Input**: Users can add simple text without full event creation
- ✅ **Upgrade Path**: Convert text items to full events/items when needed
- ✅ **Automatic Sync**: Checking linked events marks them complete
- ✅ **Bulk Operations**: Move items between lists, bulk check/uncheck
- ✅ **Smart Suggestions**: System suggests converting text to events/items

---

## Advanced Features

### Routine System (Automation)

#### Routines (Event Generators)
```sql
CREATE TABLE routines (
    routine_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    title VARCHAR(255) NOT NULL,
    event_type_id INTEGER,
    
    -- Flexible scheduling patterns
    schedule_pattern JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    
    -- Auto-generated event template
    default_title_template VARCHAR(255),
    default_description TEXT,
    default_custom_fields JSONB DEFAULT '{}'
);
```

**Schedule Pattern Examples:**
```json
// Daily routine
{"type": "daily", "time": "08:00", "days": ["monday", "tuesday", "wednesday", "thursday", "friday"]}

// Weekly routine
{"type": "weekly", "day": "sunday", "time": "19:00", "interval": 1}

// Monthly routine
{"type": "monthly", "day": 15, "time": "10:00", "interval": 1}

// Custom pattern
{"type": "custom", "dates": ["2024-01-15", "2024-02-15", "2024-03-15"], "time": "14:00"}
```

**Features Enabled:**
- ✅ **Automated Event Creation**: Generate events based on schedule patterns
- ✅ **Template-Based Generation**: Use event type templates for consistency
- ✅ **Flexible Scheduling**: Daily, weekly, monthly, and custom patterns
- ✅ **Dynamic Content**: Variable substitution in generated events
- ✅ **Completion Tracking**: Track routine adherence and patterns
- ✅ **Schedule Adjustment**: Modify patterns without losing history

### Template System (Embedded)

#### Content Templates (In Event Types)
```sql
-- Templates embedded directly in event_types table
content_template: "# {{title}}\n\n**Due:** {{due_date | date('MMM DD')}}\n**Priority:** {{priority | priority_badge}}\n**Budget:** {{budget | currency}}\n\n## Description\n{{description}}\n\n## Location\n{{location | default('TBD')}}\n\n## Notes\n{{custom_fields.notes | default('No additional notes')}}"

available_variables: [
  "title", "description", "due_date", "priority", "budget", "location",
  "user.name", "user.email", "today", "tomorrow", "this_week",
  "custom_fields.*", "time_until_due", "days_until_due"
]
```

**Built-in Template Filters:**
- `date(format)` - Format dates: {{due_date | date('YYYY-MM-DD')}}
- `currency(code)` - Format money: {{budget | currency('USD')}}
- `default(value)` - Fallback values: {{location | default('No location')}}
- `uppercase` - Text transform: {{title | uppercase}}
- `truncate(length)` - Limit text: {{description | truncate(100)}}
- `priority_badge` - Visual priority: {{priority | priority_badge}} → 🔴 High
- `relative_time` - Human dates: {{due_date | relative_time}} → "in 3 days"

**Features Enabled:**
- ✅ **Dynamic Content**: Auto-generate descriptions, emails, reports
- ✅ **Variable Substitution**: Pull data from events, items, user, system
- ✅ **Filter Functions**: Transform and format data for display
- ✅ **Conditional Logic**: Show/hide content based on field values
- ✅ **Multi-Format Output**: Generate markdown, HTML, plain text
- ✅ **User Customization**: Users can modify templates per event type

### Goal System (Future Enhancement)

#### Goals (Special Event Types)
```javascript
// Goals as sophisticated event types with progress tracking
{
  event_type: "Goal",
  custom_fields: {
    target_value: 100,
    current_value: 45,
    unit: "workouts",
    deadline: "2024-12-31",
    milestones: [
      {value: 25, label: "Quarter", achieved: true, date: "2024-03-15"},
      {value: 50, label: "Halfway", achieved: false},
      {value: 75, label: "Three Quarters", achieved: false},
      {value: 100, label: "Complete", achieved: false}
    ]
  }
}
```

**Features Enabled:**
- ✅ **Progress Tracking**: Quantitative and qualitative goal measurement
- ✅ **Milestone Management**: Break large goals into smaller targets
- ✅ **Automatic Calculation**: Progress percentages and projections
- ✅ **Integration with Events**: Regular events can contribute to goal progress
- ✅ **Visual Dashboards**: Progress charts and achievement visualization
- ✅ **Achievement System**: Celebration of milestone completion

---

## Performance & Technical Features

### Hybrid Database Performance

#### PostgreSQL Server Performance (Primary Storage)
```sql
-- Optimized for 1M+ records with enterprise performance
SELECT * FROM events 
WHERE user_id = ? 
  AND priority >= 4 
  AND due_date BETWEEN ? AND ?
  AND custom_fields @> '{"project_code": "PROJ-2024"}';
-- Performance: 20-50ms with 1M records

-- JSONB flexibility with GIN index optimization
SELECT * FROM events 
WHERE user_id = ?
  AND custom_fields @> '{"department": "Engineering", "tags": ["urgent"]}'
ORDER BY due_date LIMIT 50;
-- Performance: 30-80ms with 1M records

-- Advanced search capabilities
SELECT *, ts_rank(search_vector, plainto_tsquery('urgent project deadline')) as rank
FROM events 
WHERE search_vector @@ plainto_tsquery('urgent project deadline')
ORDER BY rank DESC LIMIT 100;
-- Performance: 100-300ms full-text search across unlimited data
```

#### IndexedDB Client Performance (Intelligent Cache)
```javascript
// Local cache performance for offline-first experience
const highPriorityEvents = await db.events
  .where('user_id').equals(userId)
  .and(event => event.priority >= 4)
  .and(event => event.due_date <= tomorrow)
  .toArray();
// Performance: 1-5ms (10K cached records)

// Offline modification queue
await db.events.add(newEvent);
await db.sync_queue.add({operation: 'CREATE', entity: 'event', data: newEvent});
// Performance: <1ms (queued for sync)
```

#### Strategic Indexing for Scale
```sql
-- PostgreSQL Server Indexes
CREATE INDEX CONCURRENTLY idx_events_user_priority_due 
ON events(user_id, priority, due_date) WHERE status = 'active';

CREATE INDEX CONCURRENTLY idx_events_custom_fields 
ON events USING GIN (custom_fields);

CREATE INDEX CONCURRENTLY idx_events_search 
ON events USING GIN (to_tsvector('english', title || ' ' || description));

-- Query performance results:
-- Simple filters: 10-30ms
-- JSONB queries: 20-80ms  
-- Full-text search: 50-200ms
-- Complex analytics: 200ms-2s
```

### Intelligent Synchronization

#### Conflict-Free Sync Strategy
```javascript
class IntelligentSync {
  async syncToServer() {
    // 1. Push local changes
    const localChanges = await this.getLocalChanges();
    await this.server.pushChanges(localChanges);
    
    // 2. Pull relevant server updates
    const serverUpdates = await this.server.getUpdatesFor({
      user_id: this.userId,
      since: this.lastSyncTime,
      relevance_score: 0.6 // Only sync relevant data
    });
    
    // 3. Resolve conflicts with user preferences
    const conflicts = await this.detectConflicts(serverUpdates);
    await this.resolveConflicts(conflicts);
    
    // 4. Update local cache intelligently
    await this.updateLocalCache(serverUpdates);
  }
}
```

**Sync Performance:**
- ✅ **Delta Sync**: Only changed records (typical: <1MB transfer)
- ✅ **Conflict Resolution**: Real-time collaborative editing
- ✅ **Background Sync**: Non-blocking user experience
- ✅ **Offline Queue**: Unlimited offline operations
- ✅ **Smart Caching**: 10K most relevant records locally

### Scalability Architecture

#### Client Layer Optimization
```javascript
// Memory-efficient virtual scrolling
class VirtualEventList {
  constructor() {
    this.pageSize = 50;
    this.maxCachedPages = 10; // Limit memory usage
  }
  
  async loadPage(pageIndex) {
    // Check local cache first
    if (this.localCache.has(pageIndex)) {
      return this.localCache.get(pageIndex);
    }
    
    // Fallback to server with pagination
    return this.server.getEvents({
      offset: pageIndex * this.pageSize,
      limit: this.pageSize
    });
  }
}
```

#### Server Layer Optimization
```sql
-- Partitioning for massive datasets
CREATE TABLE events_y2024m01 PARTITION OF events
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- Automatic archiving of old data
CREATE TABLE events_archive (LIKE events INCLUDING ALL);

-- Advanced analytics with materialized views
CREATE MATERIALIZED VIEW user_productivity_stats AS
SELECT user_id,
       COUNT(*) as total_events,
       AVG(priority) as avg_priority,
       COUNT(*) FILTER (WHERE status = 'completed') as completed_count
FROM events 
GROUP BY user_id;
```

**Enterprise Scale Capabilities:**
- ✅ **Unlimited Storage**: PostgreSQL handles billions of records
- ✅ **Horizontal Scaling**: Read replicas, connection pooling
- ✅ **Real-time Analytics**: Materialized views, advanced aggregations
- ✅ **Multi-tenant Architecture**: Row-level security, data isolation
- ✅ **Global Distribution**: Edge caching, regional databases

---

## UI Integration Features

### Workspace Management

#### Enhanced User Preferences
```sql
-- All UI state in users table (performance optimized)
ALTER TABLE users ADD COLUMN workspace_config JSONB DEFAULT '{}';
ALTER TABLE users ADD COLUMN view_preferences JSONB DEFAULT '{}';
ALTER TABLE users ADD COLUMN onboarding_state JSONB DEFAULT '{}';
```

**Workspace Configuration:**
```json
{
  "pinned_events": [123, 456, 789],
  "active_collections": [1, 3, 7],
  "workspace_layout": "split-view",
  "default_view_mode": "list",
  "recent_searches": ["#work priority:high", "#health due:this-week"],
  "quick_filters": [
    {"name": "Today", "filter": {"due_date": "today"}},
    {"name": "High Priority", "filter": {"priority": {">=": 4}}}
  ]
}
```

**View Preferences:**
```json
{
  "events_view": {
    "columns": ["title", "due_date", "priority", "tags"],
    "sort_by": "due_date",
    "sort_order": "asc",
    "page_size": 25,
    "show_completed": false
  },
  "items_view": {
    "display_mode": "grid",
    "show_quantities": true,
    "group_by": "item_type"
  },
  "collections_view": {
    "display_mode": "list",
    "show_counts": true,
    "auto_refresh": true
  }
}
```

**Progressive Disclosure:**
```json
{
  "first_event_created": true,
  "first_collection_created": false,
  "views_tab_unlocked": true,
  "templates_introduced": false,
  "field_library_discovered": false,
  "routines_unlocked": false
}
```

**Features Enabled:**
- ✅ **Persistent Workspace**: Maintain user context across sessions
- ✅ **Customizable Views**: User-configurable display preferences
- ✅ **Progressive Disclosure**: Unlock features as users advance
- ✅ **Quick Access**: Pinned items and recent actions
- ✅ **Adaptive Interface**: UI adapts to user behavior patterns

### Tabbed Navigation System

#### Three-Tab Architecture
1. **EVENTS** - Primary workspace with filtering, creation, and management
2. **VAULT** - Collections, saved filters, and organizational structures
3. **TEMPLATES** - Content templates, automation rules, and customization

**Event Tab Features:**
- ✅ **Quick Capture Bar**: Always-visible input for rapid event creation
- ✅ **Smart Filtering**: Real-time filtering with Collection Query Language
- ✅ **Bulk Operations**: Multi-select for batch actions
- ✅ **Inline Editing**: Edit events without modal dialogs
- ✅ **Relationship Visualization**: See connections between events
- ✅ **Calendar Integration**: Switch between list and calendar views

**Vault Tab Features:**
- ✅ **Collection Dashboard**: Visual overview of all collections
- ✅ **Dynamic Collections**: Real-time updating based on filters
- ✅ **Collection Sharing**: Export and import collection definitions
- ✅ **Tag Management**: Visual tag organization and editing
- ✅ **Relationship Explorer**: Graph view of entity relationships
- ✅ **Advanced Search**: Complex queries across all data

**Templates Tab Features:**
- ✅ **Event Type Builder**: Visual creation of new event types
- ✅ **Field Library Browser**: Drag-and-drop field selection
- ✅ **Template Editor**: Live preview of content templates
- ✅ **Routine Designer**: Visual workflow for recurring events
- ✅ **Automation Rules**: Advanced triggers and actions
- ✅ **Export/Import**: Share configurations between users

---

## File Synchronization

### Bidirectional Markdown Sync

#### Entity Files Table
```sql
CREATE TABLE entity_files (
    id SERIAL PRIMARY KEY,
    entity_type VARCHAR(10) NOT NULL,  -- 'event' or 'item'
    entity_id INTEGER NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    sync_status JSONB DEFAULT '{}',
    user_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(entity_type, entity_id, file_path)
);
```

#### Sync Architecture
```javascript
class FileSync {
  // Convert database event to markdown file
  static async exportToMarkdown(eventId) {
    const event = await Event.get(eventId);
    const template = await EventType.getTemplate(event.event_type_id);
    const markdown = template.render(event);
    
    await this.writeFile(event.file_path, markdown);
    await this.updateSyncStatus(eventId, 'exported');
  }
  
  // Parse markdown file and update database
  static async importFromMarkdown(filePath) {
    const markdown = await this.readFile(filePath);
    const parsed = await this.parseMarkdown(markdown);
    
    await Event.update(parsed.event_id, parsed.data);
    await this.updateSyncStatus(parsed.event_id, 'imported');
  }
  
  // Two-way sync with conflict detection
  static async bidirectionalSync() {
    const conflicts = await this.detectConflicts();
    for (const conflict of conflicts) {
      await this.resolveConflict(conflict);
    }
  }
}
```

**Sync Status Tracking:**
```json
{
  "last_db_export": "2024-01-15T10:30:00Z",
  "last_file_import": "2024-01-15T10:25:00Z", 
  "conflict_detected": false,
  "auto_sync_enabled": true,
  "backup_created": "2024-01-15T10:29:00Z"
}
```

**Features Enabled:**
- ✅ **Real-time Sync**: Changes in database immediately reflect in files
- ✅ **External Editing**: Edit markdown files in any editor, sync back to database
- ✅ **Conflict Resolution**: Smart merging when both database and file change
- ✅ **Version History**: Maintain history of file changes for rollback
- ✅ **Selective Sync**: Choose which events/items to sync with files
- ✅ **Backup Creation**: Automatic backups before sync operations

### Integration Capabilities

#### External Tool Support
```javascript
// Integration examples
const integrations = {
  obsidian: {
    vault_path: '/Users/name/Documents/ObsidianVault',
    sync_pattern: 'Events/{{event_type}}/{{title}}.md',
    template_format: 'obsidian_template'
  },
  
  notion: {
    api_key: 'secret_key',
    database_id: 'notion_database_id',
    sync_direction: 'bidirectional'
  },
  
  filesystem: {
    base_path: '/Users/name/Documents/Productivity',
    organize_by: 'event_type',  // or 'date', 'priority', 'tag'
    file_naming: '{{due_date}}-{{title}}.md'
  }
};
```

**Features Enabled:**
- ✅ **Obsidian Integration**: Sync with Obsidian vaults for knowledge management
- ✅ **Notion Sync**: Bidirectional sync with Notion databases
- ✅ **File System Export**: Organize as markdown files in any folder structure
- ✅ **Multiple Formats**: Export to markdown, JSON, CSV, or custom formats
- ✅ **Configurable Naming**: User-defined file naming patterns
- ✅ **Batch Operations**: Bulk export/import of multiple entities

---

## Security & Audit Features

### Comprehensive Audit Trail

#### Operation Logs
```sql
CREATE TABLE operation_logs (
    log_id SERIAL PRIMARY KEY,
    user_id INTEGER,
    operation_type VARCHAR(50) NOT NULL,  -- 'CREATE', 'UPDATE', 'DELETE', 'LOGIN'
    entity_type VARCHAR(50),              -- 'event', 'item', 'tag', etc.
    entity_id INTEGER,
    old_values JSONB,                     -- State before change
    new_values JSONB,                     -- State after change
    metadata JSONB DEFAULT '{}',          -- IP, user agent, etc.
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Audit Capabilities:**
- ✅ **Complete Change History**: Every create, update, delete operation logged
- ✅ **Before/After Values**: Full state tracking for rollback capability
- ✅ **User Attribution**: All changes tied to specific users
- ✅ **Metadata Tracking**: IP addresses, browsers, session info
- ✅ **Query Interface**: Search audit logs by user, entity, date, operation
- ✅ **Compliance Ready**: Supports regulatory audit requirements

### Data Recovery

#### Soft Delete System
```sql
CREATE TABLE deleted_entities (
    deletion_id SERIAL PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,
    entity_id INTEGER NOT NULL,
    entity_data JSONB NOT NULL,          -- Complete entity snapshot
    deleted_by INTEGER,
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deletion_reason TEXT
);
```

**Recovery Features:**
- ✅ **Soft Deletes**: Nothing is permanently destroyed immediately
- ✅ **Complete Snapshots**: Full entity state preserved for recovery
- ✅ **Relationship Preservation**: Connected entities remain recoverable
- ✅ **User Interface**: Easy recovery interface for accidental deletions
- ✅ **Bulk Recovery**: Restore multiple related entities together
- ✅ **Permanent Cleanup**: Configurable permanent deletion after time period

### Privacy & Data Protection

#### User Data Management
```javascript
class PrivacyManager {
  // GDPR compliance features
  static async exportUserData(userId) {
    return {
      user: await User.get(userId),
      events: await Event.findByUser(userId),
      items: await Item.findByUser(userId),
      tags: await Tag.findByUser(userId),
      collections: await Collection.findByUser(userId),
      audit_logs: await OperationLog.findByUser(userId)
    };
  }
  
  static async anonymizeUser(userId) {
    await User.update(userId, {
      email: '[ANONYMIZED]',
      username: '[ANONYMIZED]',
      workspace_config: {},
      view_preferences: {}
    });
    
    await OperationLog.create({
      operation_type: 'ANONYMIZE',
      entity_type: 'user',
      entity_id: userId
    });
  }
  
  static async deleteUserData(userId) {
    // Cascade delete all user data with audit trail
    await this.cascadeDelete('user', userId);
  }
}
```

**Privacy Features:**
- ✅ **Data Export**: Complete user data export in JSON format
- ✅ **Data Anonymization**: Remove PII while preserving analytics
- ✅ **Right to Deletion**: Complete user data removal
- ✅ **Consent Management**: Track user consent for data processing
- ✅ **Data Minimization**: Collect only necessary data
- ✅ **Encryption**: Sensitive data encrypted at rest and in transit

---

## Extensibility Features

### Infinite Type Creation

#### User-Defined Event Types
```javascript
// Example: User creates "Workout" event type
const workoutType = await EventType.create({
  name: "Workout",
  description: "Exercise tracking and planning",
  color: "#e74c3c",
  icon: "dumbbell",
  content_template: `# {{title}}
  
**Date:** {{due_date | date('MMM DD, YYYY')}}
**Duration:** {{custom_fields.duration}} minutes
**Type:** {{custom_fields.workout_type}}
**Location:** {{location | default('Home')}}

## Exercises
{{custom_fields.exercises}}

## Notes
{{custom_fields.notes | default('No additional notes')}}`,
  
  available_variables: [
    "title", "due_date", "location", "description",
    "custom_fields.duration", "custom_fields.workout_type", 
    "custom_fields.exercises", "custom_fields.notes"
  ]
});

// Add fields from library
await EntityField.add(workoutType.id, 'event_type', [
  {field_id: 1, display_name: "Workout Date", is_required: true},      // due_date
  {field_id: 15, display_name: "Duration (minutes)", default_value: 60}, // number field
  {field_id: 20, display_name: "Workout Type", is_required: true},     // select field
  {field_id: 4, display_name: "Gym/Location"},                         // location
  {field_id: 25, display_name: "Exercises", is_required: true},        // text area
  {field_id: 7, display_name: "Notes"}                                 // text area
]);
```

**Generated User Experience:**
1. **Form Auto-Generation**: System creates workout form with duration slider, workout type dropdown, etc.
2. **Template Rendering**: Each workout event gets formatted description with variables
3. **Validation**: Required fields enforced, number ranges validated
4. **UI Integration**: Custom color/icon in lists, calendars, dashboards

### Plugin Architecture (Future)

#### Extension Points
```javascript
// Example plugin system design
class PluginManager {
  static registerPlugin(plugin) {
    this.plugins.push(plugin);
    this.registerHooks(plugin.hooks);
  }
  
  static async executeHook(hookName, data) {
    const hooks = this.hooks[hookName] || [];
    for (const hook of hooks) {
      data = await hook(data);
    }
    return data;
  }
}

// Example: Analytics plugin
class AnalyticsPlugin {
  hooks = {
    'event.created': async (event) => {
      await this.trackEvent('event_created', {
        event_type: event.event_type_id,
        has_due_date: !!event.due_date,
        priority: event.priority
      });
      return event;
    },
    
    'collection.viewed': async (collection) => {
      await this.trackEvent('collection_viewed', {
        collection_id: collection.id,
        item_count: collection.item_count
      });
      return collection;
    }
  };
}
```

**Extension Capabilities:**
- ✅ **Custom Field Types**: Define new validation and UI components
- ✅ **Custom Views**: Create specialized display modes
- ✅ **Integration Hooks**: Connect to external services
- ✅ **Automation Rules**: Custom triggers and actions
- ✅ **Import/Export**: Custom data format support
- ✅ **Theme System**: Custom UI themes and layouts

### API Platform

#### RESTful API Design
```javascript
// API endpoints for all functionality
const apiRoutes = {
  // Core entities
  'GET /api/events': 'EventController.index',
  'POST /api/events': 'EventController.create',
  'GET /api/events/:id': 'EventController.show',
  'PUT /api/events/:id': 'EventController.update',
  'DELETE /api/events/:id': 'EventController.destroy',
  
  // Advanced queries
  'POST /api/events/search': 'EventController.search',
  'GET /api/collections/:id/events': 'CollectionController.events',
  
  // Relationships
  'GET /api/events/:id/relationships': 'RelationshipController.index',
  'POST /api/events/:id/relationships': 'RelationshipController.create',
  
  // Type system
  'GET /api/event-types': 'EventTypeController.index',
  'POST /api/event-types': 'EventTypeController.create',
  'GET /api/field-definitions': 'FieldController.definitions',
  
  // File sync
  'POST /api/events/:id/export': 'FileSyncController.export',
  'POST /api/files/import': 'FileSyncController.import'
};
```

**API Features:**
- ✅ **Complete REST API**: Full CRUD operations for all entities
- ✅ **Advanced Queries**: Collection Query Language via API
- ✅ **Batch Operations**: Multi-entity create/update/delete
- ✅ **File Upload/Download**: Attachment and sync support
- ✅ **Authentication**: Token-based auth with role permissions
- ✅ **Rate Limiting**: Prevent abuse with configurable limits
- ✅ **Documentation**: Auto-generated API documentation
- ✅ **Webhooks**: Real-time notifications for external systems

---

## Implementation Roadmap

### Phase 1: Offline-First Client Foundation ✅ (Complete)
**Status**: 18-table IndexedDB schema working, MVVM architecture operational

- [x] Database schema with Events, Items, Users tables (IndexedDB)
- [x] Type system (event_types, item_types)
- [x] Universal systems (tags, tag_assignments, links)
- [x] Collections and Lists with dynamic filtering
- [x] Basic Models and ViewModels (MVVM pattern)
- [x] Quick capture functionality with NLP
- [x] Audit logging system with soft deletes
- [x] Offline-first development environment

### Phase 2: PostgreSQL Server Architecture 🚀 (Next - 2-3 weeks)
**Goal**: Add PostgreSQL server with identical schema for unlimited scale

#### Week 1: Server Database Setup
- [ ] PostgreSQL server with identical 18-table schema
- [ ] Real column optimization (priority, budget, location, due_date)
- [ ] JSONB custom fields with GIN indexing
- [ ] Strategic compound indexes for performance
- [ ] Database migration system for schema evolution

#### Week 2: RESTful API Development
- [ ] Node.js/Express API server with PostgreSQL connection
- [ ] CRUD endpoints for all entities with JSONB optimization
- [ ] Authentication and authorization system
- [ ] Query optimization for 1M+ record performance
- [ ] API rate limiting and security measures

#### Week 3: Universal Field System
- [ ] Server-side field_definitions and entity_fields implementation
- [ ] Dynamic form generation based on field configurations
- [ ] Validation system for custom fields
- [ ] Field library management interface
- [ ] Type builder with PostgreSQL backend

### Phase 3: Intelligent Sync & Enterprise Features 🔧 (4-6 weeks)
**Goal**: Bidirectional sync with conflict resolution and advanced features

#### Weeks 4-5: Synchronization Layer
- [ ] Bidirectional client-server synchronization
- [ ] Intelligent conflict resolution with user preferences
- [ ] Real-time updates via WebSocket integration
- [ ] Background sync optimization and delta transfers
- [ ] Offline modification queue with retry logic

#### Week 6: Advanced Server Features
- [ ] Full-text search using PostgreSQL capabilities
- [ ] Advanced analytics with materialized views
- [ ] Multi-user collaboration with row-level security
- [ ] Real-time notifications and activity feeds
- [ ] Enterprise backup and disaster recovery

#### Weeks 7-9: Enhanced Client Experience
- [ ] Intelligent caching strategy (10K most relevant records)
- [ ] Virtual scrolling for large datasets
- [ ] Progressive loading with background updates
- [ ] Advanced collection queries with server execution
- [ ] Relationship visualization with graph queries

### Phase 4: Production & Scale 📋 (4-6 weeks)
**Goal**: Production-ready deployment with enterprise capabilities

#### Weeks 10-11: Production Infrastructure
- [ ] Docker containerization for all services
- [ ] PostgreSQL optimization for production scale
- [ ] Load balancing and horizontal scaling
- [ ] Monitoring and observability implementation
- [ ] Automated deployment and CI/CD pipeline

#### Weeks 12-13: Enterprise Features
- [ ] Multi-tenant architecture with data isolation
- [ ] Advanced user management and permissions
- [ ] Integration APIs for enterprise tools
- [ ] Advanced reporting and analytics dashboard
- [ ] Compliance features (audit trails, data retention)

#### Weeks 14-15: Performance & Optimization
- [ ] Query optimization for massive datasets (10M+ records)
- [ ] Caching strategies (Redis, CDN integration)
- [ ] Database partitioning for time-series data
- [ ] Performance monitoring and automatic scaling
- [ ] Mobile-responsive design with offline sync

### Phase 5: Platform & Ecosystem 🚀 (Ongoing)
**Goal**: Ecosystem expansion and advanced capabilities

- [ ] Mobile applications with full offline sync
- [ ] Advanced AI features (smart suggestions, automation)
- [ ] Third-party integrations (Zapier, IFTTT, enterprise tools)
- [ ] Plugin architecture and marketplace
- [ ] Global deployment with edge caching
- [ ] Advanced analytics and machine learning insights

---

## Conclusion

This Implementation Roadmap represents a **comprehensive path from offline-first development to enterprise-scale platform**. Through the PostgreSQL + JSONB server architecture combined with intelligent IndexedDB caching, the system can scale from personal productivity (1K records) to enterprise collaboration (1M+ records) while maintaining the core principle of **radical simplicity with universal extensibility**.

### Key Success Factors

1. **Hybrid Architecture** - Best of both worlds: offline capability + unlimited server scale
2. **Identical Schemas** - Seamless sync between IndexedDB cache and PostgreSQL server
3. **Performance Focus** - Real columns + JSONB strategy for 10x query improvement
4. **Intelligent Sync** - Only transfer relevant data, resolve conflicts gracefully
5. **Future-Proof Design** - Architecture supports AI integration, global scale, and collaboration

### Core Philosophy Realized

**"Clean, Simple, Pure Data Structures"** - Every design decision optimizes for simplicity, performance, and maintainability while enabling infinite user customization through the PostgreSQL + JSONB backend.

**"Offline-First, Server-Scale"** - Users get instant offline experience with the confidence that their data scales infinitely through the server architecture.

This hybrid approach transforms how people organize their digital lives, providing the flexibility to evolve from personal productivity to enterprise-scale organizational systems without fundamental changes to the underlying architecture.

**The result: A productivity platform that works instantly offline and scales infinitely online.**


# Database Schema v4.0
**Organizational Ecosystem Application - Hybrid Offline-First + Server Architecture**

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [PostgreSQL Server Schema](#postgresql-server-schema)
3. [IndexedDB Client Schema](#indexeddb-client-schema)
4. [Synchronization Strategy](#synchronization-strategy)
5. [Performance Optimization](#performance-optimization)
6. [Schema Migration Strategy](#schema-migration-strategy)

---

## Architecture Overview

### Hybrid Design Philosophy

The Organizational Ecosystem uses a **hybrid offline-first architecture** with identical schemas for seamless synchronization:

```
┌─────────────────────────────────────────────────────────────┐
│                     CLIENT LAYER                           │
├─────────────────────────────────────────────────────────────┤
│  IndexedDB Cache: Intelligent subset (10K most relevant)   │
│  - Instant offline operations (1-5ms)                      │
│  - Complete functionality without server                   │
│  - Modification queue for offline changes                  │
│  - Automatic background sync when online                   │
└─────────────────────────────────────────────────────────────┘
                               ▲ ▼ Intelligent Sync
┌─────────────────────────────────────────────────────────────┐
│                    SERVER LAYER                            │
├─────────────────────────────────────────────────────────────┤
│  PostgreSQL + JSONB: Unlimited primary storage             │
│  - Enterprise performance with 1M+ records (10-100ms)     │
│  - Advanced search and analytics capabilities              │
│  - Multi-user collaboration with conflict resolution       │
│  - Real-time updates and comprehensive audit trails        │
└─────────────────────────────────────────────────────────────┘
```

### Schema Consistency Strategy

**Identical 18-table structure** across both layers ensures:
- ✅ **Seamless Sync**: No data transformation needed
- ✅ **Offline Development**: Build against IndexedDB, deploy to PostgreSQL
- ✅ **Conflict Resolution**: Same data types and constraints
- ✅ **Performance**: Optimized indexes for both platforms

### Core Principles

1. **Two-Type Purity**: Everything is either an Event (verb) or Item (noun)
2. **Real Columns + JSONB**: Common fields as real columns (10x performance), custom fields in JSONB
3. **Polymorphic Design**: Universal systems work across all entity types
4. **Offline-First**: Complete functionality without server dependency

---

## PostgreSQL Server Schema

### Core Entities

#### Users Table
```sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    
    -- Workspace configuration (JSONB for flexibility)
    workspace_config JSONB DEFAULT '{}',
    view_preferences JSONB DEFAULT '{}',
    onboarding_state JSONB DEFAULT '{}',
    
    -- Subscription and limits
    subscription_tier VARCHAR(20) DEFAULT 'free',
    storage_used_mb INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- Performance indexes
CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_username ON users(username) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_subscription ON users(subscription_tier, created_at);

-- Row-level security for multi-user
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY users_own_data ON users FOR ALL 
USING (user_id = current_setting('app.current_user_id')::INTEGER);
```

#### Events Table (Performance Optimized)
```sql
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    event_type_id INTEGER REFERENCES event_types(event_type_id),
    
    -- Core content
    title VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- PERFORMANCE: Real columns for 10x query speed improvement
    priority INTEGER CHECK (priority BETWEEN 1 AND 5),
    budget DECIMAL(10,2),
    location VARCHAR(200),
    due_date TIMESTAMP,
    completed_date TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'cancelled', 'deferred')),
    
    -- FLEXIBILITY: JSONB for unlimited custom fields with GIN index performance
    custom_fields JSONB DEFAULT '{}',
    
    -- Full-text search optimization
    search_vector tsvector,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- Enterprise-grade performance indexes
CREATE INDEX idx_events_user_active ON events(user_id, status, due_date) 
WHERE deleted_at IS NULL;

CREATE INDEX idx_events_priority_filter ON events(user_id, priority, due_date) 
WHERE deleted_at IS NULL AND status = 'active';

CREATE INDEX idx_events_location ON events(user_id, location) 
WHERE deleted_at IS NULL AND location IS NOT NULL;

CREATE INDEX idx_events_budget ON events(user_id, budget) 
WHERE deleted_at IS NULL AND budget IS NOT NULL;

-- JSONB optimization with GIN indexes
CREATE INDEX idx_events_custom_fields ON events USING GIN (custom_fields) 
WHERE deleted_at IS NULL;

-- Full-text search capability
CREATE INDEX idx_events_search ON events USING GIN (search_vector) 
WHERE deleted_at IS NULL;

-- Auto-update search vector trigger
CREATE OR REPLACE FUNCTION update_events_search_vector() RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector := to_tsvector('english', 
        COALESCE(NEW.title, '') || ' ' || 
        COALESCE(NEW.description, '') || ' ' ||
        COALESCE(NEW.location, '')
    );
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER events_search_update 
BEFORE INSERT OR UPDATE ON events 
FOR EACH ROW EXECUTE FUNCTION update_events_search_vector();

-- Row-level security
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
CREATE POLICY events_own_data ON events FOR ALL 
USING (user_id = current_setting('app.current_user_id')::INTEGER);
```

#### Items Table (Performance Optimized)
```sql
CREATE TABLE items (
    item_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    item_type_id INTEGER REFERENCES item_types(item_type_id),
    
    -- Core content
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- PERFORMANCE: Real columns for common operations
    quantity DECIMAL(10,3) DEFAULT 1,
    unit VARCHAR(50),
    value DECIMAL(10,2),
    location VARCHAR(200),
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'consumed', 'lost')),
    
    -- FLEXIBILITY: JSONB for custom fields
    custom_fields JSONB DEFAULT '{}',
    
    -- Full-text search
    search_vector tsvector,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- Performance indexes for inventory management
CREATE INDEX idx_items_user_active ON items(user_id, status) 
WHERE deleted_at IS NULL;

CREATE INDEX idx_items_quantity ON items(user_id, quantity) 
WHERE deleted_at IS NULL AND quantity > 0;

CREATE INDEX idx_items_value ON items(user_id, value DESC) 
WHERE deleted_at IS NULL AND value IS NOT NULL;

CREATE INDEX idx_items_location ON items(user_id, location) 
WHERE deleted_at IS NULL AND location IS NOT NULL;

-- JSONB and search indexes
CREATE INDEX idx_items_custom_fields ON items USING GIN (custom_fields) 
WHERE deleted_at IS NULL;

CREATE INDEX idx_items_search ON items USING GIN (search_vector) 
WHERE deleted_at IS NULL;

-- Search vector maintenance
CREATE TRIGGER items_search_update 
BEFORE INSERT OR UPDATE ON items 
FOR EACH ROW EXECUTE FUNCTION update_items_search_vector();

CREATE OR REPLACE FUNCTION update_items_search_vector() RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector := to_tsvector('english', 
        COALESCE(NEW.name, '') || ' ' || 
        COALESCE(NEW.description, '') || ' ' ||
        COALESCE(NEW.location, '')
    );
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Row-level security
ALTER TABLE items ENABLE ROW LEVEL SECURITY;
CREATE POLICY items_own_data ON items FOR ALL 
USING (user_id = current_setting('app.current_user_id')::INTEGER);
```

### Remaining Tables Summary

The complete PostgreSQL schema includes 18 tables total:

**Type System:**
- event_types, item_types (with embedded templates)

**Universal Field System:**  
- field_definitions, entity_fields (polymorphic field assignment)

**Universal Systems:**
- tags, tag_assignments (polymorphic tagging)
- links (universal relationships)

**Organization:**
- collections (dynamic filtering with CQL)
- lists, list_items (hybrid text/linked entities)
- routines, routine_event_instances (automation)

**Infrastructure:**
- entity_files (file sync)
- operation_logs (audit trail)
- deleted_entities (soft delete recovery)

*[Full schemas available in original DATABASE_SCHEMA.md]*

---

## IndexedDB Client Schema

### Dexie.js Schema Definition

```javascript
// src/database/schema.js
import Dexie from 'dexie';

class OrganizationalDatabase extends Dexie {
  constructor() {
    super('OrganizationalEcosystem');
    
    // IDENTICAL structure to PostgreSQL for seamless sync
    this.version(1).stores({
      // Core entities (mirrors PostgreSQL exactly)
      users: 'user_id, username, email, workspace_config, view_preferences',
      events: 'event_id, user_id, event_type_id, title, priority, budget, location, due_date, status, custom_fields',
      items: 'item_id, user_id, item_type_id, name, quantity, value, location, status, custom_fields',
      
      // Type system
      event_types: 'event_type_id, user_id, name, content_template, available_variables',
      item_types: 'item_type_id, user_id, name, category, tracks_quantity',
      
      // Universal field system
      field_definitions: 'field_id, field_name, field_type, validation_schema, category',
      entity_fields: '[entity_type+entity_id+field_id], entity_type, entity_id, field_id, sequence_order',
      
      // Universal systems
      tags: 'tag_id, user_id, name, color',
      tag_assignments: '[taggable_type+taggable_id+tag_id], tag_id, taggable_type, taggable_id',
      links: 'link_id, from_type, from_id, to_type, to_id, relationship_type',
      
      // Organization
      collections: 'collection_id, user_id, name, filter_config, view_config',
      lists: 'list_id, user_id, title, is_ordered',
      list_items: 'list_item_id, list_id, text_content, linked_type, linked_id, sequence_order',
      
      // Advanced features
      routines: 'routine_id, user_id, title, event_type_id, schedule_pattern',
      routine_event_instances: 'instance_id, routine_id, event_id, scheduled_date',
      
      // File sync
      entity_files: 'id, entity_type, entity_id, file_path, sync_status',
      
      // Infrastructure
      operation_logs: 'log_id, user_id, operation_type, entity_type, entity_id, timestamp',
      deleted_entities: 'deletion_id, entity_type, entity_id, entity_data, deleted_at',
      
      // Sync management
      sync_queue: 'sync_id, operation, entity_type, entity_id, data, created_at'
    });
  }
}

export const db = new OrganizationalDatabase();
```

### Client-Specific Optimizations

#### Intelligent Caching Strategy
```javascript
class CacheManager {
  constructor() {
    this.maxLocalRecords = 10000;
    this.cacheStrategy = {
      recent: 2000,        // Recently accessed
      favorites: 1000,     // User-starred  
      due_soon: 2000,      // Due within week
      active_projects: 3000, // Current work
      offline_queue: 2000   // Pending sync
    };
  }
  
  async optimizeCache() {
    const relevantEvents = await this.server.getRelevantEvents({
      user_id: this.userId,
      strategy: this.cacheStrategy
    });
    
    // Replace cache with most relevant subset
    await db.transaction('rw', db.events, async () => {
      await db.events.clear();
      await db.events.bulkAdd(relevantEvents);
    });
  }
}
```

#### Offline Modification Queue
```javascript
class OfflineQueue {
  async queueOperation(operation, entityType, entityId, data) {
    await db.sync_queue.add({
      operation,        // 'CREATE', 'UPDATE', 'DELETE'
      entity_type: entityType,
      entity_id: entityId,
      data,
      created_at: new Date(),
      retry_count: 0
    });
  }
  
  async processQueue() {
    const pendingOperations = await db.sync_queue
      .orderBy('created_at')
      .toArray();
    
    for (const op of pendingOperations) {
      try {
        await this.syncToServer(op);
        await db.sync_queue.delete(op.sync_id);
      } catch (error) {
        await this.handleSyncError(op, error);
      }
    }
  }
}
```

---

## Synchronization Strategy

### Bidirectional Sync Architecture

```javascript
class IntelligentSync {
  constructor() {
    this.conflictResolution = 'server_wins'; // 'client_wins', 'merge', 'manual'
    this.syncBatchSize = 100;
    this.syncInterval = 30000; // 30 seconds
  }
  
  async bidirectionalSync() {
    // 1. Push local changes to server
    await this.pushLocalChanges();
    
    // 2. Pull relevant server updates
    await this.pullServerUpdates();
    
    // 3. Resolve any conflicts
    await this.resolveConflicts();
    
    // 4. Optimize local cache
    await this.optimizeLocalCache();
  }
  
  async pushLocalChanges() {
    const pendingChanges = await db.sync_queue.toArray();
    
    for (const change of pendingChanges) {
      try {
        const result = await this.server.applyChange(change);
        
        if (result.success) {
          // Update local record with server version
          await this.updateLocalRecord(change, result.data);
          await db.sync_queue.delete(change.sync_id);
        } else {
          await this.handleSyncConflict(change, result);
        }
      } catch (error) {
        await this.handleSyncError(change, error);
      }
    }
  }
  
  async pullServerUpdates() {
    const lastSyncTime = await this.getLastSyncTime();
    
    const serverUpdates = await this.server.getUpdatesFor({
      user_id: this.userId,
      since: lastSyncTime,
      relevance_filter: this.getCacheStrategy()
    });
    
    // Apply server updates to local cache
    for (const update of serverUpdates) {
      await this.applyServerUpdate(update);
    }
    
    await this.setLastSyncTime(new Date());
  }
  
  async resolveConflicts() {
    const conflicts = await db.sync_conflicts.toArray();
    
    for (const conflict of conflicts) {
      switch (this.conflictResolution) {
        case 'server_wins':
          await this.applyServerVersion(conflict);
          break;
        case 'client_wins':
          await this.pushClientVersion(conflict);
          break;
        case 'merge':
          await this.mergeVersions(conflict);
          break;
        case 'manual':
          await this.requestUserResolution(conflict);
          break;
      }
    }
  }
}
```

---

## Performance Optimization

### PostgreSQL Query Performance

#### Example Queries with Performance Expectations

```sql
-- Real column filtering (10-30ms with 1M records)
SELECT * FROM events 
WHERE user_id = $1 
  AND priority >= 4 
  AND due_date BETWEEN $2 AND $3
  AND status = 'active'
ORDER BY due_date 
LIMIT 50;

-- JSONB filtering with GIN index (20-80ms with 1M records)
SELECT * FROM events 
WHERE user_id = $1 
  AND custom_fields @> '{"project": "Alpha", "department": "Engineering"}'
ORDER BY due_date 
LIMIT 50;

-- Combined real + JSONB query (25-100ms with 1M records)
SELECT * FROM events 
WHERE user_id = $1 
  AND priority >= 4 
  AND custom_fields @> '{"tags": ["urgent"]}'
  AND due_date > CURRENT_DATE
ORDER BY priority DESC, due_date ASC
LIMIT 50;

-- Full-text search (50-200ms with 1M records)
SELECT *, ts_rank(search_vector, plainto_tsquery($2)) as rank
FROM events 
WHERE user_id = $1 
  AND search_vector @@ plainto_tsquery($2)
ORDER BY rank DESC 
LIMIT 100;
```

### IndexedDB Performance

#### Optimized Query Patterns

```javascript
class OptimizedQueries {
  // Compound index queries (fastest)
  async getHighPriorityEvents(userId) {
    return db.events
      .where('[user_id+priority]')
      .between([userId, 4], [userId, 5])
      .toArray();
  }
  
  // Single field with filter (fast)
  async getDueSoonEvents(userId, daysAhead = 7) {
    const maxDate = new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000);
    
    return db.events
      .where('user_id')
      .equals(userId)
      .and(event => event.due_date && event.due_date <= maxDate)
      .toArray();
  }
  
  // Virtual pagination for large result sets
  async getPaginatedEvents(userId, page = 0, pageSize = 50) {
    return db.events
      .where('user_id')
      .equals(userId)
      .offset(page * pageSize)
      .limit(pageSize)
      .toArray();
  }
}
```

---

## Schema Migration Strategy

### Version Management

```sql
-- Migration tracking table
CREATE TABLE schema_migrations (
    version INTEGER PRIMARY KEY,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    migration_name VARCHAR(255) NOT NULL,
    checksum VARCHAR(64) NOT NULL
);

-- Example migration (V2: Add real columns for performance)
-- V2__add_performance_columns.sql
ALTER TABLE events 
ADD COLUMN priority INTEGER CHECK (priority BETWEEN 1 AND 5),
ADD COLUMN budget DECIMAL(10,2),
ADD COLUMN location VARCHAR(200),
ADD COLUMN due_date TIMESTAMP;

-- Migrate data from custom_fields to real columns
UPDATE events 
SET priority = (custom_fields->>'priority')::INTEGER
WHERE custom_fields->>'priority' IS NOT NULL;

UPDATE events 
SET budget = (custom_fields->>'budget')::DECIMAL
WHERE custom_fields->>'budget' IS NOT NULL;

-- Remove migrated fields from custom_fields
UPDATE events 
SET custom_fields = custom_fields - 'priority' - 'budget' - 'location' - 'due_date';

-- Add indexes for new columns
CREATE INDEX idx_events_priority_due ON events(user_id, priority, due_date) 
WHERE deleted_at IS NULL;

INSERT INTO schema_migrations (version, migration_name, checksum) 
VALUES (2, 'Add performance columns', 'abc123...');
```

### Client-Server Schema Sync

```javascript
class SchemaSyncManager {
  async checkSchemaVersion() {
    const clientVersion = await db.getSchemaVersion();
    const serverVersion = await this.server.getSchemaVersion();
    
    if (clientVersion < serverVersion) {
      await this.upgradeClientSchema(clientVersion, serverVersion);
    }
  }
  
  async upgradeClientSchema(fromVersion, toVersion) {
    const migrations = await this.server.getMigrations(fromVersion, toVersion);
    
    for (const migration of migrations) {
      await this.applyClientMigration(migration);
    }
    
    await db.setSchemaVersion(toVersion);
  }
}
```

---

## Conclusion

This hybrid database architecture provides the foundation for a **radically simple, infinitely extensible** organizational ecosystem that scales from personal productivity (1K records) to enterprise collaboration (1M+ records) while maintaining **offline-first functionality** and **sub-second performance**.

### Key Architectural Benefits

1. **Identical Schemas**: Seamless sync between PostgreSQL server and IndexedDB client
2. **Performance Optimized**: Real columns + JSONB strategy for 10x query improvement  
3. **Unlimited Scale**: PostgreSQL handles enterprise datasets with advanced features
4. **Offline-First**: Complete functionality without server dependency
5. **Future-Proof**: Architecture supports AI integration, collaboration, and global scale

The **18-table design** achieves what traditional systems need 50+ tables to accomplish, while the **PostgreSQL + JSONB** approach provides both performance and flexibility for unlimited customization.

**Result: A productivity platform that works instantly offline and scales infinitely online.**


# UI/UX Specification
*Final Interface Design and User Experience Patterns*

## Core Navigation Structure

### Tabbed Architecture
```
┌─────────────────────────────────────────────┐
│ [Files & Data] [Views] [Config]             │ ← Horizontal tabs
├─────────────────────────────────────────────┤
│                                             │
│           Tab-specific content              │
│                                             │
└─────────────────────────────────────────────┘
```

**Default Tab:** Files & Data
- New users start here (data ownership principle)
- No forced abstractions until user creates collections
- Direct access to markdown files

**Tab Behavior:**
- Tabs do not interact with each other
- Each maintains independent context
- No forced tab switching
- **Tab visibility:** Views tab hidden until first collection created
- **Minimal tab design** with + button to add more available tabs

### Tab Management
**Progressive Tab Visibility:**
- **Files & Data:** Always visible (default)
- **Views:** Appears after first collection created
- **Config:** Always available
- **Additional tabs:** Can be added via + button (minimal design)

### Workspace/Staging Implementation

**Location:** Below tabs in navigation (persistent across all tabs)
```
┌─────────────────────────────┐
│ [Files & Data] [Views] [Config] │
├─────────────────────────────┤
│ 🔧 Workspace (3) ▼         │ ← Always visible
│   📌 project-notes.md      │ ← Pinned files
│   📌 Health collection     │ ← Pinned collections  
│   📝 New draft (pending)   │ ← Pending review
├─────────────────────────────┤
│ Files ▼                    │
│   notes/                   │
│   projects/                │
├─────────────────────────────┤
│ Quick Capture              │
└─────────────────────────────┘
```

**Workspace Features:**
- **Drag expandable interface**
- **Unlimited general items**, 5 pinned items maximum
- **Header with collapse button**
- **Two subsections:**
  - Global Pending (review items)
  - Workspace (pinned items)
- **Persistent across sessions**
- **Saved workspace support** (implemented as Collections)

**Adding to Workspace:**
- **Drag & drop** from any tab
- **Right-click** context menu "Pin to workspace"
- **Pin button** on files/collections

## Tab Specifications

### Files & Data Tab (Default)

**Sidebar:**
- Workspace section (persistent)
- Files tree (expandable, all markdown content)
- Quick capture (bottom, persistent)

**Main Area Default:** Split editor/preview OR editor/graph
- Left: Markdown editor
- Right: Rendered preview OR graph view
- **Graph view option:** Click nodes to view, option to navigate
- **Tabbed split editor:** Can switch between preview/graph in right pane
- **User preference options:**
  - Card view + editor
  - Graph view + editor  
  - Tabbed main area (editor/preview/graph)

**New User Experience:**
- Welcome note in editor
- Preview showing rendered result
- Guide/onboarding content in preview pane

### Views Tab
**Appears after:** User creates first collection
**Contains:**
- Today view
- Collections (Health, Work, Finance, etc.)
- Goals and routines
- Custom filters

**Collection Click Behavior:**
- Opens customizable dashboard/workspace for that collection
- Shows filtered list of Events/Items related to that collection
- Customizable layouts (future: define dashboard layout options)

**Collection Creation:**
- **In-context creation** in Views tab (not modal)
- **Filter creator component** appears below existing collections
- **Template-first approach** - Start with premade templates (Health, Work, Custom)
- **Filter hierarchy:** Event Types + Item Types (parallel, equal) → Custom Field filters
- **Live preview** shows what would be included as filters are defined
- **Logical progression:** Choose template → Refine types → Add field filters → Save & name

### Config Tab  
**Contains:**
- Event types and custom fields
- Tags management
- System settings
- Import/export tools

## Data Architecture Integration

### Core Data Model
**Parallel Data Types:** Events and Items are equal, parallel data types
- **Events:** Actions, occurrences, tasks, projects, notes
- **Items:** Physical/digital assets, inventory, resources
- **Equal status:** Neither sits above the other - both are first-class citizens
- **Universal linking:** Events and Items can link to each other freely

### File-to-Event Relationship
**Principle:** Every Event/Item has corresponding markdown file

**Implementation:**
- User creates Event in structured editor → markdown file auto-generated
- User edits markdown file → structured data extracted and stored
- Templates created in markdown → available in structured forms
- **Bidirectional sync** maintains both representations

**User Understanding:**
- Files & Data tab = raw data ownership
- Views tab = structured interface
- Both views represent same underlying data

**Key Point:** All markdown goes in Files & Data tab for data ownership. When users create Events in structured editor, system automatically creates markdown file AND captures structured data for database storage.

### Workspace Management

**Saved Workspaces:**
- Implemented as special Collections
- Can be tagged, filtered, shared
- Leverage existing architecture
- User can switch between: "Project Alpha", "Health Review", "Weekly Planning"

**Workspace Types:**
- **General items:** Unlimited
- **Pinned items:** Maximum 5
- **Workspace saving:** Optional feature for power users

**Adding to Workspace:**
- **Drag & drop** from any tab
- **Right-click** context menu "Pin to workspace"
- **Pin button** on files/collections

## Progressive Disclosure Pattern

**Level 1 (New Users):**
- Only Files & Data tab visible
- Direct file editing interface
- Workspace for pending review items

**Level 2 (Collections Created):**
- Views tab appears
- Can still default to Files & Data
- Workspace supports pinned collections

**Level 3 (Power Users):**
- All tabs available
- Can set Views as default
- Complex workspace management
- Multiple saved workspaces

## Design Principles

### Data Ownership First
- Files & Data tab prioritized over abstractions
- All content exportable as markdown
- User controls file organization
- Raw data always accessible

### Persistent Workspace
- Reduces navigation friction
- Maintains "mental desktop" concept
- Works across all tabs consistently
- Saves user's working context

### User Preference Support
- Customizable default tab
- Configurable main area layout
- Personal workspace organization
- Flexible interface adaptation

### Bidirectional Data Flow
- Markdown files ↔ Structured data
- Templates in markdown format
- Full account regeneration from files possible
- User can view/modify at any level

## Implementation Notes

### Quick Capture
- **Location:** Bottom of sidebar (persistent)
- **Behavior:** Always visible, never blocked
- **Expansion:** 1-5 line textarea, grows upward as needed
- **Context:** Draft text maintained across navigation
- **Future features:** NLP parsing, smart suggestions (not current priority)

### Search Strategy
- **Primary:** Global search across all content
- **Local prioritization:** Current tab/collection content appears first in results
- **Context awareness:** When in Health collection, health-related items rank higher
- **Universal access:** Search works from any tab or context

### Mobile Strategy
- **Navigation:** Hamburger menu contains tabs and workspace
- **Workspace adaptation:** Consider "Recent/Pinned" section optimized for mobile
- **Responsive design:** Desktop workspace may need mobile-specific treatment

### File Organization
- **Primary:** Tags + bidirectional links (flat structure)
- **Optional:** Manual folders (like Obsidian)
- **Display:** Tree shows both folder hierarchy AND tag filtering

### Default States
- **App open:** Files & Data tab
- **New user:** Welcome note in editor, preview on right
- **Empty selection:** Editor with guide content
- **Session persistence:** Remembers last active tab and workspace contents

### View Modes & Persistence
**Available Views:** List, Timeline, Kanban, Card (context-specific)
**View Controls:** Located wherever different view types are available
**View Persistence:** Each context remembers its preferred view mode
**Contextual Availability:** Some locations may have one view, others all views

### Performance & Scale Considerations
**Large datasets:** Pagination with preloaded next page
**List rendering:** Virtualized lists for 1000+ items
**Collection management:** Efficient handling of dozens of collections
**Search optimization:** Fast global search with local prioritization

### Accessibility & Power User Features
**Keyboard shortcuts:** Planned for tab switching, quick capture focus, workspace pinning
**Import/Migration:** Support for external data conversion to system syntax
**Template library:** Premade templates for collections, Event Types, Item Types, custom fields
**Field library:** Reusable custom field definitions

## Development Notes

### Implementation Priority
1. **Tab structure** (foundation for everything)
2. **Workspace positioning** (persistent navigation element)  
3. **Files & Data default behavior** (editor/preview/graph setup)
4. **Collection dashboard framework** (customizable layouts)
5. **Filter creator component** (template-first approach)
6. **Search implementation** (global with local prioritization)

### Future Implementation
- **Mobile responsive design** (hamburger navigation)
- **Keyboard shortcuts** (power user accessibility)
- **Performance optimizations** (virtualization, pagination)
- **Import/export tools** (data migration support)

---

*This specification captures all finalized UI/UX decisions made during design discussions. Updates should be made here as interface evolves.*



# Documentation Plan & Autodocumentation Guide
*A comprehensive strategy for maintaining living documentation throughout development*

## Documentation Philosophy

**Core Principle**: Documentation should be **automatic**, **contextual**, and **living** - updating as the code evolves without requiring separate maintenance effort.

**Target Audiences**:
- **Future You** - Understanding decisions and architecture 6 months later
- **Team Members** - Onboarding and collaboration
- **Users** - API usage and feature understanding
- **Stakeholders** - Architecture decisions and progress

---

## 1. Code Documentation (Automatic)

### JSDoc Setup for JavaScript Modules

**Purpose**: Auto-document your ViewModels, Models, and core logic

**Installation**:
```bash
npm install -g jsdoc
npm install --save-dev jsdoc-to-markdown
```

**Configuration** (`jsdoc.json`):
```json
{
  "source": {
    "include": ["./src/"],
    "includePattern": "\\.(js|jsx)$",
    "excludePattern": "node_modules/"
  },
  "opts": {
    "destination": "./docs/api/",
    "recurse": true
  },
  "plugins": ["plugins/markdown"],
  "templates": {
    "cleverLinks": false,
    "monospaceLinks": false
  }
}
```

**Usage Pattern** (in your existing code):
```javascript
/**
 * Creates a new event with validation and automatic markdown file generation
 * @class EventViewModel
 * @description Manages event creation, validation, and database operations
 * following the Universal Field System architecture
 */
class EventViewModel {
    /**
     * Creates a new event with bidirectional sync to markdown
     * @param {Object} eventData - Event data following custom field schema
     * @param {string} eventData.title - Event title (required)
     * @param {string} eventData.content - Event content (required)
     * @param {number} eventData.event_type_id - Reference to custom event type
     * @param {Object} eventData.custom_fields - Dynamic fields based on event type
     * @returns {Promise<Event>} Created event with auto-generated file_path
     * @throws {Error} When title/content missing or validation fails
     * @example
     * const event = await eventVM.createEvent({
     *   title: "Doctor Appointment",
     *   content: "Annual checkup",
     *   event_type_id: 2,
     *   custom_fields: { location: "Downtown Clinic", cost: 150 }
     * });
     */
    async createEvent(eventData) {
        // Implementation here
    }
}
```

**Auto-generation Commands**:
```bash
# Generate HTML documentation
jsdoc -c jsdoc.json

# Generate markdown for README inclusion
jsdoc2md "src/**/*.js" > docs/api/API.md

# Watch mode during development
jsdoc -c jsdoc.json --watch
```

### TypeScript-style Documentation (Enhanced JSDoc)

**Enhanced type checking without TypeScript**:
```javascript
/**
 * @typedef {Object} CustomField
 * @property {string} name - Field name matching field library
 * @property {string} type - text|number|date|select|multiselect
 * @property {*} value - Field value matching the type
 * @property {boolean} required - Whether field is required
 */

/**
 * @typedef {Object} EventType
 * @property {number} id - Unique identifier
 * @property {string} name - Display name for event type
 * @property {CustomField[]} custom_fields - Array of custom field definitions
 * @property {string} template - Markdown template for auto-generation
 */
```

---

## 2. Architecture Documentation (Visual + Text)

### Mermaid Diagrams in Markdown

**Purpose**: Keep visual documentation in sync with your existing markdown specs

**Installation** (VS Code):
- Install "Mermaid Preview" extension
- Diagrams render in GitHub/GitLab automatically

**Usage in your existing docs**:

**Database Relationships** (`docs/architecture/DATABASE_RELATIONSHIPS.md`):
```markdown
## Entity Relationship Diagram

```mermaid
erDiagram
    EVENTS ||--o{ EVENT_TAGS : "has"
    ITEMS ||--o{ ITEM_TAGS : "has"
    EVENTS }o--|| EVENT_TYPES : "belongs_to"
    ITEMS }o--|| ITEM_TYPES : "belongs_to"
    EVENT_TYPES ||--o{ CUSTOM_FIELDS : "defines"
    ITEM_TYPES ||--o{ CUSTOM_FIELDS : "defines"
    EVENTS ||--o{ LINKS : "from"
    EVENTS ||--o{ LINKS : "to"
    ITEMS ||--o{ LINKS : "from"
    ITEMS ||--o{ LINKS : "to"
```

**UI Component Hierarchy** (`docs/architecture/UI_COMPONENTS.md`):
```mermaid
graph TD
    A[App.js] --> B[MainView]
    B --> C[EventsTab]
    B --> D[VaultTab]
    B --> E[TemplatesTab]
    
    C --> F[EventList]
    C --> G[EventCard]
    C --> H[FilterBar]
    
    D --> I[CollectionDashboard]
    D --> J[TagManager]
    
    E --> K[EventTypeBuilder]
    E --> L[FieldLibrary]
```

**Data Flow Architecture**:
```mermaid
sequenceDiagram
    participant U as User
    participant V as ViewModel
    participant M as Model
    participant D as Database
    participant F as FileSystem
    
    U->>V: Create Event
    V->>M: Validate Data
    M->>D: Store Structured Data
    M->>F: Generate Markdown File
    F-->>V: File Path
    V-->>U: Success + File Reference
```

### Auto-generated Architecture Docs

**Dependency Analysis**:
```bash
npm install -g madge

# Generate dependency graphs
madge --image deps.png src/
madge --circular src/  # Find circular dependencies
madge --summary src/   # Generate summary stats
```

**File Structure Documentation**:
```bash
# Auto-generate file tree documentation
tree src/ > docs/architecture/FILE_STRUCTURE.md

# Or with descriptions
find src/ -name "*.js" -exec echo "## {}" \; -exec head -5 {} \; > docs/api/MODULE_OVERVIEW.md
```

---

## 3. Database Documentation (Schema + Examples)

### Auto-generated Schema Documentation

**SQL Schema Documentation** (add to your existing db.js):
```javascript
/**
 * Database Schema Documentation
 * Auto-generated from Dexie schema definitions
 */
class DatabaseDocumenter {
    static generateSchemaDocs() {
        const schemas = {};
        
        Object.keys(db._allTables).forEach(tableName => {
            const table = db[tableName];
            schemas[tableName] = {
                primaryKey: table.schema.primKey.name,
                indexes: table.schema.indexes.map(idx => idx.name),
                relationships: this.findRelationships(tableName)
            };
        });
        
        return schemas;
    }
    
    static async generateSampleData() {
        // Generate example data for documentation
        const examples = {};
        
        for (let tableName of Object.keys(db._allTables)) {
            const sample = await db[tableName].limit(1).toArray();
            if (sample.length > 0) {
                examples[tableName] = sample[0];
            }
        }
        
        return examples;
    }
}
```

**Usage**:
```javascript
// In your development console or test file
const schemaDocs = DatabaseDocumenter.generateSchemaDocs();
const examples = await DatabaseDocumenter.generateSampleData();

console.log('Schema Documentation:', JSON.stringify(schemaDocs, null, 2));
console.log('Example Data:', JSON.stringify(examples, null, 2));
```

### Query Documentation

**Document your common queries** (in existing ViewModels):
```javascript
/**
 * Collection Query Language (CQL) Examples
 * Auto-documented from actual implementation
 */
class QueryDocumenter {
    /**
     * Get events by collection filter
     * @example
     * // Health collection: events with health tags due this week
     * const healthEvents = await this.getEventsByCollection({
     *   tags: ['health', 'medical'],
     *   due_date: { '>=': startOfWeek, '<=': endOfWeek },
     *   priority: { '>=': 3 }
     * });
     */
    async getEventsByCollection(filter) {
        // Your implementation
    }
}
```

---

## 4. Real-time Documentation (As You Code)

### VS Code Extensions Setup

**Install these extensions**:
```json
{
  "recommendations": [
    "aaron-bond.better-comments",
    "mintlify.document",
    "streetsidesoftware.code-spell-checker",
    "bierner.markdown-mermaid",
    "shd101wyy.markdown-preview-enhanced"
  ]
}
```

**Better Comments Configuration** (`.vscode/settings.json`):
```json
{
  "better-comments.tags": [
    {
      "tag": "!",
      "color": "#FF2D00",
      "strikethrough": false,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    },
    {
      "tag": "?",
      "color": "#3498DB",
      "strikethrough": false,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    },
    {
      "tag": "//",
      "color": "#474747",
      "strikethrough": true,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    },
    {
      "tag": "TODO",
      "color": "#FF8C00",
      "strikethrough": false,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    },
    {
      "tag": "FIXME",
      "color": "#FF2D00",
      "strikethrough": false,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    },
    {
      "tag": "ARCH",
      "color": "#9b59b6",
      "strikethrough": false,
      "underline": false,
      "backgroundColor": "transparent",
      "bold": false,
      "italic": false
    }
  ]
}
```

**Usage in your code**:
```javascript
// ! CRITICAL: This affects bidirectional sync between markdown and database
// ? QUESTION: Should we validate custom fields here or in the model?
// TODO: Add support for nested custom fields in Universal Field System
// FIXME: Memory leak when disposing event listeners
// ARCH: Following the Data Ownership First principle from UI_UX_SPECIFICATION.md

class EventViewModel {
    // Your implementation
}
```

### Automated TODO/FIXME Tracking

**Create a script** (`scripts/extract-todos.js`):
```javascript
const fs = require('fs');
const path = require('path');

function extractTodos(dir) {
    const todos = [];
    
    function scanFile(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
            const match = line.match(/(TODO|FIXME|ARCH|QUESTION):\s*(.*)/);
            if (match) {
                todos.push({
                    type: match[1],
                    message: match[2],
                    file: filePath,
                    line: index + 1,
                    context: line.trim()
                });
            }
        });
    }
    
    function scanDirectory(dirPath) {
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
                scanDirectory(fullPath);
            } else if (item.endsWith('.js') || item.endsWith('.md')) {
                scanFile(fullPath);
            }
        }
    }
    
    scanDirectory(dir);
    return todos;
}

// Generate TODO documentation
const todos = extractTodos('./src');
const markdown = generateTodoMarkdown(todos);
fs.writeFileSync('./docs/development/TODOS.md', markdown);

function generateTodoMarkdown(todos) {
    let md = '# Development TODOs\n\n';
    
    const grouped = todos.reduce((acc, todo) => {
        if (!acc[todo.type]) acc[todo.type] = [];
        acc[todo.type].push(todo);
        return acc;
    }, {});
    
    Object.entries(grouped).forEach(([type, items]) => {
        md += `## ${type}\n\n`;
        items.forEach(item => {
            md += `- **${item.file}:${item.line}** - ${item.message}\n`;
        });
        md += '\n';
    });
    
    return md;
}
```

**Add to package.json**:
```json
{
  "scripts": {
    "docs:todos": "node scripts/extract-todos.js",
    "docs:generate": "npm run docs:todos && jsdoc -c jsdoc.json"
  }
}
```

---

## 5. Project Documentation (High-level)

### Automated README Generation

**Template** (`.readme/template.md`):
```markdown
# {{name}}
{{description}}

## Architecture Overview

{{architecture_summary}}

## Quick Start

{{quick_start}}

## API Documentation

{{api_links}}

## Development Status

Last updated: {{date}}
Total TODOs: {{todo_count}}
Test Coverage: {{coverage}}

## Recent Changes

{{changelog}}
```

**Generation Script** (`scripts/generate-readme.js`):
```javascript
const fs = require('fs');
const { execSync } = require('child_process');

function generateReadme() {
    const packageJson = JSON.parse(fs.readFileSync('./package.json'));
    const todos = require('./extract-todos')('./src');
    
    const template = fs.readFileSync('./.readme/template.md', 'utf8');
    
    const replacements = {
        name: packageJson.name,
        description: packageJson.description,
        date: new Date().toISOString().split('T')[0],
        todo_count: todos.length,
        architecture_summary: generateArchSummary(),
        api_links: generateApiLinks(),
        quick_start: generateQuickStart(),
        changelog: generateChangelog()
    };
    
    let readme = template;
    Object.entries(replacements).forEach(([key, value]) => {
        readme = readme.replace(new RegExp(`{{${key}}}`, 'g'), value);
    });
    
    fs.writeFileSync('./README.md', readme);
}
```

### Changelog Automation

**Using conventional commits**:
```bash
npm install -g conventional-changelog-cli

# Generate changelog from commit messages
conventional-changelog -p angular -i CHANGELOG.md -s

# Or auto-generate from git tags
git-changelog --tag=$(git describe --tags --abbrev=0)
```

### Progress Tracking

**Feature completion script** (`scripts/track-progress.js`):
```javascript
function trackProgress() {
    const features = extractFeaturesFromSpecs();
    const implemented = checkImplementationStatus();
    
    const progress = features.map(feature => ({
        name: feature.name,
        status: implemented.includes(feature.name) ? '✅' : '⏳',
        description: feature.description
    }));
    
    generateProgressReport(progress);
}
```

---

## 6. Integration & Automation

### Git Hooks for Auto-documentation

**Pre-commit hook** (`.husky/pre-commit`):
```bash
#!/bin/sh
# Auto-generate documentation before commit

npm run docs:generate
git add docs/

# Update README if package.json changed
if git diff --cached --name-only | grep -q "package.json"; then
    npm run docs:readme
    git add README.md
fi
```

### CI/CD Documentation Updates

**GitHub Actions** (`.github/workflows/docs.yml`):
```yaml
name: Update Documentation

on:
  push:
    branches: [main]

jobs:
  docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
          
      - name: Install dependencies
        run: npm install
        
      - name: Generate documentation
        run: |
          npm run docs:generate
          npm run docs:todos
          npm run docs:readme
          
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
```

### Documentation Health Checks

**Validation script** (`scripts/validate-docs.js`):
```javascript
function validateDocumentation() {
    const checks = [
        checkAPIDocCoverage(),
        checkMarkdownLinks(),
        checkCodeExamples(),
        checkArchitectureAlignment()
    ];
    
    const failed = checks.filter(check => !check.passed);
    
    if (failed.length > 0) {
        console.log('Documentation issues found:');
        failed.forEach(check => console.log(`- ${check.error}`));
        process.exit(1);
    }
}
```

---

## 7. Documentation Workflow

### Daily Development Workflow

1. **Code with intention comments**:
   ```javascript
   // ARCH: Implementing Universal Field System pattern
   // TODO: Add validation for nested custom fields
   ```

2. **Auto-generate docs on commit**:
   ```bash
   git commit -m "feat: add custom field validation"
   # Hook automatically updates JSDoc and TODOs
   ```

3. **Weekly review**:
   ```bash
   npm run docs:validate  # Check documentation health
   npm run docs:todos     # Review outstanding TODOs
   ```

### Architecture Decision Records (ADRs)

**Template** (`docs/architecture/adr/template.md`):
```markdown
# ADR-XXX: [Title]

Date: YYYY-MM-DD
Status: Proposed | Accepted | Deprecated | Superseded

## Context
What is the issue that we're seeing that is motivating this decision or change?

## Decision
What is the change that we're proposing or have agreed to implement?

## Consequences
What becomes easier or more difficult to do and any risks introduced by the change that will need to be mitigated.

## Implementation Notes
Technical details about how this will be implemented.

## References
- Links to related discussions, code, or specifications
```

### Documentation Review Process

**Before major releases**:
1. Run `npm run docs:validate`
2. Review and close completed TODOs
3. Update architecture diagrams if data model changed
4. Generate fresh API documentation
5. Update README with new features

---

## 8. Tools Summary

| Category | Tool | Purpose | Automation Level |
|----------|------|---------|------------------|
| **Code** | JSDoc | API documentation | High |
| **Code** | Better Comments | Intention tracking | Real-time |
| **Architecture** | Mermaid | Visual diagrams | Manual |
| **Database** | Custom scripts | Schema docs | Medium |
| **Project** | Conventional commits | Changelog | High |
| **Validation** | Custom scripts | Doc health | High |
| **Dependencies** | Madge | Architecture analysis | High |

## Getting Started

1. **Install core tools**:
   ```bash
   npm install -g jsdoc conventional-changelog-cli madge
   ```

2. **Set up VS Code extensions** (from recommendations above)

3. **Add scripts to package.json**:
   ```json
   {
     "scripts": {
       "docs:generate": "jsdoc -c jsdoc.json",
       "docs:todos": "node scripts/extract-todos.js",
       "docs:validate": "node scripts/validate-docs.js",
       "docs:readme": "node scripts/generate-readme.js"
     }
   }
   ```

4. **Start documenting with intention**:
   - Add JSDoc to your existing ViewModels
   - Use Better Comments for architecture notes
   - Add Mermaid diagrams to your existing specs

This documentation system will grow with your project, automatically capturing your architectural decisions and keeping your docs current as you develop.





# Development Guide v4.0
**Organizational Ecosystem Application - Complete Developer Documentation**

---

## Table of Contents

1. [Getting Started](#getting-started)
2. [Architecture Overview](#architecture-overview)
3. [Project Structure](#project-structure)
4. [Database Development](#database-development)
5. [MVVM Implementation Patterns](#mvvm-implementation-patterns)
6. [Universal Systems Development](#universal-systems-development)
7. [Performance Optimization](#performance-optimization)
8. [UI Development Guidelines](#ui-development-guidelines)
9. [Testing Strategy](#testing-strategy)
10. [API Development](#api-development)
11. [File Synchronization](#file-synchronization)
12. [Security Implementation](#security-implementation)
13. [Deployment Guide](#deployment-guide)
14. [Contributing Guidelines](#contributing-guidelines)
15. [Troubleshooting](#troubleshooting)

---

## Getting Started

### Prerequisites

```bash
# Required
Node.js 18+ 
npm 9+
Git 2.0+

# Recommended for development
VS Code with extensions:
- JavaScript/TypeScript support
- IndexedDB Explorer
- REST Client
- Git integration
```

### Quick Setup

```bash
# Clone the repository
git clone https://github.com/your-org/organizational-ecosystem.git
cd organizational-ecosystem

# Install dependencies
npm install

# Start development server
npm run dev

# Open in browser
open http://localhost:3000
```

### Development Dependencies

```json
{
  "dependencies": {
    "dexie": "^3.2.4",
    "date-fns": "^2.30.0"
  },
  "devDependencies": {
    "serve": "^14.2.1",
    "eslint": "^8.45.0",
    "jest": "^29.6.1",
    "@types/jest": "^29.5.3",
    "live-server": "^1.2.2"
  }
}
```

### Environment Setup

```bash
# Create development environment file
cp .env.example .env.development

# Configure development settings
cat > .env.development << EOF
NODE_ENV=development
APP_NAME=Organizational Ecosystem
VERSION=4.0.0
DEBUG=true

# Database
DB_NAME=org_ecosystem_dev
DB_VERSION=1

# File Sync
SYNC_ENABLED=true
SYNC_DIRECTORY=./sync-files

# Performance
ENABLE_PERFORMANCE_MONITORING=true
LOG_LEVEL=debug
EOF
```

---

## Architecture Overview

### Core Philosophy

**Everything is either an Event (verb) or an Item (noun).** This fundamental principle drives all architectural decisions and simplifies the entire system.

```javascript
// Core abstraction
class Entity {
  static getType(data) {
    return data.involves_action ? 'event' : 'item';
  }
}

// Examples
"Buy groceries" → Event (action)
"MacBook Pro" → Item (thing)
"Meeting with team" → Event (action)
"Conference room" → Item (thing)
```

### System Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     USER INTERFACE                         │
├─────────────────────────────────────────────────────────────┤
│  Events Tab    │    Vault Tab    │    Templates Tab       │
│  - Quick Input │  - Collections  │  - Event Types         │
│  - Event List  │  - Tags        │  - Field Library       │
│  - Calendar    │  - Relationships│  - Content Templates   │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                    VIEWMODEL LAYER                         │
├─────────────────────────────────────────────────────────────┤
│  EventViewModel  │  ItemViewModel  │  CollectionViewModel   │
│  - State Mgmt    │  - Inventory    │  - Dynamic Filtering   │
│  - Validation    │  - Tracking     │  - Real-time Updates   │
│  - Offline Queue │  - Sync Status  │  - Conflict Resolution │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                     MODEL LAYER                            │
├─────────────────────────────────────────────────────────────┤
│    Event Model   │   Item Model    │   Universal Models     │
│    - Local CRUD  │   - Local CRUD  │   - Tag Model          │
│    - Sync Logic  │   - Sync Logic  │   - Link Model         │
│    - Conflict    │   - Conflict    │   - Collection Model   │
│    - Resolution  │   - Resolution  │   - Sync Queue Model   │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│              INTELLIGENT SYNC LAYER                        │
├─────────────────────────────────────────────────────────────┤
│  Bidirectional Sync │ Conflict Resolution │ Offline Queue   │
│  - Push changes     │ - Server wins       │ - CREATE ops    │
│  - Pull updates     │ - Client wins       │ - UPDATE ops    │
│  - Delta sync       │ - Smart merge       │ - DELETE ops    │
│  - Real-time        │ - Manual resolution │ - Retry logic   │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                CLIENT DATABASE LAYER                       │
├─────────────────────────────────────────────────────────────┤
│                IndexedDB Cache (10K records)               │
│  - Recent events (last 30 days)                            │
│  - Starred/pinned items                                     │
│  - Active projects and collections                          │
│  - 18 tables (mirrors server schema exactly)               │
│  Performance: 1-10ms queries, complete offline capability  │
└─────────────────────────────────────────────────────────────┘
                               ▲ ▼ Bidirectional Sync
┌─────────────────────────────────────────────────────────────┐
│               SERVER DATABASE LAYER                        │
├─────────────────────────────────────────────────────────────┤
│              PostgreSQL + JSONB (Unlimited)                │
│  - Full dataset with enterprise performance                │
│  - Real columns + JSONB custom fields                      │
│  - Advanced search and analytics                           │
│  - Multi-user collaboration with row-level security        │
│  - 18 tables (identical to client)                         │
│  Performance: 10-100ms queries, unlimited scale            │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                   API SERVER LAYER                         │
├─────────────────────────────────────────────────────────────┤
│  Node.js + Express RESTful API                             │
│  - Authentication & Authorization                           │
│  - JSONB query optimization                                │
│  - Real-time updates (WebSocket)                           │
│  - Rate limiting & security                                │
│  Performance: Enterprise-grade with multi-user support     │
└─────────────────────────────────────────────────────────────┘
```

### Technology Stack

```javascript
// Complete hybrid technology stack
const techStack = {
  // Client Development (Offline-First)
  frontend: {
    language: 'Vanilla JavaScript ES2022',
    architecture: 'MVVM (Model-View-ViewModel)',
    database: 'IndexedDB + Dexie.js (intelligent cache)',
    performance: 'Strategic compound indexes',
    offline: 'Complete functionality without server'
  },
  
  // Server Development (Unlimited Scale)
  backend: {
    language: 'Node.js + JavaScript',
    framework: 'Express.js RESTful API', 
    database: 'PostgreSQL + JSONB (primary storage)',
    authentication: 'JWT with row-level security',
    realtime: 'WebSocket for live updates',
    performance: '10-100ms queries with 1M+ records'
  },
  
  // Synchronization Layer
  sync: {
    strategy: 'Bidirectional intelligent sync',
    conflicts: 'Real-time conflict resolution',
    offline: 'Modification queue with retry logic',
    caching: '10K most relevant records locally'
  },
  
  // Development Environment
  development: {
    client: 'Live-server for IndexedDB development',
    server: 'Docker PostgreSQL + Express API',
    testing: 'Jest + integration test suites',
    debugging: 'IndexedDB inspector + PostgreSQL logs'
  },
  
  // Deployment
  production: {
    containerization: 'Docker + Docker Compose',
    database: 'PostgreSQL with optimized indexes',
    api: 'Node.js with PM2 process management',
    scaling: 'Horizontal scaling ready'
  }
};
```

---

## Project Structure

### Directory Organization

```
organizational-ecosystem/
├── docs/                          # Documentation
│   ├── FEATURE_MATRIX.md          # Complete feature specification
│   ├── DATABASE_SCHEMA.md         # Database design
│   ├── SYSTEM_ARCHITECTURE.md     # System architecture
│   └── API_REFERENCE.md           # API documentation
│
├── src/                           # Source code
│   ├── database/                  # Database layer
│   │   ├── schema.js              # Database schema definition
│   │   ├── connection.js          # IndexedDB connection
│   │   └── migrations.js          # Schema migrations
│   │
│   ├── models/                    # Data access layer
│   │   ├── base/                  
│   │   │   ├── BaseModel.js       # Abstract base model
│   │   │   ├── BaseEntity.js      # Event/Item base class
│   │   │   └── QueryBuilder.js    # Query construction
│   │   ├── Event.js               # Event model
│   │   ├── Item.js                # Item model
│   │   ├── Tag.js                 # Tag model
│   │   ├── Collection.js          # Collection model
│   │   ├── EventType.js           # Event type model
│   │   ├── ItemType.js            # Item type model
│   │   ├── FieldDefinition.js     # Field library model
│   │   └── Link.js                # Relationship model
│   │
│   ├── viewmodels/                # Business logic layer
│   │   ├── base/
│   │   │   ├── BaseViewModel.js   # Abstract base viewmodel
│   │   │   └── ObservableState.js # Reactive state management
│   │   ├── MainViewModel.js       # Primary application state
│   │   ├── EventViewModel.js      # Event management logic
│   │   ├── ItemViewModel.js       # Item management logic
│   │   ├── CollectionViewModel.js # Collection filtering logic
│   │   ├── QuickCaptureViewModel.js # Input parsing logic
│   │   └── WorkspaceViewModel.js  # UI state management
│   │
│   ├── views/                     # UI layer (future)
│   │   ├── components/
│   │   ├── pages/
│   │   └── templates/
│   │
│   ├── utils/                     # Utility functions
│   │   ├── dateUtils.js           # Date parsing and formatting
│   │   ├── stringUtils.js         # Text processing utilities
│   │   ├── validationUtils.js     # Input validation
│   │   ├── performanceUtils.js    # Performance monitoring
│   │   └── templateEngine.js      # Template variable substitution
│   │
│   ├── sync/                      # File synchronization (future)
│   │   ├── FileSync.js
│   │   ├── ConflictResolver.js
│   │   └── MarkdownParser.js
│   │
│   └── app.js                     # Application entry point
│
├── public/                        # Static assets
│   ├── index.html                 # Main HTML file
│   ├── styles/
│   │   ├── main.css               # Main stylesheet
│   │   ├── components.css         # Component styles
│   │   └── themes/                # Theme files
│   └── assets/
│       ├── icons/                 # Icon files
│       └── images/                # Image assets
│
├── tests/                         # Test files
│   ├── unit/                      # Unit tests
│   │   ├── models/
│   │   ├── viewmodels/
│   │   └── utils/
│   ├── integration/               # Integration tests
│   ├── e2e/                       # End-to-end tests
│   └── fixtures/                  # Test data
│
├── scripts/                       # Build and utility scripts
│   ├── setup-dev.js               # Development setup
│   ├── migrate-schema.js          # Database migrations
│   ├── seed-data.js               # Sample data generation
│   └── performance-test.js        # Performance benchmarking
│
├── config/                        # Configuration files
│   ├── database.js                # Database configuration
│   ├── performance.js             # Performance settings
│   └── sync.js                    # File sync configuration
│
├── package.json                   # Dependencies and scripts
├── README.md                      # Project overview
├── .env.example                   # Environment variables template
├── .gitignore                     # Git ignore rules
└── CHANGELOG.md                   # Version history
```

### File Naming Conventions

```javascript
// Models: PascalCase with descriptive names
Event.js, Item.js, EventType.js, FieldDefinition.js

// ViewModels: PascalCase ending with ViewModel
MainViewModel.js, EventViewModel.js, CollectionViewModel.js

// Utilities: camelCase ending with Utils
dateUtils.js, stringUtils.js, validationUtils.js

// Components: PascalCase ending with Component (future)
EventListComponent.js, QuickCaptureComponent.js

// Constants: UPPER_SNAKE_CASE
DATABASE_CONFIG.js, FIELD_TYPES.js, QUERY_OPERATORS.js
```

---

## Database Development

### IndexedDB Schema Setup

```javascript
// src/database/schema.js
import Dexie from 'dexie';

class OrganizationalDatabase extends Dexie {
  constructor() {
    super('OrganizationalEcosystem');
    
    // Define schema version 1.0
    this.version(1).stores({
      // Core entities
      users: 'user_id, username, email, workspace_config, view_preferences',
      events: 'event_id, user_id, event_type_id, title, priority, budget, location, due_date, status, custom_fields',
      items: 'item_id, user_id, item_type_id, name, quantity, value, location, status, custom_fields',
      
      // Type system
      event_types: 'event_type_id, user_id, name, content_template, available_variables',
      item_types: 'item_type_id, user_id, name, category, tracks_quantity',
      
      // Universal field system
      field_definitions: 'field_id, field_name, field_type, validation_schema, category',
      entity_fields: '[entity_type+entity_id+field_id], entity_type, entity_id, field_id, sequence_order',
      
      // Universal systems
      tags: 'tag_id, user_id, name, color',
      tag_assignments: '[taggable_type+taggable_id+tag_id], tag_id, taggable_type, taggable_id',
      links: 'link_id, from_type, from_id, to_type, to_id, relationship_type',
      
      // Organization
      collections: 'collection_id, user_id, name, filter_config, view_config',
      lists: 'list_id, user_id, title, is_ordered',
      list_items: 'list_item_id, list_id, text_content, linked_type, linked_id, sequence_order',
      
      // Advanced features
      routines: 'routine_id, user_id, title, event_type_id, schedule_pattern',
      routine_event_instances: 'instance_id, routine_id, event_id, scheduled_date',
      
      // File sync
      entity_files: 'id, entity_type, entity_id, file_path, sync_status',
      
      // Infrastructure
      operation_logs: 'log_id, user_id, operation_type, entity_type, entity_id, timestamp',
      deleted_entities: 'deletion_id, entity_type, entity_id, entity_data, deleted_at'
    });
    
    // Performance indexes
    this.events.hook('ready', () => {
      // Compound indexes for performance
      this.events.toCollection().primaryKeys().then(keys => {
        console.log(`Events table ready with ${keys.length} records`);
      });
    });
  }
}

export const db = new OrganizationalDatabase();
```

### Database Migration System

```javascript
// src/database/migrations.js
class MigrationManager {
  static migrations = [
    {
      version: 1,
      description: 'Initial schema',
      up: async (db) => {
        // Initial schema is defined in constructor
        console.log('Initial schema created');
      }
    },
    {
      version: 2,
      description: 'Add performance columns to events',
      up: async (db) => {
        // Migration will be handled by Dexie version upgrade
        await db.events.toCollection().modify(event => {
          // Migrate custom_fields data to real columns
          if (event.custom_fields?.priority) {
            event.priority = event.custom_fields.priority;
          }
          if (event.custom_fields?.budget) {
            event.budget = event.custom_fields.budget;
          }
          if (event.custom_fields?.location) {
            event.location = event.custom_fields.location;
          }
        });
      }
    }
  ];
  
  static async runMigrations() {
    const currentVersion = await this.getCurrentVersion();
    const pendingMigrations = this.migrations.filter(m => m.version > currentVersion);
    
    for (const migration of pendingMigrations) {
      console.log(`Running migration ${migration.version}: ${migration.description}`);
      await migration.up(db);
      await this.updateVersion(migration.version);
    }
  }
  
  static async getCurrentVersion() {
    try {
      const versionData = await db.operation_logs
        .where('operation_type')
        .equals('MIGRATION')
        .last();
      return versionData?.metadata?.version || 0;
    } catch {
      return 0;
    }
  }
  
  static async updateVersion(version) {
    await db.operation_logs.add({
      operation_type: 'MIGRATION',
      metadata: { version, timestamp: new Date().toISOString() },
      timestamp: new Date()
    });
  }
}

export { MigrationManager };
```

### Query Patterns

```javascript
// src/models/base/QueryBuilder.js
class QueryBuilder {
  constructor(table) {
    this.table = table;
    this.query = table.toCollection();
  }
  
  // Performance-optimized user filtering
  byUser(userId) {
    this.query = this.table.where('user_id').equals(userId);
    return this;
  }
  
  // Real column filtering (10x faster than JSONB)
  byPriority(minPriority) {
    this.query = this.query.and(item => item.priority >= minPriority);
    return this;
  }
  
  // Date range filtering
  dueBetween(startDate, endDate) {
    this.query = this.query.and(item => 
      item.due_date >= startDate && item.due_date <= endDate
    );
    return this;
  }
  
  // JSONB custom field filtering
  byCustomField(fieldName, value) {
    this.query = this.query.and(item => 
      item.custom_fields?.[fieldName] === value
    );
    return this;
  }
  
  // Tag filtering (polymorphic)
  withTags(tagNames) {
    return this.query.and(async (item) => {
      const assignments = await db.tag_assignments
        .where('[taggable_type+taggable_id]')
        .equals([this.table.name.slice(0, -1), item[`${this.table.name.slice(0, -1)}_id`]])
        .toArray();
      
      const itemTagIds = assignments.map(a => a.tag_id);
      const itemTags = await db.tags.where('tag_id').anyOf(itemTagIds).toArray();
      const itemTagNames = itemTags.map(t => t.name);
      
      return tagNames.some(tagName => itemTagNames.includes(tagName));
    });
  }
  
  // Execute query with pagination
  async paginate(offset = 0, limit = 50) {
    return this.query.offset(offset).limit(limit).toArray();
  }
  
  // Execute query and get count
  async count() {
    return this.query.count();
  }
}

// Usage example
const highPriorityWorkEvents = await new QueryBuilder(db.events)
  .byUser(currentUserId)
  .byPriority(4)
  .withTags(['work'])
  .dueBetween(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000))
  .paginate(0, 25);
```

---

## MVVM Implementation Patterns

### Base Model Pattern

```javascript
// src/models/base/BaseModel.js
class BaseModel {
  constructor(tableName, primaryKey) {
    this.table = db[tableName];
    this.primaryKey = primaryKey;
    this.tableName = tableName;
  }
  
  // Standard CRUD operations
  async create(data) {
    const now = new Date();
    const record = {
      ...data,
      created_at: now,
      updated_at: now
    };
    
    const id = await this.table.add(record);
    await this.logOperation('CREATE', id, null, record);
    return await this.findById(id);
  }
  
  async findById(id) {
    return await this.table.get(id);
  }
  
  async update(id, data) {
    const oldRecord = await this.findById(id);
    const updatedData = {
      ...data,
      updated_at: new Date()
    };
    
    await this.table.update(id, updatedData);
    await this.logOperation('UPDATE', id, oldRecord, updatedData);
    return await this.findById(id);
  }
  
  async delete(id) {
    const record = await this.findById(id);
    
    // Soft delete - move to deleted_entities
    await db.deleted_entities.add({
      entity_type: this.tableName.slice(0, -1), // Remove 's' from table name
      entity_id: id,
      entity_data: record,
      deleted_by: await this.getCurrentUserId(),
      deleted_at: new Date(),
      deletion_reason: 'User initiated'
    });
    
    await this.table.delete(id);
    await this.logOperation('DELETE', id, record, null);
  }
  
  // Query builder
  query() {
    return new QueryBuilder(this.table);
  }
  
  // Audit logging
  async logOperation(operationType, entityId, oldValues, newValues) {
    await db.operation_logs.add({
      user_id: await this.getCurrentUserId(),
      operation_type: operationType,
      entity_type: this.tableName.slice(0, -1),
      entity_id: entityId,
      old_values: oldValues,
      new_values: newValues,
      timestamp: new Date()
    });
  }
  
  async getCurrentUserId() {
    // Implementation depends on auth system
    return 1; // Default user for now
  }
}

export { BaseModel };
```

### Event Model Implementation

```javascript
// src/models/Event.js
import { BaseModel } from './base/BaseModel.js';

class EventModel extends BaseModel {
  constructor() {
    super('events', 'event_id');
  }
  
  // Performance-optimized queries using real columns
  async findByPriorityAndDueDate(userId, minPriority, startDate, endDate) {
    return this.table
      .where('user_id').equals(userId)
      .and(event => event.priority >= minPriority)
      .and(event => event.due_date >= startDate && event.due_date <= endDate)
      .toArray();
  }
  
  async findByLocation(userId, location) {
    return this.table
      .where('user_id').equals(userId)
      .and(event => event.location === location)
      .toArray();
  }
  
  // Custom field queries (JSONB)
  async findByCustomField(userId, fieldName, value) {
    return this.table
      .where('user_id').equals(userId)
      .and(event => event.custom_fields?.[fieldName] === value)
      .toArray();
  }
  
  // Complex relationship queries
  async findWithRelationships(eventId, relationshipType = null) {
    const event = await this.findById(eventId);
    if (!event) return null;
    
    let relationships = db.links.where('from_type').equals('event').and(link => link.from_id === eventId);
    
    if (relationshipType) {
      relationships = relationships.and(link => link.relationship_type === relationshipType);
    }
    
    const links = await relationships.toArray();
    
    // Load related entities
    const relatedEvents = [];
    const relatedItems = [];
    
    for (const link of links) {
      if (link.to_type === 'event') {
        const relatedEvent = await db.events.get(link.to_id);
        if (relatedEvent) {
          relatedEvents.push({ ...relatedEvent, relationship: link.relationship_type });
        }
      } else if (link.to_type === 'item') {
        const relatedItem = await db.items.get(link.to_id);
        if (relatedItem) {
          relatedItems.push({ ...relatedItem, relationship: link.relationship_type });
        }
      }
    }
    
    return {
      ...event,
      related_events: relatedEvents,
      related_items: relatedItems
    };
  }
  
  // Tag-based queries
  async findByTags(userId, tagNames) {
    const events = await this.table.where('user_id').equals(userId).toArray();
    const eventsWithTags = [];
    
    for (const event of events) {
      const assignments = await db.tag_assignments
        .where('[taggable_type+taggable_id]')
        .equals(['event', event.event_id])
        .toArray();
      
      if (assignments.length > 0) {
        const tagIds = assignments.map(a => a.tag_id);
        const tags = await db.tags.where('tag_id').anyOf(tagIds).toArray();
        const eventTagNames = tags.map(t => t.name);
        
        if (tagNames.some(tagName => eventTagNames.includes(tagName))) {
          eventsWithTags.push({
            ...event,
            tags: tags
          });
        }
      }
    }
    
    return eventsWithTags;
  }
  
  // Collection query execution
  async executeCollectionQuery(collectionConfig) {
    const { entity_type, conditions, sort } = collectionConfig;
    
    if (entity_type && entity_type !== 'event') {
      return [];
    }
    
    let query = this.table.toCollection();
    
    // Apply conditions
    if (conditions) {
      query = await this.applyConditions(query, conditions);
    }
    
    let results = await query.toArray();
    
    // Apply sorting
    if (sort && sort.length > 0) {
      results.sort((a, b) => {
        for (const sortRule of sort) {
          const { field, direction } = sortRule;
          let aVal = this.getFieldValue(a, field);
          let bVal = this.getFieldValue(b, field);
          
          if (aVal < bVal) return direction === 'asc' ? -1 : 1;
          if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        }
        return 0;
      });
    }
    
    return results;
  }
  
  async applyConditions(query, conditions) {
    const { operator, rules } = conditions;
    
    if (operator === 'AND') {
      for (const rule of rules) {
        query = query.and(event => this.evaluateRule(event, rule));
      }
    } else if (operator === 'OR') {
      // For OR conditions, we need to evaluate all rules and combine results
      const results = [];
      for (const rule of rules) {
        const ruleResults = await this.table.toCollection()
          .and(event => this.evaluateRule(event, rule))
          .toArray();
        results.push(...ruleResults);
      }
      
      // Remove duplicates
      const uniqueResults = results.filter((event, index, self) =>
        index === self.findIndex(e => e.event_id === event.event_id)
      );
      
      // Convert back to query-like object
      return {
        toArray: async () => uniqueResults
      };
    }
    
    return query;
  }
  
  evaluateRule(event, rule) {
    const { field, operator, value } = rule;
    const fieldValue = this.getFieldValue(event, field);
    
    switch (operator) {
      case 'equals':
        return fieldValue === value;
      case 'not_equals':
        return fieldValue !== value;
      case 'greater_than':
        return fieldValue > value;
      case 'less_than':
        return fieldValue < value;
      case 'greater_than_or_equal':
        return fieldValue >= value;
      case 'less_than_or_equal':
        return fieldValue <= value;
      case 'contains':
        return String(fieldValue).toLowerCase().includes(String(value).toLowerCase());
      case 'starts_with':
        return String(fieldValue).toLowerCase().startsWith(String(value).toLowerCase());
      case 'ends_with':
        return String(fieldValue).toLowerCase().endsWith(String(value).toLowerCase());
      case 'in':
        return Array.isArray(value) && value.includes(fieldValue);
      case 'not_in':
        return Array.isArray(value) && !value.includes(fieldValue);
      case 'date_between':
        return fieldValue >= new Date(value[0]) && fieldValue <= new Date(value[1]);
      default:
        return true;
    }
  }
  
  getFieldValue(event, fieldPath) {
    if (fieldPath.includes('.')) {
      const parts = fieldPath.split('.');
      let value = event;
      for (const part of parts) {
        value = value?.[part];
      }
      return value;
    }
    return event[fieldPath];
  }
}

export const Event = new EventModel();
```

### ViewModel Pattern

```javascript
// src/viewmodels/base/BaseViewModel.js
class BaseViewModel {
  constructor() {
    this.state = new ObservableState();
    this.subscriptions = new Set();
  }
  
  // Subscribe to state changes
  subscribe(callback) {
    this.subscriptions.add(callback);
    return () => this.subscriptions.delete(callback);
  }
  
  // Notify subscribers of state changes
  notify(change) {
    this.subscriptions.forEach(callback => callback(change));
  }
  
  // Cleanup resources
  dispose() {
    this.subscriptions.clear();
  }
}

// src/viewmodels/base/ObservableState.js
class ObservableState {
  constructor(initialState = {}) {
    this._state = initialState;
    this._subscribers = new Set();
  }
  
  get(key) {
    return this._state[key];
  }
  
  set(key, value) {
    const oldValue = this._state[key];
    this._state[key] = value;
    
    this._notify({
      type: 'SET',
      key,
      oldValue,
      newValue: value
    });
  }
  
  update(updates) {
    const oldState = { ...this._state };
    Object.assign(this._state, updates);
    
    this._notify({
      type: 'UPDATE',
      oldState,
      newState: { ...this._state },
      updates
    });
  }
  
  subscribe(callback) {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
  
  _notify(change) {
    this._subscribers.forEach(callback => callback(change));
  }
}

export { BaseViewModel, ObservableState };
```

### Event ViewModel Implementation

```javascript
// src/viewmodels/EventViewModel.js
import { BaseViewModel } from './base/BaseViewModel.js';
import { Event } from '../models/Event.js';
import { EventType } from '../models/EventType.js';

class EventViewModel extends BaseViewModel {
  constructor() {
    super();
    
    this.state.update({
      events: [],
      selectedEvent: null,
      loading: false,
      error: null,
      filters: {
        search: '',
        priority: null,
        due_date_range: null,
        tags: [],
        status: 'active'
      },
      pagination: {
        page: 0,
        pageSize: 50,
        total: 0
      }
    });
  }
  
  // Load events with current filters
  async loadEvents() {
    this.state.set('loading', true);
    this.state.set('error', null);
    
    try {
      const userId = await this.getCurrentUserId();
      const { filters, pagination } = this.state._state;
      
      // Build query based on filters
      let query = Event.query().byUser(userId);
      
      // Apply filters
      if (filters.priority) {
        query = query.byPriority(filters.priority);
      }
      
      if (filters.due_date_range) {
        query = query.dueBetween(filters.due_date_range.start, filters.due_date_range.end);
      }
      
      if (filters.tags.length > 0) {
        query = query.withTags(filters.tags);
      }
      
      if (filters.search) {
        query = query.and(event => 
          event.title.toLowerCase().includes(filters.search.toLowerCase()) ||
          event.description?.toLowerCase().includes(filters.search.toLowerCase())
        );
      }
      
      // Execute query with pagination
      const events = await query.paginate(
        pagination.page * pagination.pageSize,
        pagination.pageSize
      );
      
      const total = await query.count();
      
      this.state.update({
        events,
        pagination: { ...pagination, total },
        loading: false
      });
      
      this.notify({ type: 'EVENTS_LOADED', events, total });
      
    } catch (error) {
      this.state.update({
        error: error.message,
        loading: false
      });
      
      this.notify({ type: 'ERROR', error });
    }
  }
  
  // Create new event
  async createEvent(eventData) {
    try {
      // Validate event data
      const validation = await this.validateEventData(eventData);
      if (!validation.valid) {
        throw new Error(validation.errors.join(', '));
      }
      
      // Create event
      const event = await Event.create({
        user_id: await this.getCurrentUserId(),
        ...eventData
      });
      
      // Add to current events list
      const events = this.state.get('events');
      this.state.set('events', [event, ...events]);
      
      this.notify({ type: 'EVENT_CREATED', event });
      
      return event;
      
    } catch (error) {
      this.state.set('error', error.message);
      this.notify({ type: 'ERROR', error });
      throw error;
    }
  }
  
  // Update existing event
  async updateEvent(eventId, updates) {
    try {
      const validation = await this.validateEventData(updates, eventId);
      if (!validation.valid) {
        throw new Error(validation.errors.join(', '));
      }
      
      const updatedEvent = await Event.update(eventId, updates);
      
      // Update in events list
      const events = this.state.get('events');
      const updatedEvents = events.map(event => 
        event.event_id === eventId ? updatedEvent : event
      );
      
      this.state.set('events', updatedEvents);
      
      // Update selected event if it's the one being updated
      if (this.state.get('selectedEvent')?.event_id === eventId) {
        this.state.set('selectedEvent', updatedEvent);
      }
      
      this.notify({ type: 'EVENT_UPDATED', event: updatedEvent });
      
      return updatedEvent;
      
    } catch (error) {
      this.state.set('error', error.message);
      this.notify({ type: 'ERROR', error });
      throw error;
    }
  }
  
  // Delete event
  async deleteEvent(eventId) {
    try {
      await Event.delete(eventId);
      
      // Remove from events list
      const events = this.state.get('events');
      const filteredEvents = events.filter(event => event.event_id !== eventId);
      this.state.set('events', filteredEvents);
      
      // Clear selected event if it was deleted
      if (this.state.get('selectedEvent')?.event_id === eventId) {
        this.state.set('selectedEvent', null);
      }
      
      this.notify({ type: 'EVENT_DELETED', eventId });
      
    } catch (error) {
      this.state.set('error', error.message);
      this.notify({ type: 'ERROR', error });
      throw error;
    }
  }
  
  // Validate event data
  async validateEventData(data, eventId = null) {
    const errors = [];
    
    // Required fields
    if (!data.title || data.title.trim().length === 0) {
      errors.push('Title is required');
    }
    
    if (data.title && data.title.length > 255) {
      errors.push('Title must be 255 characters or less');
    }
    
    // Priority validation
    if (data.priority !== undefined) {
      if (!Number.isInteger(data.priority) || data.priority < 1 || data.priority > 5) {
        errors.push('Priority must be an integer between 1 and 5');
      }
    }
    
    // Budget validation
    if (data.budget !== undefined) {
      if (typeof data.budget !== 'number' || data.budget < 0) {
        errors.push('Budget must be a non-negative number');
      }
    }
    
    // Due date validation
    if (data.due_date !== undefined) {
      if (!(data.due_date instanceof Date) && isNaN(new Date(data.due_date))) {
        errors.push('Due date must be a valid date');
      }
    }
    
    // Event type validation
    if (data.event_type_id) {
      const eventType = await EventType.findById(data.event_type_id);
      if (!eventType) {
        errors.push('Invalid event type');
      } else {
        // Validate custom fields against event type schema
        const fieldValidation = await this.validateCustomFields(data.custom_fields, eventType);
        errors.push(...fieldValidation.errors);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  // Validate custom fields against event type schema
  async validateCustomFields(customFields = {}, eventType) {
    const errors = [];
    
    // Get required fields for this event type
    const entityFields = await db.entity_fields
      .where('[entity_type+entity_id]')
      .equals(['event_type', eventType.event_type_id])
      .toArray();
    
    for (const entityField of entityFields) {
      const fieldDef = await db.field_definitions.get(entityField.field_id);
      const fieldValue = customFields[fieldDef.field_name];
      
      // Check required fields
      if (entityField.is_required && (fieldValue === undefined || fieldValue === null || fieldValue === '')) {
        errors.push(`${entityField.display_name || fieldDef.display_name} is required`);
        continue;
      }
      
      // Validate field type and schema
      if (fieldValue !== undefined && fieldValue !== null) {
        const validation = this.validateFieldValue(fieldValue, fieldDef);
        if (!validation.valid) {
          errors.push(`${entityField.display_name || fieldDef.display_name}: ${validation.error}`);
        }
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  validateFieldValue(value, fieldDef) {
    const { field_type, validation_schema } = fieldDef;
    
    switch (field_type) {
      case 'text':
        if (typeof value !== 'string') return { valid: false, error: 'Must be text' };
        if (validation_schema.maxLength && value.length > validation_schema.maxLength) {
          return { valid: false, error: `Must be ${validation_schema.maxLength} characters or less` };
        }
        break;
        
      case 'number':
        if (typeof value !== 'number') return { valid: false, error: 'Must be a number' };
        if (validation_schema.min && value < validation_schema.min) {
          return { valid: false, error: `Must be at least ${validation_schema.min}` };
        }
        if (validation_schema.max && value > validation_schema.max) {
          return { valid: false, error: `Must be no more than ${validation_schema.max}` };
        }
        break;
        
      case 'date':
        if (!(value instanceof Date) && isNaN(new Date(value))) {
          return { valid: false, error: 'Must be a valid date' };
        }
        break;
        
      case 'select':
        if (validation_schema.options) {
          const validValues = validation_schema.options.map(opt => opt.value);
          if (!validValues.includes(value)) {
            return { valid: false, error: 'Must be one of the allowed options' };
          }
        }
        break;
        
      case 'currency':
        if (typeof value !== 'number' || value < 0) {
          return { valid: false, error: 'Must be a non-negative amount' };
        }
        break;
    }
    
    return { valid: true };
  }
  
  // Filter and search methods
  setFilter(filterName, value) {
    const filters = { ...this.state.get('filters') };
    filters[filterName] = value;
    this.state.set('filters', filters);
    
    // Reload events with new filters
    this.loadEvents();
  }
  
  clearFilters() {
    this.state.set('filters', {
      search: '',
      priority: null,
      due_date_range: null,
      tags: [],
      status: 'active'
    });
    
    this.loadEvents();
  }
  
  // Pagination
  nextPage() {
    const pagination = this.state.get('pagination');
    if ((pagination.page + 1) * pagination.pageSize < pagination.total) {
      this.state.set('pagination', {
        ...pagination,
        page: pagination.page + 1
      });
      this.loadEvents();
    }
  }
  
  previousPage() {
    const pagination = this.state.get('pagination');
    if (pagination.page > 0) {
      this.state.set('pagination', {
        ...pagination,
        page: pagination.page - 1
      });
      this.loadEvents();
    }
  }
  
  async getCurrentUserId() {
    // Implementation depends on auth system
    return 1; // Default user for now
  }
}

export { EventViewModel };
```

---

## Universal Systems Development

### Tag System Implementation

```javascript
// src/models/Tag.js
import { BaseModel } from './base/BaseModel.js';

class TagModel extends BaseModel {
  constructor() {
    super('tags', 'tag_id');
  }
  
  // Find or create tag by name
  async findOrCreate(userId, tagName, color = '#95a5a6') {
    const existing = await this.table
      .where('[user_id+name]')
      .equals([userId, tagName])
      .first();
    
    if (existing) {
      return existing;
    }
    
    return await this.create({
      user_id: userId,
      name: tagName,
      color: color
    });
  }
  
  // Get all tags for user with usage counts
  async findByUserWithCounts(userId) {
    const tags = await this.table.where('user_id').equals(userId).toArray();
    const tagsWithCounts = [];
    
    for (const tag of tags) {
      const usageCount = await db.tag_assignments
        .where('tag_id')
        .equals(tag.tag_id)
        .count();
      
      tagsWithCounts.push({
        ...tag,
        usage_count: usageCount
      });
    }
    
    return tagsWithCounts.sort((a, b) => b.usage_count - a.usage_count);
  }
  
  // Find entities by tag
  async findEntitiesByTag(tagId) {
    const assignments = await db.tag_assignments
      .where('tag_id')
      .equals(tagId)
      .toArray();
    
    const entities = { events: [], items: [] };
    
    for (const assignment of assignments) {
      if (assignment.taggable_type === 'event') {
        const event = await db.events.get(assignment.taggable_id);
        if (event) entities.events.push(event);
      } else if (assignment.taggable_type === 'item') {
        const item = await db.items.get(assignment.taggable_id);
        if (item) entities.items.push(item);
      }
    }
    
    return entities;
  }
}

export const Tag = new TagModel();
```

### Tag Assignment System

```javascript
// src/models/TagAssignment.js
class TagAssignmentModel {
  constructor() {
    this.table = db.tag_assignments;
  }
  
  // Assign tag to entity
  async assign(tagId, entityType, entityId) {
    try {
      await this.table.add({
        tag_id: tagId,
        taggable_type: entityType,
        taggable_id: entityId,
        created_at: new Date()
      });
    } catch (error) {
      // Handle duplicate key error (tag already assigned)
      if (error.name === 'ConstraintError') {
        return; // Already assigned, no action needed
      }
      throw error;
    }
  }
  
  // Remove tag from entity
  async unassign(tagId, entityType, entityId) {
    await this.table
      .where('[tag_id+taggable_type+taggable_id]')
      .equals([tagId, entityType, entityId])
      .delete();
  }
  
  // Get all tags for entity
  async getTagsForEntity(entityType, entityId) {
    const assignments = await this.table
      .where('[taggable_type+taggable_id]')
      .equals([entityType, entityId])
      .toArray();
    
    const tagIds = assignments.map(a => a.tag_id);
    return await db.tags.where('tag_id').anyOf(tagIds).toArray();
  }
  
  // Bulk assign tags from string array
  async assignTagsFromNames(userId, entityType, entityId, tagNames) {
    const assignments = [];
    
    for (const tagName of tagNames) {
      const tag = await Tag.findOrCreate(userId, tagName);
      assignments.push({
        tag_id: tag.tag_id,
        taggable_type: entityType,
        taggable_id: entityId
      });
    }
    
    // Remove existing assignments
    await this.table
      .where('[taggable_type+taggable_id]')
      .equals([entityType, entityId])
      .delete();
    
    // Add new assignments
    await this.table.bulkAdd(assignments);
  }
  
  // Extract hashtags from text and assign
  async extractAndAssignHashtags(userId, entityType, entityId, text) {
    const hashtagRegex = /#([a-zA-Z0-9_]+)/g;
    const hashtags = [];
    let match;
    
    while ((match = hashtagRegex.exec(text)) !== null) {
      hashtags.push(match[1].toLowerCase());
    }
    
    if (hashtags.length > 0) {
      await this.assignTagsFromNames(userId, entityType, entityId, hashtags);
    }
    
    return hashtags;
  }
}

export const TagAssignment = new TagAssignmentModel();
```

### Quick Capture System

```javascript
// src/viewmodels/QuickCaptureViewModel.js
import { BaseViewModel } from './base/BaseViewModel.js';
import { Event } from '../models/Event.js';
import { Item } from '../models/Item.js';
import { TagAssignment } from '../models/TagAssignment.js';
import { parseDate, parseCurrency, parseLocation } from '../utils/parseUtils.js';

class QuickCaptureViewModel extends BaseViewModel {
  constructor() {
    super();
    
    this.state.update({
      input: '',
      parsing: false,
      preview: null,
      suggestions: []
    });
  }
  
  // Parse input and show preview
  async parseInput(input) {
    this.state.set('parsing', true);
    this.state.set('input', input);
    
    try {
      const parsed = await this.analyzeInput(input);
      this.state.set('preview', parsed);
      this.notify({ type: 'INPUT_PARSED', parsed });
    } catch (error) {
      this.state.set('error', error.message);
    } finally {
      this.state.set('parsing', false);
    }
  }
  
  // Analyze input and determine entity type and fields
  async analyzeInput(input) {
    const analysis = {
      original_input: input,
      entity_type: this.determineEntityType(input),
      title: '',
      description: '',
      tags: [],
      fields: {},
      confidence: 0
    };
    
    // Extract hashtags
    const hashtagRegex = /#([a-zA-Z0-9_]+)/g;
    const hashtags = [];
    let cleanText = input.replace(hashtagRegex, (match, tag) => {
      hashtags.push(tag.toLowerCase());
      return '';
    }).trim();
    
    analysis.tags = hashtags;
    
    // Extract due date
    const dateResult = parseDate(cleanText);
    if (dateResult.date) {
      analysis.fields.due_date = dateResult.date;
      cleanText = dateResult.remainingText;
    }
    
    // Extract currency/budget
    const currencyResult = parseCurrency(cleanText);
    if (currencyResult.amount) {
      analysis.fields.budget = currencyResult.amount;
      cleanText = currencyResult.remainingText;
    }
    
    // Extract location
    const locationResult = parseLocation(cleanText);
    if (locationResult.location) {
      analysis.fields.location = locationResult.location;
      cleanText = locationResult.remainingText;
    }
    
    // Extract priority
    const priorityMatch = cleanText.match(/priority:(\d+|low|medium|high)/i);
    if (priorityMatch) {
      const priorityValue = priorityMatch[1].toLowerCase();
      analysis.fields.priority = this.parsePriority(priorityValue);
      cleanText = cleanText.replace(priorityMatch[0], '').trim();
    }
    
    // Remaining text becomes title and description
    const words = cleanText.split(' ').filter(word => word.length > 0);
    if (words.length > 0) {
      // First part is title, rest is description
      if (words.length <= 5) {
        analysis.title = words.join(' ');
      } else {
        analysis.title = words.slice(0, 5).join(' ');
        analysis.description = words.slice(5).join(' ');
      }
    }
    
    // Calculate confidence based on extracted information
    analysis.confidence = this.calculateConfidence(analysis);
    
    return analysis;
  }
  
  // Determine if input represents an event or item
  determineEntityType(input) {
    const eventIndicators = [
      'call', 'meet', 'buy', 'do', 'complete', 'finish', 'start',
      'schedule', 'plan', 'review', 'check', 'visit', 'go to',
      'reminder', 'appointment', 'deadline', 'due:'
    ];
    
    const itemIndicators = [
      'book', 'laptop', 'chair', 'desk', 'phone', 'car',
      'tool', 'equipment', 'device', 'machine', 'software',
      'account', 'subscription', 'membership'
    ];
    
    const lowerInput = input.toLowerCase();
    
    const eventScore = eventIndicators.filter(indicator => 
      lowerInput.includes(indicator)
    ).length;
    
    const itemScore = itemIndicators.filter(indicator => 
      lowerInput.includes(indicator)
    ).length;
    
    // Check for action verbs (events) vs nouns (items)
    const hasActionVerb = /^(call|meet|buy|do|complete|finish|start|schedule|plan|review|check|visit|go|create|make|send|write|read|study)/i.test(input);
    
    if (hasActionVerb || eventScore > itemScore) {
      return 'event';
    } else if (itemScore > eventScore) {
      return 'item';
    }
    
    // Default to event for ambiguous cases
    return 'event';
  }
  
  parsePriority(value) {
    if (typeof value === 'number') return Math.max(1, Math.min(5, value));
    
    switch (value.toLowerCase()) {
      case 'low': return 2;
      case 'medium': return 3;
      case 'high': return 4;
      default: return parseInt(value) || 3;
    }
  }
  
  calculateConfidence(analysis) {
    let score = 0;
    
    // Title extracted
    if (analysis.title) score += 30;
    
    // Tags extracted
    if (analysis.tags.length > 0) score += 20;
    
    // Due date extracted
    if (analysis.fields.due_date) score += 20;
    
    // Budget/value extracted
    if (analysis.fields.budget) score += 15;
    
    // Location extracted
    if (analysis.fields.location) score += 10;
    
    // Priority extracted
    if (analysis.fields.priority) score += 5;
    
    return Math.min(100, score);
  }
  
  // Create entity from parsed input
  async createFromParsed(parsed) {
    try {
      const userId = await this.getCurrentUserId();
      
      let entity;
      if (parsed.entity_type === 'event') {
        entity = await Event.create({
          user_id: userId,
          title: parsed.title,
          description: parsed.description || null,
          due_date: parsed.fields.due_date || null,
          priority: parsed.fields.priority || 3,
          budget: parsed.fields.budget || null,
          location: parsed.fields.location || null,
          status: 'active'
        });
      } else {
        entity = await Item.create({
          user_id: userId,
          name: parsed.title,
          description: parsed.description || null,
          value: parsed.fields.budget || null,
          location: parsed.fields.location || null,
          quantity: 1,
          status: 'active'
        });
      }
      
      // Assign tags
      if (parsed.tags.length > 0) {
        await TagAssignment.assignTagsFromNames(
          userId,
          parsed.entity_type,
          entity[`${parsed.entity_type}_id`],
          parsed.tags
        );
      }
      
      this.state.set('input', '');
      this.state.set('preview', null);
      
      this.notify({ 
        type: 'ENTITY_CREATED', 
        entity, 
        entityType: parsed.entity_type 
      });
      
      return entity;
      
    } catch (error) {
      this.state.set('error', error.message);
      this.notify({ type: 'ERROR', error });
      throw error;
    }
  }
  
  async getCurrentUserId() {
    return 1; // Default user for now
  }
}

export { QuickCaptureViewModel };
```

---

## Performance Optimization

### Database Performance

```javascript
// src/utils/performanceUtils.js
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.enabled = process.env.ENABLE_PERFORMANCE_MONITORING === 'true';
  }
  
  // Time database operations
  async timeOperation(operationName, operation) {
    if (!this.enabled) {
      return await operation();
    }
    
    const startTime = performance.now();
    const result = await operation();
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    this.recordMetric(operationName, duration);
    
    if (duration > 100) { // Log slow operations
      console.warn(`Slow operation: ${operationName} took ${duration.toFixed(2)}ms`);
    }
    
    return result;
  }
  
  recordMetric(name, value) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    const values = this.metrics.get(name);
    values.push({
      value,
      timestamp: new Date()
    });
    
    // Keep only last 100 measurements
    if (values.length > 100) {
      values.shift();
    }
  }
  
  getMetrics(name) {
    const values = this.metrics.get(name) || [];
    if (values.length === 0) return null;
    
    const durations = values.map(v => v.value);
    return {
      count: durations.length,
      average: durations.reduce((a, b) => a + b, 0) / durations.length,
      min: Math.min(...durations),
      max: Math.max(...durations),
      latest: durations[durations.length - 1]
    };
  }
  
  getAllMetrics() {
    const result = {};
    for (const [name, values] of this.metrics) {
      result[name] = this.getMetrics(name);
    }
    return result;
  }
}

export const performanceMonitor = new PerformanceMonitor();

// Usage in models
class OptimizedEventModel extends BaseModel {
  async findByPriority(userId, minPriority) {
    return performanceMonitor.timeOperation('event_find_by_priority', async () => {
      return this.table
        .where('user_id').equals(userId)
        .and(event => event.priority >= minPriority)
        .toArray();
    });
  }
}
```

### Query Optimization Patterns

```javascript
// src/models/base/OptimizedQueries.js
class OptimizedQueries {
  // Use real columns for common filters (10x faster)
  static async findEventsByCommonCriteria(userId, criteria) {
    let query = db.events.where('user_id').equals(userId);
    
    // Priority filter (real column - very fast)
    if (criteria.minPriority) {
      query = query.and(event => event.priority >= criteria.minPriority);
    }
    
    // Due date range (real column - very fast)
    if (criteria.dueDateRange) {
      query = query.and(event => 
        event.due_date >= criteria.dueDateRange.start &&
        event.due_date <= criteria.dueDateRange.end
      );
    }
    
    // Location filter (real column - very fast)
    if (criteria.location) {
      query = query.and(event => event.location === criteria.location);
    }
    
    // Budget range (real column - very fast)
    if (criteria.budgetRange) {
      query = query.and(event => 
        event.budget >= criteria.budgetRange.min &&
        event.budget <= criteria.budgetRange.max
      );
    }
    
    // Status filter (real column - very fast)
    if (criteria.status) {
      query = query.and(event => event.status === criteria.status);
    }
    
    return query.toArray();
  }
  
  // Use JSONB only when necessary (slower but flexible)
  static async findEventsByCustomFields(userId, customCriteria) {
    return db.events
      .where('user_id').equals(userId)
      .and(event => {
        for (const [field, value] of Object.entries(customCriteria)) {
          if (event.custom_fields?.[field] !== value) {
            return false;
          }
        }
        return true;
      })
      .toArray();
  }
  
  // Combine real columns with JSONB for optimal performance
  static async findEventsOptimized(userId, criteria) {
    // First filter by real columns (fast)
    let events = await this.findEventsByCommonCriteria(userId, criteria);
    
    // Then filter by custom fields if needed (slower, but on smaller dataset)
    if (criteria.customFields && Object.keys(criteria.customFields).length > 0) {
      events = events.filter(event => {
        for (const [field, value] of Object.entries(criteria.customFields)) {
          if (event.custom_fields?.[field] !== value) {
            return false;
          }
        }
        return true;
      });
    }
    
    return events;
  }
  
  // Optimized tag queries
  static async findEventsByTags(userId, tagNames) {
    // Get tag IDs first
    const tags = await db.tags
      .where('user_id').equals(userId)
      .and(tag => tagNames.includes(tag.name))
      .toArray();
    
    const tagIds = tags.map(t => t.tag_id);
    
    if (tagIds.length === 0) return [];
    
    // Get tagged event IDs
    const assignments = await db.tag_assignments
      .where('tag_id').anyOf(tagIds)
      .and(assignment => assignment.taggable_type === 'event')
      .toArray();
    
    const eventIds = [...new Set(assignments.map(a => a.taggable_id))];
    
    // Get events by IDs (fast)
    return db.events
      .where('event_id').anyOf(eventIds)
      .and(event => event.user_id === userId)
      .toArray();
  }
}

export { OptimizedQueries };
```

### Memory Management

```javascript
// src/utils/memoryManager.js
class MemoryManager {
  constructor() {
    this.cache = new Map();
    this.maxCacheSize = 1000;
    this.cleanupInterval = 5 * 60 * 1000; // 5 minutes
    
    // Periodic cleanup
    setInterval(() => this.cleanup(), this.cleanupInterval);
  }
  
  // Intelligent caching for frequently accessed data
  async getCachedOrFetch(key, fetchFunction, ttl = 5 * 60 * 1000) {
    const cached = this.cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.data;
    }
    
    const data = await fetchFunction();
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
    
    return data;
  }
  
  // Cache event types (rarely change)
  async getEventTypes(userId) {
    return this.getCachedOrFetch(
      `event_types_${userId}`,
      () => db.event_types.where('user_id').equals(userId).toArray(),
      15 * 60 * 1000 // 15 minutes
    );
  }
  
  // Cache field definitions (rarely change)
  async getFieldDefinitions() {
    return this.getCachedOrFetch(
      'field_definitions',
      () => db.field_definitions.toArray(),
      30 * 60 * 1000 // 30 minutes
    );
  }
  
  // Cache user preferences (moderate change frequency)
  async getUserPreferences(userId) {
    return this.getCachedOrFetch(
      `user_preferences_${userId}`,
      () => db.users.get(userId),
      5 * 60 * 1000 // 5 minutes
    );
  }
  
  // Invalidate cache when data changes
  invalidate(pattern) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
  
  // Cleanup expired entries
  cleanup() {
    const now = Date.now();
    for (const [key, cached] of this.cache.entries()) {
      if (now - cached.timestamp > cached.ttl) {
        this.cache.delete(key);
      }
    }
    
    // Limit cache size
    if (this.cache.size > this.maxCacheSize) {
      const entries = Array.from(this.cache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      const toDelete = entries.slice(0, this.cache.size - this.maxCacheSize);
      for (const [key] of toDelete) {
        this.cache.delete(key);
      }
    }
  }
  
  // Get memory usage statistics
  getStats() {
    return {
      cacheSize: this.cache.size,
      maxCacheSize: this.maxCacheSize,
      memoryUsage: this.estimateMemoryUsage()
    };
  }
  
  estimateMemoryUsage() {
    let totalSize = 0;
    for (const cached of this.cache.values()) {
      totalSize += JSON.stringify(cached.data).length;
    }
    return totalSize;
  }
}

export const memoryManager = new MemoryManager();
```

---

## UI Development Guidelines

### Component Architecture (Future)

```javascript
// src/views/components/base/BaseComponent.js
class BaseComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.state = {};
    this.subscriptions = new Set();
  }
  
  connectedCallback() {
    this.render();
    this.bindEvents();
  }
  
  disconnectedCallback() {
    this.cleanup();
  }
  
  // State management
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.render();
  }
  
  // Event binding
  bindEvents() {
    // Override in subclasses
  }
  
  // Cleanup
  cleanup() {
    this.subscriptions.forEach(unsubscribe => unsubscribe());
    this.subscriptions.clear();
  }
  
  // Rendering
  render() {
    this.shadowRoot.innerHTML = `
      <style>${this.getStyles()}</style>
      ${this.getTemplate()}
    `;
  }
  
  getStyles() {
    return ''; // Override in subclasses
  }
  
  getTemplate() {
    return ''; // Override in subclasses
  }
  
  // ViewModel integration
  connectToViewModel(viewModel) {
    const unsubscribe = viewModel.subscribe((change) => {
      this.onViewModelChange(change);
    });
    this.subscriptions.add(unsubscribe);
  }
  
  onViewModelChange(change) {
    // Override in subclasses
  }
}

// Example component
class EventListComponent extends BaseComponent {
  constructor() {
    super();
    this.state = {
      events: [],
      loading: false,
      selectedEvent: null
    };
  }
  
  connectedCallback() {
    super.connectedCallback();
    
    // Connect to EventViewModel
    this.connectToViewModel(window.app.eventViewModel);
  }
  
  onViewModelChange(change) {
    switch (change.type) {
      case 'EVENTS_LOADED':
        this.setState({ 
          events: change.events,
          loading: false 
        });
        break;
        
      case 'EVENT_CREATED':
        this.setState({
          events: [change.event, ...this.state.events]
        });
        break;
        
      case 'EVENT_UPDATED':
        this.setState({
          events: this.state.events.map(event =>
            event.event_id === change.event.event_id ? change.event : event
          )
        });
        break;
    }
  }
  
  bindEvents() {
    this.shadowRoot.addEventListener('click', (e) => {
      if (e.target.classList.contains('event-item')) {
        const eventId = parseInt(e.target.dataset.eventId);
        this.selectEvent(eventId);
      }
    });
  }
  
  selectEvent(eventId) {
    const event = this.state.events.find(e => e.event_id === eventId);
    this.setState({ selectedEvent: event });
    
    this.dispatchEvent(new CustomEvent('event-selected', {
      detail: { event },
      bubbles: true
    }));
  }
  
  getTemplate() {
    if (this.state.loading) {
      return '<div class="loading">Loading events...</div>';
    }
    
    return `
      <div class="event-list">
        ${this.state.events.map(event => `
          <div class="event-item" data-event-id="${event.event_id}">
            <div class="event-title">${event.title}</div>
            <div class="event-meta">
              ${event.due_date ? `<span class="due-date">${new Date(event.due_date).toLocaleDateString()}</span>` : ''}
              ${event.priority ? `<span class="priority priority-${event.priority}">P${event.priority}</span>` : ''}
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  getStyles() {
    return `
      .event-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .event-item {
        padding: 12px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .event-item:hover {
        background-color: #f5f5f5;
      }
      
      .event-title {
        font-weight: 500;
        margin-bottom: 4px;
      }
      
      .event-meta {
        display: flex;
        gap: 8px;
        font-size: 0.875rem;
        color: #666;
      }
      
      .priority {
        padding: 2px 6px;
        border-radius: 2px;
        font-size: 0.75rem;
        font-weight: bold;
      }
      
      .priority-1, .priority-2 { background: #e8f5e8; color: #2e7d2e; }
      .priority-3 { background: #fff3cd; color: #856404; }
      .priority-4, .priority-5 { background: #f8d7da; color: #721c24; }
    `;
  }
}

customElements.define('event-list', EventListComponent);
```

### CSS Architecture

```css
/* public/styles/main.css */

/* CSS Custom Properties for Theming */
:root {
  /* Colors */
  --color-primary: #3498db;
  --color-secondary: #2ecc71;
  --color-accent: #e74c3c;
  --color-warning: #f39c12;
  --color-success: #27ae60;
  --color-error: #e74c3c;
  
  /* Grays */
  --color-gray-50: #f8f9fa;
  --color-gray-100: #e9ecef;
  --color-gray-200: #dee2e6;
  --color-gray-300: #ced4da;
  --color-gray-400: #adb5bd;
  --color-gray-500: #6c757d;
  --color-gray-600: #495057;
  --color-gray-700: #343a40;
  --color-gray-800: #212529;
  --color-gray-900: #000000;
  
  /* Typography */
  --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-family-mono: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
  --font-size-3xl: 1.875rem;
  
  /* Spacing */
  --spacing-1: 0.25rem;
  --spacing-2: 0.5rem;
  --spacing-3: 0.75rem;
  --spacing-4: 1rem;
  --spacing-5: 1.25rem;
  --spacing-6: 1.5rem;
  --spacing-8: 2rem;
  --spacing-10: 2.5rem;
  --spacing-12: 3rem;
  
  /* Layout */
  --border-radius: 4px;
  --border-radius-lg: 8px;
  --border-width: 1px;
  --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  --box-shadow-lg: 0 4px 6px rgba(0, 0, 0, 0.1);
  
  /* Animation */
  --transition-fast: 0.15s ease;
  --transition-base: 0.3s ease;
  --transition-slow: 0.5s ease;
}

/* Reset and Base Styles */
*, *::before, *::after {
  box-sizing: border-box;
}

html {
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  padding: 0;
  color: var(--color-gray-800);
  background-color: var(--color-gray-50);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  margin: 0 0 var(--spacing-4) 0;
  font-weight: 600;
  line-height: 1.3;
}

h1 { font-size: var(--font-size-3xl); }
h2 { font-size: var(--font-size-2xl); }
h3 { font-size: var(--font-size-xl); }
h4 { font-size: var(--font-size-lg); }
h5 { font-size: var(--font-size-base); }
h6 { font-size: var(--font-size-sm); }

p {
  margin: 0 0 var(--spacing-4) 0;
}

/* Layout Components */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--spacing-4);
}

.grid {
  display: grid;
  gap: var(--spacing-4);
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-4 {
  gap: var(--spacing-4);
}

/* Form Components */
.form-group {
  margin-bottom: var(--spacing-4);
}

.form-label {
  display: block;
  margin-bottom: var(--spacing-2);
  font-weight: 500;
  color: var(--color-gray-700);
}

.form-input {
  width: 100%;
  padding: var(--spacing-3);
  border: var(--border-width) solid var(--color-gray-300);
  border-radius: var(--border-radius);
  font-size: var(--font-size-base);
  transition: border-color var(--transition-fast);
}

.form-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.form-input:invalid {
  border-color: var(--color-error);
}

/* Button Components */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-3) var(--spacing-4);
  border: var(--border-width) solid transparent;
  border-radius: var(--border-radius);
  font-size: var(--font-size-base);
  font-weight: 500;
  text-decoration: none;
  cursor: pointer;
  transition: all var(--transition-fast);
  user-select: none;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background-color: var(--color-primary);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background-color: #2980b9;
}

.btn-secondary {
  background-color: var(--color-gray-200);
  color: var(--color-gray-800);
}

.btn-secondary:hover:not(:disabled) {
  background-color: var(--color-gray-300);
}

.btn-success {
  background-color: var(--color-success);
  color: white;
}

.btn-danger {
  background-color: var(--color-error);
  color: white;
}

.btn-sm {
  padding: var(--spacing-2) var(--spacing-3);
  font-size: var(--font-size-sm);
}

.btn-lg {
  padding: var(--spacing-4) var(--spacing-6);
  font-size: var(--font-size-lg);
}

/* Card Component */
.card {
  background: white;
  border-radius: var(--border-radius-lg);
  box-shadow: var(--box-shadow);
  overflow: hidden;
}

.card-header {
  padding: var(--spacing-4);
  border-bottom: var(--border-width) solid var(--color-gray-200);
  background-color: var(--color-gray-50);
}

.card-body {
  padding: var(--spacing-4);
}

.card-footer {
  padding: var(--spacing-4);
  border-top: var(--border-width) solid var(--color-gray-200);
  background-color: var(--color-gray-50);
}

/* Utility Classes */
.text-xs { font-size: var(--font-size-xs); }
.text-sm { font-size: var(--font-size-sm); }
.text-lg { font-size: var(--font-size-lg); }
.text-xl { font-size: var(--font-size-xl); }

.text-left { text-align: left; }
.text-center { text-align: center; }
.text-right { text-align: right; }

.font-normal { font-weight: 400; }
.font-medium { font-weight: 500; }
.font-bold { font-weight: 700; }

.text-gray-500 { color: var(--color-gray-500); }
.text-gray-600 { color: var(--color-gray-600); }
.text-gray-700 { color: var(--color-gray-700); }

.bg-white { background-color: white; }
.bg-gray-50 { background-color: var(--color-gray-50); }
.bg-gray-100 { background-color: var(--color-gray-100); }

.border { border: var(--border-width) solid var(--color-gray-300); }
.border-t { border-top: var(--border-width) solid var(--color-gray-300); }
.border-b { border-bottom: var(--border-width) solid var(--color-gray-300); }

.rounded { border-radius: var(--border-radius); }
.rounded-lg { border-radius: var(--border-radius-lg); }

.shadow { box-shadow: var(--box-shadow); }
.shadow-lg { box-shadow: var(--box-shadow-lg); }

.hidden { display: none; }
.block { display: block; }
.inline { display: inline; }
.inline-block { display: inline-block; }

/* Responsive Design */
@media (min-width: 768px) {
  .md\:grid-cols-2 {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .md\:grid-cols-3 {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (min-width: 1024px) {
  .lg\:grid-cols-4 {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* Animation Classes */
.fade-in {
  animation: fadeIn var(--transition-base);
}

.slide-up {
  animation: slideUp var(--transition-base);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Loading States */
.loading {
  position: relative;
  color: transparent;
}

.loading::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border: 2px solid var(--color-gray-300);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
  :root {
    --color-gray-50: #212529;
    --color-gray-100: #343a40;
    --color-gray-200: #495057;
    --color-gray-300: #6c757d;
    --color-gray-800: #f8f9fa;
    --color-gray-900: #ffffff;
  }
  
  body {
    background-color: var(--color-gray-50);
    color: var(--color-gray-800);
  }
  
  .card {
    background-color: var(--color-gray-100);
  }
}
```

### Iconography

- **Icon Set**: The project uses [Tabler Icons](https://tabler-icons.io/), a free and open source icon library. The icons are stored in `public/assets/icons`.
- **Adding New Icons**: To add a new icon, download the SVG file from the Tabler Icons website and place it in the `public/assets/icons` directory. Optimize the SVG using a tool like [SVGOMG](https://jakearchibald.github.io/svgomg/).
- **Usage in HTML**: Icons can be embedded directly into HTML using an `<img>` tag or as a background image in CSS.
- **Usage in JavaScript**: In JavaScript, icons can be dynamically created and added to the DOM. A helper function can be created to streamline this process.

---

## Testing Strategy

### Unit Testing Setup

```javascript
// tests/unit/models/Event.test.js
import { Event } from '../../../src/models/Event.js';
import { db } from '../../../src/database/schema.js';

describe('Event Model', () => {
  beforeEach(async () => {
    // Clear database before each test
    await db.delete();
    await db.open();
    
    // Seed with test user
    await db.users.add({
      user_id: 1,
      username: 'testuser',
      email: 'test@example.com',
      password_hash: 'hashed_password'
    });
  });
  
  afterEach(async () => {
    await db.delete();
  });
  
  describe('create', () => {
    it('should create a new event with required fields', async () => {
      const eventData = {
        user_id: 1,
        title: 'Test Event',
        description: 'Test Description',
        priority: 3,
        status: 'active'
      };
      
      const event = await Event.create(eventData);
      
      expect(event).toMatchObject(eventData);
      expect(event.event_id).toBeDefined();
      expect(event.created_at).toBeInstanceOf(Date);
      expect(event.updated_at).toBeInstanceOf(Date);
    });
    
    it('should log the creation operation', async () => {
      const eventData = {
        user_id: 1,
        title: 'Test Event'
      };
      
      const event = await Event.create(eventData);
      
      const logs = await db.operation_logs
        .where('entity_id')
        .equals(event.event_id)
        .toArray();
      
      expect(logs).toHaveLength(1);
      expect(logs[0].operation_type).toBe('CREATE');
      expect(logs[0].entity_type).toBe('event');
    });
    
    it('should handle performance-optimized queries', async () => {
      // Create test events
      const events = [];
      for (let i = 1; i <= 5; i++) {
        events.push(await Event.create({
          user_id: 1,
          title: `Event ${i}`,
          priority: i,
          budget: i * 100,
          due_date: new Date(Date.now() + i * 24 * 60 * 60 * 1000)
        }));
      }
      
      // Test real column filtering
      const highPriorityEvents = await Event.findByPriorityAndDueDate(
        1,
        4,
        new Date(),
        new Date(Date.now() + 10 * 24 * 60 * 60 * 1000)
      );
      
      expect(highPriorityEvents).toHaveLength(2);
      expect(highPriorityEvents.every(e => e.priority >= 4)).toBe(true);
    });
  });
  
  describe('relationships', () => {
    it('should find events with relationships', async () => {
      // Create events
      const event1 = await Event.create({
        user_id: 1,
        title: 'Main Event'
      });
      
      const event2 = await Event.create({
        user_id: 1,
        title: 'Dependent Event'
      });
      
      // Create relationship
      await db.links.add({
        from_type: 'event',
        from_id: event1.event_id,
        to_type: 'event',
        to_id: event2.event_id,
        relationship_type: 'depends_on'
      });
      
      // Test relationship query
      const eventWithRelationships = await Event.findWithRelationships(event1.event_id);
      
      expect(eventWithRelationships.related_events).toHaveLength(1);
      expect(eventWithRelationships.related_events[0].title).toBe('Dependent Event');
      expect(eventWithRelationships.related_events[0].relationship).toBe('depends_on');
    });
  });
});
```

### Integration Testing

```javascript
// tests/integration/quickCapture.test.js
import { QuickCaptureViewModel } from '../../src/viewmodels/QuickCaptureViewModel.js';
import { Event } from '../../src/models/Event.js';
import { Item } from '../../src/models/Item.js';
import { Tag } from '../../src/models/Tag.js';
import { db } from '../../src/database/schema.js';

describe('Quick Capture Integration', () => {
  let quickCapture;
  
  beforeEach(async () => {
    await db.delete();
    await db.open();
    
    // Seed test user
    await db.users.add({
      user_id: 1,
      username: 'testuser',
      email: 'test@example.com'
    });
    
    quickCapture = new QuickCaptureViewModel();
  });
  
  afterEach(async () => {
    quickCapture.dispose();
    await db.delete();
  });
  
  it('should parse and create event from natural language input', async () => {
    const input = 'Call John about project #work #urgent due:tomorrow $50 @office';
    
    // Parse input
    await quickCapture.parseInput(input);
    const parsed = quickCapture.state.get('preview');
    
    expect(parsed.entity_type).toBe('event');
    expect(parsed.title).toBe('Call John about project');
    expect(parsed.tags).toEqual(['work', 'urgent']);
    expect(parsed.fields.budget).toBe(50);
    expect(parsed.fields.location).toBe('office');
    expect(parsed.fields.due_date).toBeInstanceOf(Date);
    
    // Create entity
    const event = await quickCapture.createFromParsed(parsed);
    
    expect(event.title).toBe('Call John about project');
    expect(event.budget).toBe(50);
    expect(event.location).toBe('office');
    expect(event.due_date).toBeInstanceOf(Date);
    
    // Verify tags were created and assigned
    const tags = await Tag.findByUserWithCounts(1);
    expect(tags.map(t => t.name)).toEqual(expect.arrayContaining(['work', 'urgent']));
  });
  
  it('should handle item creation from input', async () => {
    const input = 'MacBook Pro 2023 $2499 #tech #equipment';
    
    await quickCapture.parseInput(input);
    const parsed = quickCapture.state.get('preview');
    
    expect(parsed.entity_type).toBe('item');
    expect(parsed.title).toBe('MacBook Pro 2023');
    expect(parsed.fields.budget).toBe(2499);
    expect(parsed.tags).toEqual(['tech', 'equipment']);
    
    const item = await quickCapture.createFromParsed(parsed);
    
    expect(item.name).toBe('MacBook Pro 2023');
    expect(item.value).toBe(2499);
  });
  
  it('should handle complex parsing scenarios', async () => {
    const testCases = [
      {
        input: 'Meeting with team @conference-room due:friday 2pm #work priority:high',
        expected: {
          entity_type: 'event',
          title: 'Meeting with team',
          tags: ['work'],
          fields: {
            location: 'conference-room',
            priority: 4
          }
        }
      },
      {
        input: 'Buy groceries milk bread eggs #shopping $25 due:today',
        expected: {
          entity_type: 'event',
          title: 'Buy groceries',
          description: 'milk bread eggs',
          tags: ['shopping'],
          fields: {
            budget: 25
          }
        }
      }
    ];
    
    for (const testCase of testCases) {
      await quickCapture.parseInput(testCase.input);
      const parsed = quickCapture.state.get('preview');
      
      expect(parsed.entity_type).toBe(testCase.expected.entity_type);
      expect(parsed.title).toBe(testCase.expected.title);
      
      if (testCase.expected.description) {
        expect(parsed.description).toBe(testCase.expected.description);
      }
      
      expect(parsed.tags).toEqual(testCase.expected.tags);
      
      for (const [field, value] of Object.entries(testCase.expected.fields)) {
        if (field === 'due_date') {
          expect(parsed.fields[field]).toBeInstanceOf(Date);
        } else {
          expect(parsed.fields[field]).toBe(value);
        }
      }
    }
  });
});
```

### End-to-End Testing (Future)

```javascript
// tests/e2e/userWorkflow.test.js
import { test, expect } from '@playwright/test';

test.describe('User Workflow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    
    // Set up test data
    await page.evaluate(() => {
      window.testMode = true;
    });
  });
  
  test('should create event through quick capture', async ({ page }) => {
    // Navigate to quick capture
    await page.fill('[data-testid="quick-capture-input"]', 'Call John #work due:tomorrow');
    await page.press('[data-testid="quick-capture-input"]', 'Enter');
    
    // Verify event appears in list
    await expect(page.locator('[data-testid="event-list"]')).toContainText('Call John');
    
    // Verify tags were applied
    await expect(page.locator('[data-testid="event-item"]').first()).toContainText('work');
  });
  
  test('should filter events by tags', async ({ page }) => {
    // Create test events
    await page.evaluate(() => {
      window.app.createTestEvents();
    });
    
    // Apply tag filter
    await page.click('[data-testid="tag-filter-work"]');
    
    // Verify only work events are shown
    const eventItems = page.locator('[data-testid="event-item"]');
    await expect(eventItems).toHaveCount(3);
    
    // Verify all visible events have work tag
    for (let i = 0; i < 3; i++) {
      await expect(eventItems.nth(i)).toContainText('work');
    }
  });
  
  test('should create collection from current filters', async ({ page }) => {
    // Set up filters
    await page.selectOption('[data-testid="priority-filter"]', '4');
    await page.fill('[data-testid="search-input"]', 'project');
    
    // Save as collection
    await page.click('[data-testid="save-collection-btn"]');
    await page.fill('[data-testid="collection-name"]', 'High Priority Projects');
    await page.click('[data-testid="save-btn"]');
    
    // Verify collection was created
    await page.click('[data-testid="vault-tab"]');
    await expect(page.locator('[data-testid="collections-list"]')).toContainText('High Priority Projects');
    
    // Test collection functionality
    await page.click('[data-testid="collection-item"]:has-text("High Priority Projects")');
    await expect(page.locator('[data-testid="collection-results"]')).toBeVisible();
  });
});
```

---

## API Development

### REST API Structure (Future)

```javascript
// src/api/routes/events.js
class EventsController {
  // GET /api/events
  static async index(req, res) {
    try {
      const { user_id } = req.user;
      const { page = 0, limit = 50, ...filters } = req.query;
      
      const query = Event.query().byUser(user_id);
      
      // Apply filters
      if (filters.priority) {
        query.byPriority(parseInt(filters.priority));
      }
      
      if (filters.due_before) {
        query.dueBetween(new Date(), new Date(filters.due_before));
      }
      
      if (filters.tags) {
        query.withTags(filters.tags.split(','));
      }
      
      const events = await query.paginate(page * limit, limit);
      const total = await query.count();
      
      res.json({
        data: events,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // POST /api/events
  static async create(req, res) {
    try {
      const { user_id } = req.user;
      const eventData = { ...req.body, user_id };
      
      // Validate input
      const validation = await EventValidator.validate(eventData);
      if (!validation.valid) {
        return res.status(400).json({
          error: 'Validation failed',
          details: validation.errors
        });
      }
      
      const event = await Event.create(eventData);
      
      // Handle tags if provided
      if (req.body.tags) {
        await TagAssignment.assignTagsFromNames(
          user_id,
          'event',
          event.event_id,
          req.body.tags
        );
      }
      
      res.status(201).json({ data: event });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // GET /api/events/:id
  static async show(req, res) {
    try {
      const { user_id } = req.user;
      const { id } = req.params;
      
      const event = await Event.findById(parseInt(id));
      
      if (!event || event.user_id !== user_id) {
        return res.status(404).json({ error: 'Event not found' });
      }
      
      // Include relationships and tags
      const eventWithRelationships = await Event.findWithRelationships(event.event_id);
      const tags = await TagAssignment.getTagsForEntity('event', event.event_id);
      
      res.json({
        data: {
          ...eventWithRelationships,
          tags
        }
      });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // PUT /api/events/:id
  static async update(req, res) {
    try {
      const { user_id } = req.user;
      const { id } = req.params;
      
      const existingEvent = await Event.findById(parseInt(id));
      
      if (!existingEvent || existingEvent.user_id !== user_id) {
        return res.status(404).json({ error: 'Event not found' });
      }
      
      // Validate updates
      const validation = await EventValidator.validate(req.body, parseInt(id));
      if (!validation.valid) {
        return res.status(400).json({
          error: 'Validation failed',
          details: validation.errors
        });
      }
      
      const updatedEvent = await Event.update(parseInt(id), req.body);
      
      // Handle tags if provided
      if (req.body.tags) {
        await TagAssignment.assignTagsFromNames(
          user_id,
          'event',
          updatedEvent.event_id,
          req.body.tags
        );
      }
      
      res.json({ data: updatedEvent });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // DELETE /api/events/:id
  static async destroy(req, res) {
    try {
      const { user_id } = req.user;
      const { id } = req.params;
      
      const event = await Event.findById(parseInt(id));
      
      if (!event || event.user_id !== user_id) {
        return res.status(404).json({ error: 'Event not found' });
      }
      
      await Event.delete(parseInt(id));
      
      res.status(204).send();
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // POST /api/events/search
  static async search(req, res) {
    try {
      const { user_id } = req.user;
      const { query, filters = {} } = req.body;
      
      let events;
      
      if (query) {
        // Full-text search
        events = await Event.searchByText(user_id, query);
      } else {
        // Filter-based search
        events = await Event.findByFilters(user_id, filters);
      }
      
      res.json({ data: events });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  // POST /api/events/bulk
  static async bulkCreate(req, res) {
    try {
      const { user_id } = req.user;
      const { events } = req.body;
      
      if (!Array.isArray(events) || events.length === 0) {
        return res.status(400).json({
          error: 'Events array is required and must not be empty'
        });
      }
      
      const results = [];
      const errors = [];
      
      for (const [index, eventData] of events.entries()) {
        try {
          const validation = await EventValidator.validate({ ...eventData, user_id });
          
          if (!validation.valid) {
            errors.push({
              index,
              errors: validation.errors
            });
            continue;
          }
          
          const event = await Event.create({ ...eventData, user_id });
          results.push(event);
          
        } catch (error) {
          errors.push({
            index,
            error: error.message
          });
        }
      }
      
      res.status(201).json({
        data: results,
        errors: errors.length > 0 ? errors : undefined
      });
      
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}

export { EventsController };
```

### API Middleware

```javascript
// src/api/middleware/auth.js
class AuthMiddleware {
  static async authenticate(req, res, next) {
    try {
      const authHeader = req.headers.authorization;
      
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Authorization token required' });
      }
      
      const token = authHeader.substring(7);
      const decoded = await TokenService.verify(token);
      
      req.user = decoded;
      next();
      
    } catch (error) {
      res.status(401).json({ error: 'Invalid or expired token' });
    }
  }
  
  static async requirePermission(permission) {
    return (req, res, next) => {
      if (!req.user.permissions.includes(permission)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }
      next();
    };
  }
}

// src/api/middleware/validation.js
class ValidationMiddleware {
  static validate(schema) {
    return (req, res, next) => {
      const { error, value } = schema.validate(req.body);
      
      if (error) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.details.map(d => d.message)
        });
      }
      
      req.body = value;
      next();
    };
  }
}

// src/api/middleware/rateLimit.js
class RateLimitMiddleware {
  static create(options = {}) {
    const {
      windowMs = 15 * 60 * 1000, // 15 minutes
      maxRequests = 100,
      message = 'Too many requests'
    } = options;
    
    const requests = new Map();
    
    return (req, res, next) => {
      const key = req.ip || req.connection.remoteAddress;
      const now = Date.now();
      const windowStart = now - windowMs;
      
      // Clean old entries
      for (const [ip, timestamps] of requests.entries()) {
        const validTimestamps = timestamps.filter(t => t > windowStart);
        if (validTimestamps.length === 0) {
          requests.delete(ip);
        } else {
          requests.set(ip, validTimestamps);
        }
      }
      
      // Check current requests
      const userRequests = requests.get(key) || [];
      const recentRequests = userRequests.filter(t => t > windowStart);
      
      if (recentRequests.length >= maxRequests) {
        return res.status(429).json({ error: message });
      }
      
      recentRequests.push(now);
      requests.set(key, recentRequests);
      
      next();
    };
  }
}

export { AuthMiddleware, ValidationMiddleware, RateLimitMiddleware };
```

---

## File Synchronization

### Markdown Sync Implementation

```javascript
// src/sync/FileSync.js
class FileSync {
  constructor() {
    this.syncQueue = [];
    this.isProcessing = false;
    this.syncInterval = 5000; // 5 seconds
    
    this.startSyncWorker();
  }
  
  // Export entity to markdown file
  async exportToMarkdown(entityType, entityId) {
    try {
      const entity = await this.getEntity(entityType, entityId);
      if (!entity) {
        throw new Error(`${entityType} not found`);
      }
      
      const template = await this.getTemplate(entityType, entity);
      const markdown = await this.renderTemplate(template, entity);
      
      const filePath = this.generateFilePath(entityType, entity);
      await this.writeMarkdownFile(filePath, markdown);
      
      // Update sync status
      await this.updateSyncStatus(entityType, entityId, {
        last_db_export: new Date(),
        file_path: filePath,
        sync_conflicts: {}
      });
      
      return filePath;
      
    } catch (error) {
      console.error('Export to markdown failed:', error);
      throw error;
    }
  }
  
  // Import from markdown file to database
  async importFromMarkdown(filePath) {
    try {
      const markdown = await this.readMarkdownFile(filePath);
      const parsed = await this.parseMarkdown(markdown, filePath);
      
      if (!parsed.entity_id) {
        throw new Error('Could not determine entity ID from markdown');
      }
      
      const existingEntity = await this.getEntity(parsed.entity_type, parsed.entity_id);
      
      let entity;
      if (existingEntity) {
        entity = await this.updateEntity(parsed.entity_type, parsed.entity_id, parsed.data);
      } else {
        entity = await this.createEntity(parsed.entity_type, parsed.data);
      }
      
      // Update sync status
      await this.updateSyncStatus(parsed.entity_type, entity[`${parsed.entity_type}_id`], {
        last_file_import: new Date(),
        file_path: filePath
      });
      
      return entity;
      
    } catch (error) {
      console.error('Import from markdown failed:', error);
      throw error;
    }
  }
  
  // Bidirectional sync with conflict detection
  async bidirectionalSync() {
    try {
      const entityFiles = await db.entity_files.toArray();
      
      for (const entityFile of entityFiles) {
        await this.syncEntityFile(entityFile);
      }
      
    } catch (error) {
      console.error('Bidirectional sync failed:', error);
    }
  }
  
  async syncEntityFile(entityFile) {
    try {
      const { entity_type, entity_id, file_path, sync_status } = entityFile;
      
      // Check if file exists
      const fileExists = await this.fileExists(file_path);
      if (!fileExists) {
        // File was deleted, handle accordingly
        await this.handleFileDeleted(entityFile);
        return;
      }
      
      // Get file modification time
      const fileModTime = await this.getFileModificationTime(file_path);
      const lastFileImport = new Date(sync_status.last_file_import || 0);
      const lastDbExport = new Date(sync_status.last_db_export || 0);
      
      // Get database modification time
      const entity = await this.getEntity(entity_type, entity_id);
      const dbModTime = new Date(entity.updated_at);
      
      // Determine sync direction
      if (fileModTime > lastFileImport && dbModTime > lastDbExport) {
        // Both file and database have been modified - conflict!
        await this.handleSyncConflict(entityFile, fileModTime, dbModTime);
      } else if (fileModTime > lastFileImport) {
        // File is newer - import from file
        await this.importFromMarkdown(file_path);
      } else if (dbModTime > lastDbExport) {
        // Database is newer - export to file
        await this.exportToMarkdown(entity_type, entity_id);
      }
      // If neither is newer, no sync needed
      
    } catch (error) {
      console.error(`Sync failed for ${entityFile.file_path}:`, error);
      
      // Update sync status with error
      await this.updateSyncStatus(entityFile.entity_type, entityFile.entity_id, {
        sync_error: error.message,
        last_sync_attempt: new Date()
      });
    }
  }
  
  async handleSyncConflict(entityFile, fileModTime, dbModTime) {
    const { entity_type, entity_id, file_path } = entityFile;
    
    // Create backup of current file
    const backupPath = `${file_path}.backup.${Date.now()}`;
    await this.copyFile(file_path, backupPath);
    
    // Parse both versions
    const fileContent = await this.readMarkdownFile(file_path);
    const fileParsed = await this.parseMarkdown(fileContent, file_path);
    const dbEntity = await this.getEntity(entity_type, entity_id);
    
    // Create conflict resolution data
    const conflictData = {
      detected_at: new Date(),
      file_version: {
        content: fileContent,
        modified_at: fileModTime,
        parsed_data: fileParsed.data
      },
      db_version: {
        entity: dbEntity,
        modified_at: dbModTime
      },
      backup_path: backupPath,
      resolution_strategy: 'manual' // or 'db_wins', 'file_wins', 'merge'
    };
    
    // Update sync status with conflict info
    await this.updateSyncStatus(entity_type, entity_id, {
      sync_conflicts: conflictData,
      conflict_detected: true
    });
    
    // Notify user of conflict
    this.notifyConflict(entityFile, conflictData);
  }
  
  async resolveConflict(entityType, entityId, resolution) {
    const entityFile = await db.entity_files
      .where('[entity_type+entity_id]')
      .equals([entityType, entityId])
      .first();
    
    if (!entityFile || !entityFile.sync_status.conflict_detected) {
      throw new Error('No conflict found for this entity');
    }
    
    const conflictData = entityFile.sync_status.sync_conflicts;
    
    switch (resolution.strategy) {
      case 'use_db':
        // Export database version to file
        await this.exportToMarkdown(entityType, entityId);
        break;
        
      case 'use_file':
        // Import file version to database
        await this.importFromMarkdown(entityFile.file_path);
        break;
        
      case 'merge':
        // User-provided merged data
        await this.updateEntity(entityType, entityId, resolution.mergedData);
        await this.exportToMarkdown(entityType, entityId);
        break;
        
      default:
        throw new Error('Invalid resolution strategy');
    }
    
    // Clear conflict status
    await this.updateSyncStatus(entityType, entityId, {
      sync_conflicts: {},
      conflict_detected: false,
      conflict_resolved_at: new Date(),
      resolution_strategy: resolution.strategy
    });
    
    // Clean up backup file if desired
    if (resolution.deleteBackup && conflictData.backup_path) {
      await this.deleteFile(conflictData.backup_path);
    }
  }
  
  // Template rendering
  async renderTemplate(template, entity) {
    const templateEngine = new TemplateEngine();
    
    // Prepare template variables
    const variables = {
      ...entity,
      user: await this.getCurrentUser(),
      today: new Date(),
      tomorrow: new Date(Date.now() + 24 * 60 * 60 * 1000),
      this_week: this.getWeekRange(),
      next_week: this.getWeekRange(1)
    };
    
    return templateEngine.render(template.content_template, variables);
  }
  
  // Markdown parsing
  async parseMarkdown(markdown, filePath) {
    const parser = new MarkdownParser();
    
    // Extract metadata from frontmatter
    const { frontmatter, content } = parser.parseFrontmatter(markdown);
    
    // Determine entity type and ID
    const entityType = frontmatter.entity_type || this.inferEntityTypeFromPath(filePath);
    const entityId = frontmatter.entity_id || this.inferEntityIdFromPath(filePath);
    
    // Parse content based on entity type
    const parsedData = await parser.parseContent(content, entityType);
    
    return {
      entity_type: entityType,
      entity_id: parseInt(entityId),
      data: {
        ...parsedData,
        ...frontmatter
      }
    };
  }
  
  // File system operations (to be implemented based on environment)
  async writeMarkdownFile(filePath, content) {
    // Browser environment - use File System Access API or download
    if (typeof window !== 'undefined') {
      return this.writeFileBrowser(filePath, content);
    }
    
    // Node.js environment
    const fs = await import('fs/promises');
    await fs.writeFile(filePath, content, 'utf8');
  }
  
  async readMarkdownFile(filePath) {
    if (typeof window !== 'undefined') {
      return this.readFileBrowser(filePath);
    }
    
    const fs = await import('fs/promises');
    return fs.readFile(filePath, 'utf8');
  }
  
  async writeFileBrowser(filePath, content) {
    // Use File System Access API if available
    if ('showSaveFilePicker' in window) {
      const fileHandle = await window.showSaveFilePicker({
        suggestedName: filePath.split('/').pop(),
        types: [{
          description: 'Markdown files',
          accept: { 'text/markdown': ['.md'] }
        }]
      });
      
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
      
      return fileHandle.name;
    }
    
    // Fallback to download
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filePath.split('/').pop();
    a.click();
    URL.revokeObjectURL(url);
    
    return filePath;
  }
  
  // Sync worker
  startSyncWorker() {
    setInterval(() => {
      if (!this.isProcessing) {
        this.processSyncQueue();
      }
    }, this.syncInterval);
  }
  
  async processSyncQueue() {
    if (this.syncQueue.length === 0) return;
    
    this.isProcessing = true;
    
    try {
      while (this.syncQueue.length > 0) {
        const syncTask = this.syncQueue.shift();
        await this.executeSyncTask(syncTask);
      }
    } catch (error) {
      console.error('Sync queue processing failed:', error);
    } finally {
      this.isProcessing = false;
    }
  }
  
  queueSync(entityType, entityId, operation = 'bidirectional') {
    this.syncQueue.push({
      entity_type: entityType,
      entity_id: entityId,
      operation,
      queued_at: new Date()
    });
  }
  
  // Helper methods
  async getEntity(entityType, entityId) {
    switch (entityType) {
      case 'event':
        return await Event.findById(entityId);
      case 'item':
        return await Item.findById(entityId);
      default:
        throw new Error(`Unknown entity type: ${entityType}`);
    }
  }
  
  async getTemplate(entityType, entity) {
    if (entityType === 'event' && entity.event_type_id) {
      const eventType = await db.event_types.get(entity.event_type_id);
      if (eventType?.content_template) {
        return eventType;
      }
    }
    
    // Return default template
    return {
      content_template: `# {{title}}\n\n{{description}}\n\n## Details\n{{#each custom_fields}}\n**{{@key}}:** {{this}}\n{{/each}}`
    };
  }
  
  generateFilePath(entityType, entity) {
    const basePath = this.getBasePath();
    const dateStr = new Date().toISOString().split('T')[0];
    const fileName = this.sanitizeFileName(entity.title || entity.name);
    
    return `${basePath}/${entityType}s/${dateStr}-${fileName}.md`;
  }
  
  async updateSyncStatus(entityType, entityId, statusUpdates) {
    const existing = await db.entity_files
      .where('[entity_type+entity_id]')
      .equals([entityType, entityId])
      .first();
    
    if (existing) {
      await db.entity_files.update(existing.id, {
        sync_status: {
          ...existing.sync_status,
          ...statusUpdates
        },
        updated_at: new Date()
      });
    } else {
      await db.entity_files.add({
        entity_type: entityType,
        entity_id: entityId,
        file_path: this.generateFilePath(entityType, { title: 'Unknown' }),
        sync_status: statusUpdates,
        user_id: await this.getCurrentUserId(),
        created_at: new Date(),
        updated_at: new Date()
      });
    }
  }
}

export { FileSync };
```

---

## Security Implementation

### Data Validation

```javascript
// src/utils/validationUtils.js
class ValidationUtils {
  // SQL injection prevention
  static sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    return input
      .replace(/['"\\]/g, '') // Remove quotes and backslashes
      .trim();
  }
  
  // XSS prevention
  static escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Input validation schemas
  static eventSchema = {
    title: {
      required: true,
      type: 'string',
      maxLength: 255,
      minLength: 1
    },
    description: {
      type: 'string',
      maxLength: 10000
    },
    priority: {
      type: 'integer',
      min: 1,
      max: 5
    },
    budget: {
      type: 'number',
      min: 0,
      max: 999999.99
    },
    due_date: {
      type: 'date'
    },
    status: {
      type: 'string',
      enum: ['active', 'completed', 'cancelled', 'deferred']
    },
    custom_fields: {
      type: 'object'
    }
  };
  
  static validateField(value, fieldSchema) {
    const errors = [];
    
    // Required check
    if (fieldSchema.required && (value === undefined || value === null || value === '')) {
      errors.push('This field is required');
      return { valid: false, errors };
    }
    
    // Skip other validations if not required and empty
    if (!fieldSchema.required && (value === undefined || value === null || value === '')) {
      return { valid: true, errors: [] };
    }
    
    // Type validation
    switch (fieldSchema.type) {
      case 'string':
        if (typeof value !== 'string') {
          errors.push('Must be a string');
        } else {
          if (fieldSchema.minLength && value.length < fieldSchema.minLength) {
            errors.push(`Must be at least ${fieldSchema.minLength} characters`);
          }
          if (fieldSchema.maxLength && value.length > fieldSchema.maxLength) {
            errors.push(`Must be no more than ${fieldSchema.maxLength} characters`);
          }
          if (fieldSchema.pattern && !new RegExp(fieldSchema.pattern).test(value)) {
            errors.push('Invalid format');
          }
        }
        break;
        
      case 'integer':
        if (!Number.isInteger(value)) {
          errors.push('Must be an integer');
        } else {
          if (fieldSchema.min !== undefined && value < fieldSchema.min) {
            errors.push(`Must be at least ${fieldSchema.min}`);
          }
          if (fieldSchema.max !== undefined && value > fieldSchema.max) {
            errors.push(`Must be no more than ${fieldSchema.max}`);
          }
        }
        break;
        
      case 'number':
        if (typeof value !== 'number' || isNaN(value)) {
          errors.push('Must be a number');
        } else {
          if (fieldSchema.min !== undefined && value < fieldSchema.min) {
            errors.push(`Must be at least ${fieldSchema.min}`);
          }
          if (fieldSchema.max !== undefined && value > fieldSchema.max) {
            errors.push(`Must be no more than ${fieldSchema.max}`);
          }
        }
        break;
        
      case 'date':
        if (!(value instanceof Date) && isNaN(new Date(value))) {
          errors.push('Must be a valid date');
        }
        break;
        
      case 'object':
        if (typeof value !== 'object' || Array.isArray(value)) {
          errors.push('Must be an object');
        }
        break;
        
      case 'array':
        if (!Array.isArray(value)) {
          errors.push('Must be an array');
        }
        break;
    }
    
    // Enum validation
    if (fieldSchema.enum && !fieldSchema.enum.includes(value)) {
      errors.push(`Must be one of: ${fieldSchema.enum.join(', ')}`);
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  static validateObject(obj, schema) {
    const errors = {};
    let isValid = true;
    
    for (const [fieldName, fieldSchema] of Object.entries(schema)) {
      const fieldValue = obj[fieldName];
      const validation = this.validateField(fieldValue, fieldSchema);
      
      if (!validation.valid) {
        errors[fieldName] = validation.errors;
        isValid = false;
      }
    }
    
    return {
      valid: isValid,
      errors
    };
  }
  
  // Rate limiting
  static createRateLimiter(maxAttempts = 5, windowMs = 15 * 60 * 1000) {
    const attempts = new Map();
    
    return (identifier) => {
      const now = Date.now();
      const windowStart = now - windowMs;
      
      // Clean old attempts
      for (const [id, timestamps] of attempts.entries()) {
        const validTimestamps = timestamps.filter(t => t > windowStart);
        if (validTimestamps.length === 0) {
          attempts.delete(id);
        } else {
          attempts.set(id, validTimestamps);
        }
      }
      
      // Check current attempts
      const userAttempts = attempts.get(identifier) || [];
      const recentAttempts = userAttempts.filter(t => t > windowStart);
      
      if (recentAttempts.length >= maxAttempts) {
        return {
          allowed: false,
          retryAfter: Math.ceil((recentAttempts[0] + windowMs - now) / 1000)
        };
      }
      
      recentAttempts.push(now);
      attempts.set(identifier, recentAttempts);
      
      return {
        allowed: true,
        remaining: maxAttempts - recentAttempts.length
      };
    };
  }
}

export { ValidationUtils };
```

### Authentication System (Future)

```javascript
// src/auth/AuthService.js
class AuthService {
  constructor() {
    this.currentUser = null;
    this.tokenRefreshInterval = null;
  }
  
  async login(email, password) {
    try {
      // Validate input
      if (!email || !password) {
        throw new Error('Email and password are required');
      }
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Login failed');
      }
      
      const data = await response.json();
      
      // Store tokens
      localStorage.setItem('access_token', data.access_token);
      localStorage.setItem('refresh_token', data.refresh_token);
      
      // Set current user
      this.currentUser = data.user;
      
      // Start token refresh cycle
      this.startTokenRefresh();
      
      return data.user;
      
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }
  
  async logout() {
    try {
      const token = localStorage.getItem('access_token');
      
      if (token) {
        await fetch('/api/auth/logout', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
      }
      
    } catch (error) {
      console.error('Logout request failed:', error);
    } finally {
      // Clear local state regardless of API call result
      this.clearAuthData();
    }
  }
  
  async refreshToken() {
    try {
      const refreshToken = localStorage.getItem('refresh_token');
      
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }
      
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ refresh_token: refreshToken })
      });
      
      if (!response.ok) {
        throw new Error('Token refresh failed');
      }
      
      const data = await response.json();
      
      // Update stored tokens
      localStorage.setItem('access_token', data.access_token);
      if (data.refresh_token) {
        localStorage.setItem('refresh_token', data.refresh_token);
      }
      
      return data.access_token;
      
    } catch (error) {
      console.error('Token refresh failed:', error);
      this.clearAuthData();
      throw error;
    }
  }
  
  async getCurrentUser() {
    if (this.currentUser) {
      return this.currentUser;
    }
    
    const token = localStorage.getItem('access_token');
    if (!token) {
      return null;
    }
    
    try {
      const response = await fetch('/api/auth/me', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('Failed to get current user');
      }
      
      const user = await response.json();
      this.currentUser = user;
      
      return user;
      
    } catch (error) {
      console.error('Get current user failed:', error);
      this.clearAuthData();
      return null;
    }
  }
  
  isAuthenticated() {
    return !!localStorage.getItem('access_token');
  }
  
  getAuthHeader() {
    const token = localStorage.getItem('access_token');
    return token ? { 'Authorization': `Bearer ${token}` } : {};
  }
  
  startTokenRefresh() {
    // Refresh token every 45 minutes (assuming 1 hour expiry)
    this.tokenRefreshInterval = setInterval(() => {
      this.refreshToken().catch(() => {
        // If refresh fails, user will be logged out
      });
    }, 45 * 60 * 1000);
  }
  
  clearAuthData() {
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    this.currentUser = null;
    
    if (this.tokenRefreshInterval) {
      clearInterval(this.tokenRefreshInterval);
      this.tokenRefreshInterval = null;
    }
  }
}

export const authService = new AuthService();
```

---

## Deployment Guide

### Development Deployment

```bash
# scripts/setup-dev.js
#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');

async function setupDevelopment() {
  console.log('Setting up development environment...');
  
  // Create required directories
  const directories = [
    'src/models',
    'src/viewmodels', 
    'src/views',
    'src/utils',
    'tests/unit',
    'tests/integration',
    'public/styles',
    'public/assets'
  ];
  
  for (const dir of directories) {
    await fs.mkdir(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
  
  // Copy environment file
  try {
    await fs.access('.env.development');
  } catch {
    await fs.copyFile('.env.example', '.env.development');
    console.log('Created .env.development file');
  }
  
  // Install dependencies if needed
  try {
    await fs.access('node_modules');
  } catch {
    console.log('Installing dependencies...');
    const { spawn } = require('child_process');
    await new Promise((resolve, reject) => {
      const npm = spawn('npm', ['install'], { stdio: 'inherit' });
      npm.on('close', (code) => {
        if (code === 0) resolve();
        else reject(new Error(`npm install failed with code ${code}`));
      });
    });
  }
  
  console.log('\n✅ Development environment ready!');
  console.log('Run "npm run dev" to start the development server.');
}

setupDevelopment().catch(console.error);
```

### Production Build

```json
{
  "scripts": {
    "dev": "live-server public --port=3000 --open=/",
    "build": "node scripts/build-production.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "migrate": "node scripts/migrate-schema.js",
    "seed": "node scripts/seed-data.js",
    "performance": "node scripts/performance-test.js"
  }
}
```

### Docker Deployment

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY src/ ./src/
COPY public/ ./public/
COPY config/ ./config/

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S appuser -u 1001
USER appuser

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Start application
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=org_ecosystem
      - DB_USER=postgres
      - DB_PASSWORD=password
    depends_on:
      - postgres
    volumes:
      - ./sync-files:/app/sync-files
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=org_ecosystem
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
```

---

## Contributing Guidelines

### Code Style

```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2022: true,
    node: true,
    jest: true
  },
  extends: [
    'eslint:recommended'
  ],
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module'
  },
  rules: {
    // Code Quality
    'no-unused-vars': ['error', { 'argsIgnorePattern': '^_' }],
    'no-console': ['warn', { 'allow': ['warn', 'error'] }],
    'no-debugger': 'error',
    
    // Formatting
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'always'],
    'comma-dangle': ['error', 'never'],
    
    // Best Practices
    'eqeqeq': 'error',
    'no-var': 'error',
    'prefer-const': 'error',
    'prefer-arrow-callback': 'error',
    
    // ES6+
    'arrow-spacing': 'error',
    'template-curly-spacing': 'error'
  }
};
```

### Git Workflow

```bash
# Feature development workflow
git checkout main
git pull origin main
git checkout -b feature/event-management
# Make changes
git add .
git commit -m "feat: add event filtering by priority"
git push origin feature/event-management
# Create pull request

# Commit message format
feat: add new feature
fix: fix a bug
docs: update documentation
style: formatting changes
refactor: code refactoring
test: add tests
chore: maintenance tasks
```

### Pull Request Template

```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update
- [ ] Performance improvement
- [ ] Refactoring

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] Performance tested

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex code
- [ ] Documentation updated
- [ ] No console.log statements
- [ ] Error handling implemented

## Screenshots (if applicable)

## Additional Notes
```

### Code Review Guidelines

1. **Architecture Compliance**
   - Follows MVVM pattern
   - Maintains Event/Item dichotomy
   - Uses proper separation of concerns

2. **Performance Considerations**
   - Uses real columns for common queries
   - Implements proper indexing
   - Avoids N+1 query problems

3. **Code Quality**
   - Proper error handling
   - Comprehensive validation
   - Clear variable names
   - Adequate comments

4. **Testing**
   - Unit tests for all new functionality
   - Integration tests for complex features
   - Performance tests for database operations

---

## Troubleshooting

### Common Issues

#### Database Connection Issues
```javascript
// Debug IndexedDB connection
async function debugDatabase() {
  try {
    await db.open();
    console.log('Database opened successfully');
    
    const tables = await Promise.all([
      db.users.count(),
      db.events.count(),
      db.items.count()
    ]);
    
    console.log('Table counts:', {
      users: tables[0],
      events: tables[1],
      items: tables[2]
    });
    
  } catch (error) {
    console.error('Database debug failed:', error);
    
    // Try to delete and recreate
    await db.delete();
    await db.open();
    console.log('Database recreated');
  }
}
```

#### Performance Issues
```javascript
// Monitor slow queries
const originalQuery = db.events.toCollection;
db.events.toCollection = function(...args) {
  const startTime = performance.now();
  const collection = originalQuery.apply(this, args);
  
  const originalToArray = collection.toArray;
  collection.toArray = async function() {
    const result = await originalToArray.call(this);
    const duration = performance.now() - startTime;
    
    if (duration > 100) {
      console.warn(`Slow query detected: ${duration.toFixed(2)}ms`);
    }
    
    return result;
  };
  
  return collection;
};
```

#### Memory Leaks
```javascript
// Monitor memory usage
class MemoryMonitor {
  static monitor() {
    if (!performance.memory) {
      console.warn('Memory monitoring not available');
      return;
    }
    
    const logMemory = () => {
      const memory = performance.memory;
      console.log('Memory usage:', {
        used: Math.round(memory.usedJSHeapSize / 1024 / 1024) + ' MB',
        total: Math.round(memory.totalJSHeapSize / 1024 / 1024) + ' MB',
        limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024) + ' MB'
      });
    };
    
    setInterval(logMemory, 30000); // Log every 30 seconds
  }
}
```

### Debug Utilities

```javascript
// src/utils/debugUtils.js
class DebugUtils {
  static async exportDatabaseDump() {
    const dump = {
      users: await db.users.toArray(),
      events: await db.events.toArray(),
      items: await db.items.toArray(),
      tags: await db.tags.toArray(),
      collections: await db.collections.toArray(),
      operation_logs: await db.operation_logs.limit(100).reverse().toArray()
    };
    
    const blob = new Blob([JSON.stringify(dump, null, 2)], {
      type: 'application/json'
    });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `database-dump-${new Date().toISOString()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  static async importDatabaseDump(file) {
    const text = await file.text();
    const dump = JSON.parse(text);
    
    // Clear existing data
    await db.transaction('rw', db.tables, async () => {
      for (const table of db.tables) {
        await table.clear();
      }
      
      // Import data
      for (const [tableName, records] of Object.entries(dump)) {
        if (db[tableName] && records.length > 0) {
          await db[tableName].bulkAdd(records);
        }
      }
    });
    
    console.log('Database dump imported successfully');
  }
  
  static enableVerboseLogging() {
    // Override console methods to add timestamps
    const originalLog = console.log;
    console.log = (...args) => {
      originalLog(`[${new Date().toISOString()}]`, ...args);
    };
    
    // Log all database operations
    db.on('ready', () => console.log('Database ready'));
    db.on('blocked', () => console.warn('Database blocked'));
    db.on('versionchange', () => console.warn('Database version change'));
  }
}

export { DebugUtils };
```

### Browser DevTools

```javascript
// Add debugging methods to window object for console access
if (process.env.NODE_ENV === 'development') {
  window.debugDB = {
    async clearAll() {
      await db.transaction('rw', db.tables, async () => {
        for (const table of db.tables) {
          await table.clear();
        }
      });
      console.log('All data cleared');
    },
    
    async createTestData() {
      // Create test user
      await db.users.add({
        user_id: 1,
        username: 'testuser',
        email: 'test@example.com'
      });
      
      // Create test events
      for (let i = 1; i <= 10; i++) {
        await db.events.add({
          user_id: 1,
          title: `Test Event ${i}`,
          priority: Math.ceil(Math.random() * 5),
          due_date: new Date(Date.now() + i * 24 * 60 * 60 * 1000),
          status: 'active'
        });
      }
      
      console.log('Test data created');
    },
    
    async showStats() {
      const stats = {};
      for (const table of db.tables) {
        stats[table.name] = await table.count();
      }
      console.table(stats);
    }
  };
}
```

---

## PostgreSQL Server Development

### Server Setup and Architecture

The PostgreSQL server provides unlimited scale and enterprise features while maintaining identical schema to the IndexedDB client for seamless synchronization.

#### Local Development Environment

```bash
# Option 1: Docker (Recommended)
docker run --name org-ecosystem-postgres \
  -e POSTGRES_DB=organizational_ecosystem \
  -e POSTGRES_USER=dev_user \
  -e POSTGRES_PASSWORD=dev_password \
  -p 5432:5432 \
  -d postgres:15

# Option 2: Local PostgreSQL Installation
# macOS
brew install postgresql@15
brew services start postgresql@15

# Ubuntu/Debian
sudo apt update
sudo apt install postgresql-15 postgresql-contrib-15

# Create development database
createdb organizational_ecosystem
```

#### Server Project Structure

```
server/
├── src/
│   ├── config/
│   │   ├── database.js          # PostgreSQL connection config
│   │   ├── auth.js              # JWT configuration
│   │   └── cors.js              # CORS settings
│   ├── controllers/
│   │   ├── EventController.js   # Event CRUD operations
│   │   ├── ItemController.js    # Item CRUD operations
│   │   ├── SyncController.js    # Synchronization logic
│   │   └── AuthController.js    # Authentication endpoints
│   ├── middleware/
│   │   ├── auth.js              # JWT verification
│   │   ├── rateLimit.js         # Rate limiting
│   │   └── validation.js        # Request validation
│   ├── models/
│   │   ├── Event.js             # Event model with PostgreSQL
│   │   ├── Item.js              # Item model with PostgreSQL
│   │   └── User.js              # User model
│   ├── routes/
│   │   ├── events.js            # Event API routes
│   │   ├── items.js             # Item API routes
│   │   ├── sync.js              # Sync API routes
│   │   └── auth.js              # Auth API routes
│   ├── services/
│   │   ├── SyncService.js       # Bidirectional sync logic
│   │   ├── ConflictResolver.js  # Conflict resolution
│   │   └── CacheManager.js      # Server-side caching
│   └── app.js                   # Express app setup
├── database/
│   ├── migrations/              # Database migrations
│   ├── seeds/                   # Test data seeds
│   └── init.sql                 # Initial schema setup
├── tests/
│   ├── integration/             # API integration tests
│   ├── unit/                    # Unit tests
│   └── sync/                    # Sync functionality tests
├── package.json
├── Dockerfile
└── docker-compose.yml
```

#### Environment Configuration

```bash
# server/.env.development
NODE_ENV=development
PORT=3001

# PostgreSQL Configuration
DATABASE_URL=postgres://dev_user:dev_password@localhost:5432/organizational_ecosystem
DB_HOST=localhost
DB_PORT=5432
DB_NAME=organizational_ecosystem
DB_USER=dev_user
DB_PASSWORD=dev_password

# Security
JWT_SECRET=development_jwt_secret_key_change_in_production
JWT_EXPIRES_IN=7d

# CORS
CORS_ORIGIN=http://localhost:3000

# Logging
LOG_LEVEL=debug
DB_LOGGING=true

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

#### Express.js Server Setup

```javascript
// server/src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');

const app = express();

// Database connection pool
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.CORS_ORIGIN,
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));

// Rate limiting
const limiter = rateLimit({
  windowMs: process.env.RATE_LIMIT_WINDOW_MS || 15 * 60 * 1000,
  max: process.env.RATE_LIMIT_MAX_REQUESTS || 100,
  message: { error: 'Too many requests, please try again later' }
});
app.use('/api/', limiter);

// Database middleware
app.use((req, res, next) => {
  req.db = pool;
  next();
});

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/events', require('./routes/events'));
app.use('/api/items', require('./routes/items'));
app.use('/api/sync', require('./routes/sync'));

// Health check
app.get('/health', async (req, res) => {
  try {
    await req.db.query('SELECT 1');
    res.json({ status: 'healthy', timestamp: new Date().toISOString() });
  } catch (error) {
    res.status(500).json({ status: 'unhealthy', error: error.message });
  }
});

// Error handling
app.use((error, req, res, next) => {
  console.error('API Error:', error);
  res.status(error.status || 500).json({ 
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? error.message : undefined
  });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = app;
```

### PostgreSQL Models with Performance Optimization

```javascript
// server/src/models/Event.js
class Event {
  constructor(db) {
    this.db = db;
  }
  
  async create(userId, eventData) {
    const query = `
      INSERT INTO events (
        user_id, event_type_id, title, description,
        priority, budget, location, due_date, custom_fields
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `;
    
    const values = [
      userId,
      eventData.event_type_id,
      eventData.title,
      eventData.description,
      eventData.priority,
      eventData.budget,
      eventData.location,
      eventData.due_date,
      JSON.stringify(eventData.custom_fields || {})
    ];
    
    const result = await this.db.query(query, values);
    return result.rows[0];
  }
  
  async findByUser(userId, options = {}) {
    let query = `
      SELECT e.*, et.name as event_type_name,
             EXTRACT(EPOCH FROM (e.due_date - CURRENT_TIMESTAMP)) as seconds_until_due
      FROM events e
      LEFT JOIN event_types et ON e.event_type_id = et.event_type_id
      WHERE e.user_id = $1 AND e.deleted_at IS NULL
    `;
    
    const values = [userId];
    let paramCount = 1;
    
    // Performance: Use real column filters for 10x speed improvement
    if (options.priority) {
      query += ` AND e.priority >= $${++paramCount}`;
      values.push(options.priority);
    }
    
    if (options.due_after) {
      query += ` AND e.due_date >= $${++paramCount}`;
      values.push(options.due_after);
    }
    
    if (options.due_before) {
      query += ` AND e.due_date <= $${++paramCount}`;
      values.push(options.due_before);
    }
    
    if (options.location) {
      query += ` AND e.location ILIKE $${++paramCount}`;
      values.push(`%${options.location}%`);
    }
    
    // JSONB queries with GIN index optimization
    if (options.custom_fields) {
      query += ` AND e.custom_fields @> $${++paramCount}`;
      values.push(JSON.stringify(options.custom_fields));
    }
    
    // Full-text search
    if (options.search) {
      query += ` AND e.search_vector @@ plainto_tsquery($${++paramCount})`;
      values.push(options.search);
    }
    
    // Performance: Optimized ordering
    query += ` ORDER BY e.priority DESC, e.due_date ASC`;
    
    if (options.limit) {
      query += ` LIMIT $${++paramCount}`;
      values.push(options.limit);
    }
    
    if (options.offset) {
      query += ` OFFSET $${++paramCount}`;
      values.push(options.offset);
    }
    
    const result = await this.db.query(query, values);
    return result.rows;
  }
  
  async getRelevantForSync(userId, lastSyncTime, maxRecords = 10000) {
    const query = `
      SELECT e.*, et.name as event_type_name
      FROM events e
      LEFT JOIN event_types et ON e.event_type_id = et.event_type_id
      WHERE e.user_id = $1 
        AND e.deleted_at IS NULL
        AND (
          e.updated_at > $2 OR  -- Recently modified
          e.due_date > CURRENT_DATE - INTERVAL '30 days' OR  -- Recent or upcoming
          e.priority >= 4 OR  -- High priority
          e.custom_fields @> '{"starred": true}'  -- User favorites
        )
      ORDER BY e.priority DESC, e.updated_at DESC
      LIMIT $3
    `;
    
    const result = await this.db.query(query, [userId, lastSyncTime, maxRecords]);
    return result.rows;
  }
  
  async updateWithConflictDetection(eventId, userId, updateData, clientTimestamp) {
    // Check for concurrent modifications
    const conflictCheck = await this.db.query(
      'SELECT updated_at FROM events WHERE event_id = $1 AND user_id = $2',
      [eventId, userId]
    );
    
    if (conflictCheck.rows.length === 0) {
      throw new Error('Event not found');
    }
    
    const serverTimestamp = new Date(conflictCheck.rows[0].updated_at);
    const clientTime = new Date(clientTimestamp);
    
    // If server was modified after client timestamp, we have a conflict
    if (serverTimestamp > clientTime) {
      return {
        success: false,
        conflict: true,
        server_version: conflictCheck.rows[0],
        client_version: updateData
      };
    }
    
    // No conflict, proceed with update
    const query = `
      UPDATE events 
      SET title = $3, description = $4, priority = $5, 
          budget = $6, location = $7, due_date = $8,
          custom_fields = $9, updated_at = CURRENT_TIMESTAMP
      WHERE event_id = $1 AND user_id = $2 AND deleted_at IS NULL
      RETURNING *
    `;
    
    const values = [
      eventId, userId,
      updateData.title, updateData.description, updateData.priority,
      updateData.budget, updateData.location, updateData.due_date,
      JSON.stringify(updateData.custom_fields || {})
    ];
    
    const result = await this.db.query(query, values);
    return {
      success: true,
      conflict: false,
      data: result.rows[0]
    };
  }
}

module.exports = Event;
```

### Synchronization API Implementation

```javascript
// server/src/controllers/SyncController.js
class SyncController {
  static async getUpdates(req, res) {
    try {
      const { since, relevance_filter } = req.query;
      const userId = req.user.user_id;
      
      const eventModel = new Event(req.db);
      const itemModel = new Item(req.db);
      
      // Get updates for each entity type
      const [events, items] = await Promise.all([
        eventModel.getRelevantForSync(userId, since, relevance_filter?.events || 5000),
        itemModel.getRelevantForSync(userId, since, relevance_filter?.items || 5000)
      ]);
      
      res.json({
        success: true,
        data: {
          events,
          items,
          sync_timestamp: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Sync getUpdates error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve updates'
      });
    }
  }
  
  static async applyChanges(req, res) {
    try {
      const { operations } = req.body;
      const userId = req.user.user_id;
      const results = [];
      
      // Process operations in transaction
      await req.db.query('BEGIN');
      
      try {
        for (const operation of operations) {
          const result = await SyncController.processOperation(
            req.db, 
            userId, 
            operation
          );
          results.push(result);
        }
        
        await req.db.query('COMMIT');
        
        res.json({
          success: true,
          results
        });
        
      } catch (error) {
        await req.db.query('ROLLBACK');
        throw error;
      }
      
    } catch (error) {
      console.error('Sync applyChanges error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to apply changes'
      });
    }
  }
  
  static async processOperation(db, userId, operation) {
    const { type, entity_type, entity_id, data, client_timestamp } = operation;
    
    const Model = entity_type === 'event' ? Event : Item;
    const model = new Model(db);
    
    switch (type) {
      case 'CREATE':
        const created = await model.create(userId, data);
        return {
          operation_id: operation.id,
          success: true,
          server_data: created
        };
        
      case 'UPDATE':
        const updated = await model.updateWithConflictDetection(
          entity_id, 
          userId, 
          data, 
          client_timestamp
        );
        return {
          operation_id: operation.id,
          ...updated
        };
        
      case 'DELETE':
        const deleted = await model.softDelete(entity_id, userId);
        return {
          operation_id: operation.id,
          success: !!deleted,
          server_data: deleted
        };
        
      default:
        throw new Error(`Unknown operation type: ${type}`);
    }
  }
}

module.exports = SyncController;
```

### Development Workflow

#### Starting the Hybrid Development Environment

```bash
# Terminal 1: Start PostgreSQL database
docker-compose up postgres

# Terminal 2: Start API server with hot reload
cd server
npm install
npm run dev

# Terminal 3: Start client development server  
cd client
npm install
npm run dev

# Terminal 4: Run database setup and migrations
cd server
npm run db:migrate
npm run db:seed:dev
```

#### Database Management Commands

```bash
# Package.json scripts for server development
{
  "scripts": {
    "dev": "nodemon src/app.js",
    "start": "node src/app.js",
    "test": "jest",
    "test:integration": "jest --config jest.integration.config.js",
    "db:migrate": "node scripts/migrate.js",
    "db:seed": "node scripts/seed.js",
    "db:reset": "node scripts/reset.js",
    "db:backup": "pg_dump $DATABASE_URL > backup.sql",
    "db:restore": "psql $DATABASE_URL < backup.sql"
  }
}
```

#### Testing Strategy

```javascript
// tests/integration/sync.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Synchronization API', () => {
  let authToken;
  let userId;
  
  beforeAll(async () => {
    // Set up test user and authentication
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'testpassword123'
      });
      
    authToken = loginResponse.body.access_token;
    userId = loginResponse.body.user.user_id;
  });
  
  describe('GET /api/sync/updates', () => {
    it('should return relevant updates for sync', async () => {
      const response = await request(app)
        .get('/api/sync/updates')
        .query({ since: '2024-01-01T00:00:00Z' })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
        
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('events');
      expect(response.body.data).toHaveProperty('items');
      expect(response.body.data).toHaveProperty('sync_timestamp');
    });
  });
  
  describe('POST /api/sync/apply', () => {
    it('should process client operations and detect conflicts', async () => {
      const operations = [
        {
          id: 'client-op-1',
          type: 'CREATE',
          entity_type: 'event',
          data: {
            title: 'Test Event',
            priority: 3,
            due_date: '2024-12-31T23:59:59Z'
          }
        }
      ];
      
      const response = await request(app)
        .post('/api/sync/apply')
        .send({ operations })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
        
      expect(response.body.success).toBe(true);
      expect(response.body.results).toHaveLength(1);
      expect(response.body.results[0].success).toBe(true);
    });
  });
});
```

---

## API Development

### RESTful API Design

The API follows REST principles with PostgreSQL backend for unlimited scale and enterprise features.

#### Authentication Middleware

```javascript
// server/src/middleware/auth.js
const jwt = require('jsonwebtoken');

const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Set database context for row-level security
    await req.db.query('SET app.current_user_id = $1', [decoded.user_id]);
    
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};

module.exports = { authenticateToken };
```

#### Event API Routes

```javascript
// server/src/routes/events.js
const express = require('express');
const router = express.Router();
const EventController = require('../controllers/EventController');
const { authenticateToken } = require('../middleware/auth');
const { validateEvent } = require('../middleware/validation');

// Apply authentication to all routes
router.use(authenticateToken);

// GET /api/events - List events with filters
router.get('/', EventController.index);

// GET /api/events/:id - Get specific event
router.get('/:id', EventController.show);

// POST /api/events - Create new event
router.post('/', validateEvent, EventController.create);

// PUT /api/events/:id - Update event
router.put('/:id', validateEvent, EventController.update);

// DELETE /api/events/:id - Soft delete event
router.delete('/:id', EventController.destroy);

// POST /api/events/search - Full-text search
router.post('/search', EventController.search);

// POST /api/events/bulk - Bulk operations
router.post('/bulk', EventController.bulkOperation);

module.exports = router;
```

### Performance Monitoring

```javascript
// server/src/middleware/performance.js
const performanceMonitor = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const logData = {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      user_id: req.user?.user_id,
      timestamp: new Date().toISOString()
    };
    
    // Log slow queries (>100ms)
    if (duration > 100) {
      console.warn('Slow API request:', logData);
    }
    
    // Store performance metrics for analysis
    if (req.db) {
      req.db.query(
        'INSERT INTO api_performance_logs (method, url, status, duration_ms, user_id) VALUES ($1, $2, $3, $4, $5)',
        [req.method, req.url, res.statusCode, duration, req.user?.user_id]
      ).catch(console.error);
    }
  });
  
  next();
};

module.exports = { performanceMonitor };
```

---

This comprehensive development guide provides everything needed to understand, contribute to, and maintain the Organizational Ecosystem Application. The guide emphasizes the core architectural principles while providing practical implementation details for building a robust, scalable productivity platform.

The key to success with this architecture is maintaining the **radical simplicity** principle while leveraging the **infinite extensibility** that comes from the Event/Item dichotomy and configuration-driven approach.

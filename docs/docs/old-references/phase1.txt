Here is a detailed, comprehensive plan for executing Phase 1 and Phase 2, consolidating all the tasks from your `next.txt`, `grid plan.txt`, `privacy-browser.txt`, and our recent conversation.

This plan focuses on getting your "Enterprise MVP" ready by first solidifying the JavaScript kernel (Phase 1) and then integrating the "killer feature" (the low-code builder) on top of it (Phase 2).

---

## Phase 1: Consolidate the JS Kernel (Code Rigor & Centralization) — ✅ Completed

**Goal:** To prepare the platform for the Tauri migration by centralizing all scattered logic (sanitization, policy) into pure, stateless, and auditable kernel modules. With the latest refactor, every ingress/egress path now routes through the canonical sanitizer and policy services so downstream phases can build on a hardened core.

### 1.A: Implement Canonical `Sanitizer.js` Module — ✅
* `src/platform/security/Sanitizer.js` exports `cleanse`, `cleanseText`, and `getDeterministicHash`, with schema-aware recursion and deterministic hashing. (`Sanitizer.js`)
* Registered in the service registry so callers can reach it via `stateManager.managers.sanitizer`. (`src/platform/bootstrap/ServiceRegistry.js`)
* Kernel edge integrations:
  * Async orchestration sanitizes payload/meta/policy overrides before plugin execution. (`src/shared/lib/async/AsyncOrchestrator.js`)
  * Forensic logging cleanses and hashes envelopes prior to signing. (`src/platform/security/ForensicLogger.js`)
  * Embedding generation scrubs user strings and metadata before vectorization. (`src/platform/services/EmbeddingManager.js`)
* UI/Sync edge integrations:
  * Sync layer sanitizes outbound payloads for remote transport. (`src/platform/storage/SyncLayer.js`)
  * Bind engine scrubs inbound user input and DOM-bound data. (`src/features/ui/BindEngine.js`)
- Added a reusable async runner factory exposed by `asyncOrchestrator.createRunner()` so feature code can adopt orchestration with one import instead of hand-building option objects. (`src/shared/lib/async/AsyncOrchestrationService.js`)

### 1.B: Consolidate All Policy Enforcement — ✅
* Canonical policy definitions and validators now live under `src/platform/security/policies/` and are registered centrally. (`CoreGridPolicy.js`, `NestingPolicy.js`)
* `TenantPolicyService` owns tenant overrides, caching, and persistence while deferring to the canonical policy manager for exposure rules. (`src/platform/security/TenantPolicyService.js`)
* `GridPolicyIntegration` operates as a lightweight adapter that lazily registers policies and delegates reads/writes to the platform services, keeping feature code thin. (`src/features/grid/policies/GridPolicyIntegration.js`)

With Phase 1 hardened, future orchestration, storage, and UI work should treat the sanitizer and policy services as required dependencies rather than ad-hoc utilities.

---

## Phase 2: Integrate the "Killer Feature" (UI Engines)

**Goal:** To build the user-facing low-code "atomic element" builder by integrating all your standalone `src/features/ui/` engines, as outlined in your `next.txt` file.

### 2.A: Refactor `BuildingBlockRenderer.js`
This is the core task from your `next.txt` plan.

1.  **Convert Renderer to a "Factory":**
    * **Task:** Modify `src/features/ui/BuildingBlockRenderer.js` from a "monolith" into a "factory" that delegates all its logic.
    * **Action:** Remove the internal `_bindData` method. All data-binding logic must be delegated by calling **`src/features/ui/BindEngine.js`**.
    * **Action:** Remove the internal `_attachAction` method. All event handling logic must be delegated by calling **`src/platform/actions/ActionDispatcher.js`**.

### 2.B: Activate the UI Data Flow
This is the "wiring" part of your `next.txt` plan.

1.  **Activate "Read" Path:**
    * **Task:** Make the `BindEngine` functional.
    * **Action:** Wire `BindEngine.js` to use **`src/platform/state/StateUIBridge.js`** for simple state bindings and **`src/platform/state/QueryService.js`** for complex, query-based components.

2.  **Activate "Write" Path:**
    * **Task:** Make the `ActionDispatcher` functional.
    * **Action:** Wire `ActionDispatcher.js` to call **`src/platform/state/EventFlowEngine.js`**, which will in turn look up and execute the action from the `ActionHandlerRegistry.js`.

### 2.C: Secure the UI Pipeline
This is a critical security task from your `next.txt` plan.

1.  **Secure "Read" Path:**
    * **Action:** Modify **`BindEngine.js`** so that before it renders any data, it first calls `stateManager.managers.securityManager.canRead(subject, dataBindingPath)`. If this returns `false`, it must not render the data.
2.  **Secure "Write" Path:**
    * **Action:** Modify **`ActionDispatcher.js`** so that before it dispatches any action, it first calls `stateManager.managers.securityManager.canWrite(subject, actionName, payload)`. If this returns `false`, it must block the action and notify the `SystemToastManager.js`.

### 2.D: Build the "Builder" UI & Grid Stability
This task combines the "builder" concept with the stability roadmap from your `grid plan.txt`.

1.  **Build the "Toolbox" UI:**
    * **Task:** Create the visual drag-and-drop interface for your low-code builder.
    * **Action:** Create a new UI component (e.g., `src/features/builder/ComponentToolbox.js`).
    * **Action:** This new component must read its list of available "atomic elements" (Button, Label, `iframe_renderer`, etc.) from your existing **`src/features/grid/runtime/ComponentRegistry.js`**.

2.  **Implement Grid Stability:**
    * **Task:** Implement the "High Priority" items from `grid plan.txt`.
    * **Action (Collision):** Modify `EnhancedGridRenderer.js` to add an "occupancy map" and prevent blocks from overlapping.
    * **Action (Undo/Redo):** Modify `EnhancedGridRenderer.js` so that all drag/resize/add/remove operations are wrapped in a `stateManager.transaction()` call. This will automatically populate your `GridHistoryInspector.js` and enable the undo/redo feature.

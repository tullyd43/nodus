<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/viewmodels/event-vm.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/viewmodels/event-vm.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Event ViewModel
 *
 * Manages all event-related state and operations.
 * Follows MVVM principles - no DOM manipulation, pure state management.
 */

import appDb from "../database/db.js";
import EventModel from "../models/event.js";

class EventViewModel {
	constructor() {
		this.eventModel = new EventModel();

		// Observable state specific to events
		this.state = {
			// Data
			events: [],
			selectedEvent: null,
			eventTypes: [],

			// UI State
			isLoading: false,
			isCreating: false,
			isUpdating: false,

			// Filters specific to events
			filters: {
				status: null,
				event_type_id: null,
				due_date_from: null,
				due_date_to: null,
				project_id: null,
			},

			// Search
			searchQuery: "",
			searchResults: [],

			// Quick capture
			captureText: "",
			isCaptureProcessing: false,

			// Pagination
			currentPage: 1,
			pageSize: 50,
			totalCount: 0,
		};

		// Event listeners
		this.listeners = {
			stateChange: [],
			eventsChange: [],
			eventCreated: [],
			eventUpdated: [],
			eventDeleted: [],
			filtersChange: [],
		};
	}

	// === STATE MANAGEMENT ===

	setState(newState) {
		const previousState = { ...this.state };
		this.state = { ...this.state, ...newState };

		// Notify listeners
		this.notifyListeners("stateChange", {
			previousState,
			currentState: this.state,
			changes: newState,
		});

		// Specific notifications
		if (newState.events !== undefined) {
			this.notifyListeners("eventsChange", this.state.events);
		}

		if (newState.filters !== undefined) {
			this.notifyListeners("filtersChange", this.state.filters);
		}
	}

	getState() {
		return { ...this.state };
	}

	// === EVENT LISTENERS ===

	on(event, callback) {
		if (!this.listeners[event]) {
			this.listeners[event] = [];
		}
		this.listeners[event].push(callback);
	}

	off(event, callback) {
		if (this.listeners[event]) {
			this.listeners[event] = this.listeners[event].filter(
				(cb) => cb !== callback
			);
		}
	}

	notifyListeners(event, data) {
		if (this.listeners[event]) {
			this.listeners[event].forEach((callback) => {
				try {
					callback(data);
				} catch (error) {
					console.error(
						`Error in EventViewModel ${event} listener:`,
						error
					);
				}
			});
		}
	}

	// === DATA OPERATIONS ===

	async loadEvents() {
		try {
			this.setState({ isLoading: true });

			const events = await this.eventModel.query({
				...this.state.filters,
				page: this.state.currentPage,
				pageSize: this.state.pageSize,
			});

			this.setState({
				events,
				isLoading: false,
				totalCount: events.length, // In a real app, you'd get this from the query
			});

			return events;
		} catch (error) {
			console.error("Failed to load events:", error);
			this.setState({ isLoading: false });
			throw error;
		}
	}

	async loadEventTypes() {
		try {
			// For now, get from the database directly
			// In a full app, you'd have an EventTypeModel
			const eventTypes = await appDb.event_types
				.where("user_id")
				.equals(appDb.getCurrentUserId())
				.toArray();

			this.setState({ eventTypes });
			return eventTypes;
		} catch (error) {
			console.error("Failed to load event types:", error);
			throw error;
		}
	}

	async createEvent(eventData) {
		try {
			this.setState({ isCreating: true });

			const newEvent = await this.eventModel.create(eventData);

			// Reload events to reflect the change
			await this.loadEvents();

			this.setState({ isCreating: false });
			this.notifyListeners("eventCreated", newEvent);

			return newEvent;
		} catch (error) {
			console.error("Failed to create event:", error);
			this.setState({ isCreating: false });
			throw error;
		}
	}

	async updateEvent(eventId, updateData) {
		try {
			this.setState({ isUpdating: true });

			const updatedEvent = await this.eventModel.update(
				eventId,
				updateData
			);

			// Update the event in the current list
			const events = this.state.events.map((event) =>
				event.event_id === eventId ? updatedEvent : event
			);

			this.setState({
				events,
				isUpdating: false,
				selectedEvent: updatedEvent,
			});

			this.notifyListeners("eventUpdated", updatedEvent);

			return updatedEvent;
		} catch (error) {
			console.error("Failed to update event:", error);
			this.setState({ isUpdating: false });
			throw error;
		}
	}

	async deleteEvent(eventId) {
		try {
			await this.eventModel.delete(eventId);

			// Remove from current list
			const events = this.state.events.filter(
				(event) => event.event_id !== eventId
			);

			this.setState({
				events,
				selectedEvent:
					this.state.selectedEvent?.event_id === eventId
						? null
						: this.state.selectedEvent,
			});

			this.notifyListeners("eventDeleted", eventId);

			return true;
		} catch (error) {
			console.error("Failed to delete event:", error);
			throw error;
		}
	}

	async getEventById(eventId) {
		try {
			const event = await this.eventModel.getById(eventId);
			return event;
		} catch (error) {
			console.error("Failed to get event:", error);
			throw error;
		}
	}

	// === SELECTION ===

	selectEvent(eventId) {
		const event = this.state.events.find((e) => e.event_id === eventId);
		this.setState({ selectedEvent: event });
	}

	clearSelection() {
		this.setState({ selectedEvent: null });
	}

	// === FILTERING &amp; SEARCH ===

	async applyFilters(newFilters) {
		try {
			const updatedFilters = { ...this.state.filters, ...newFilters };
			this.setState({
				filters: updatedFilters,
				currentPage: 1, // Reset to first page when filtering
			});
			await this.loadEvents();
		} catch (error) {
			console.error("Failed to apply filters:", error);
			throw error;
		}
	}

	async clearFilters() {
		const clearedFilters = {
			status: null,
			event_type_id: null,
			due_date_from: null,
			due_date_to: null,
			project_id: null,
		};

		await this.applyFilters(clearedFilters);
	}

	async search(query) {
		try {
			this.setState({ searchQuery: query });

			if (!query.trim()) {
				this.setState({ searchResults: [] });
				return [];
			}

			// Simple search implementation
			const allEvents = await this.eventModel.query({});
			const results = allEvents.filter(
				(event) =>
					event.title.toLowerCase().includes(query.toLowerCase()) ||
					event.content.toLowerCase().includes(query.toLowerCase())
			);

			this.setState({ searchResults: results });
			return results;
		} catch (error) {
			console.error("Failed to search events:", error);
			throw error;
		}
	}

	// === QUICK CAPTURE ===

	setCaptureText(text) {
		this.setState({ captureText: text });
	}

	async quickCapture(text = null) {
		try {
			const captureText = text || this.state.captureText;

			if (!captureText.trim()) {
				throw new Error("Cannot capture empty text");
			}

			this.setState({ isCaptureProcessing: true });

			// Parse capture text for smart recognition
			const eventData = this.parseCaptureText(captureText);

			const newEvent = await this.createEvent(eventData);

			this.setState({
				isCaptureProcessing: false,
				captureText: "", // Clear capture input
			});

			return newEvent;
		} catch (error) {
			console.error("Failed to quick capture:", error);
			this.setState({ isCaptureProcessing: false });
			throw error;
		}
	}

	/**
	 * Parse capture text for smart recognition
	 */
	parseCaptureText(text) {
		const eventData = {
			title: text.trim(),
			content: text.trim(),
			tags: [],
		};

		// Extract hashtags
		const hashtagMatches = text.match(/#\w+/g);
		if (hashtagMatches) {
			eventData.tags = hashtagMatches.map((tag) => tag.substring(1));
			// Remove hashtags from title/content
			eventData.title = text.replace(/#\w+/g, "").trim();
			eventData.content = eventData.title;
		}

		// Extract due dates (simple patterns)
		const dueDatePatterns = [
			/due\s+(\d{1,2}\/\d{1,2}\/\d{2,4})/i,
			/by\s+(\d{1,2}\/\d{1,2}\/\d{2,4})/i,
			/on\s+(\d{1,2}\/\d{1,2}\/\d{2,4})/i,
		];

		for (const pattern of dueDatePatterns) {
			const match = text.match(pattern);
			if (match) {
				try {
					eventData.due_date = new Date(match[1]);
					// Remove date from title
					eventData.title = text.replace(match[0], "").trim();
					eventData.content = eventData.title;
					break;
				} catch (error) {
					// Invalid date format, ignore
				}
			}
		}

		return eventData;
	}

	// === PAGINATION ===

	async goToPage(page) {
		if (page &lt; 1) return;

		this.setState({ currentPage: page });
		await this.loadEvents();
	}

	async nextPage() {
		const maxPage = Math.ceil(this.state.totalCount / this.state.pageSize);
		if (this.state.currentPage &lt; maxPage) {
			await this.goToPage(this.state.currentPage + 1);
		}
	}

	async previousPage() {
		if (this.state.currentPage > 1) {
			await this.goToPage(this.state.currentPage - 1);
		}
	}

	// === INITIALIZATION ===

	async initialize() {
		try {
			await this.loadEventTypes();
			await this.loadEvents();
			console.log("EventViewModel initialized successfully");
		} catch (error) {
			console.error("Failed to initialize EventViewModel:", error);
			throw error;
		}
	}

	// === TEST HELPERS ===

	async createTestEvent() {
		const testEvents = [
			{
				title: "Test Task",
				content: "This is a test task #testing #important",
				tags: ["testing", "important"],
				status: "todo",
			},
			{
				title: "Meeting Notes",
				content:
					"Discussed project timeline and deliverables #work #meeting",
				tags: ["work", "meeting"],
				status: "done",
			},
			{
				title: "Buy Groceries",
				content: "Milk, eggs, bread #shopping #errands",
				tags: ["shopping", "errands"],
				due_date: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
			},
		];

		const randomEvent =
			testEvents[Math.floor(Math.random() * testEvents.length)];
		return await this.createEvent(randomEvent);
	}
}

export default EventViewModel;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MainView.html">MainView</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DB_SCHEMA">DB_SCHEMA</a></li><li><a href="global.html#generateSchemaDefinition">generateSchemaDefinition</a></li><li><a href="global.html#schema">schema</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Oct 19 2025 13:47:38 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/models/field-definition.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/models/field-definition.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Field Definition Model (V2 - Performance Optimized)
 *
 * Manages the library of custom fields, their assignment to entities, and their typed values.
 * This model implements the high-performance architecture discussed, using a dedicated
 * `custom_field_values` table instead of a generic JSONB column for storing values.
 *
 * This ensures data integrity, type safety, and significantly faster queries.
 */

import appDb from "../database/db.js";

class FieldDefinitionModel {
	constructor() {
		this.db = appDb;
	}

	/**
	 * Creates a new field definition in the library.
	 * @param {object} fieldConfig - The data for the new field.
	 * @param {string} fieldConfig.name - The name of the field (e.g., 'priority', 'budget').
	 * @param {string} fieldConfig.field_type - The type: 'text', 'integer', 'decimal', 'date', 'boolean', 'enum'.
	 * @param {object} [fieldConfig.validation_rules] - Validation rules (e.g., {min, max, options}).
	 * @param {boolean} [fieldConfig.is_indexed] - Hint for future database optimizations.
	 * @returns {Promise&lt;number>} The ID of the newly created field definition.
	 */
	async create(fieldConfig) {
		try {
			const { name, field_type, validation_rules, is_indexed } = fieldConfig;

			if (!name || !field_type) {
				throw new Error("Field name and type are required.");
			}

			const VALID_TYPES = ['text', 'integer', 'decimal', 'date', 'boolean', 'enum'];
			if (!VALID_TYPES.includes(field_type)) {
				throw new Error(`Invalid field type: ${field_type}`);
			}

			this.validateRulesForType(field_type, validation_rules);

			const field = {
				name: name,
				field_type: field_type,
				validation_rules: validation_rules || {},
				is_indexed: is_indexed || false,
				created_at: new Date(),
			};

			return await this.db.field_definitions.add(field);
		} catch (error) {
			console.error("Failed to create field definition:", error);
			throw error;
		}
	}

	/**
	 * Assigns a value for a custom field to a specific entity.
	 * It validates the value against the field's type and stores it in the `custom_field_values` table.
	 * @param {string} objectType - The type of entity ('event' or 'item').
	 * @param {number} objectId - The ID of the event or item.
	 * @param {number} fieldId - The ID of the field from the definitions library.
	 * @param {*} value - The value to assign.
	 * @returns {Promise&lt;number>} The ID of the new value assignment.
	 */
	async assignValue(objectType, objectId, fieldId, value) {
		try {
			const field = await this.db.field_definitions.get(fieldId);
			if (!field) {
				throw new Error(`Field definition with ID ${fieldId} not found.`);
			}

			const typedValue = this.castValueToType(value, field.field_type, field.validation_rules);

			// Upsert: Update existing value or create a new one
			const existingValue = await this.db.custom_field_values
				.where('[field_id+object_type+object_id]')
				.equals([fieldId, objectType, objectId])
				.first();

			if (existingValue) {
				return await this.db.custom_field_values.update(existingValue.value_id, {
					value: typedValue,
					updated_at: new Date(),
				});
			} else {
				return await this.db.custom_field_values.add({
					field_id: fieldId,
					object_type: objectType,
					object_id: objectId,
					value_type: field.field_type,
					value: typedValue,
					created_at: new Date(),
					updated_at: new Date(),
				});
			}
		} catch (error) {
			console.error("Failed to assign custom field value:", error);
			throw error;
		}
	}

	/**
	 * Retrieves all fields (definitions and their values) for a specific entity.
	 * @param {string} objectType - The type of entity ('event' or 'item').
	 * @param {number} objectId - The ID of the event or item.
	 * @returns {Promise&lt;Array&lt;object>>} An array of field objects with their definitions and values.
	 */
	async getFieldsForEntity(objectType, objectId) {
		try {
			const values = await this.db.custom_field_values
				.where('[object_type+object_id]')
				.equals([objectType, objectId])
				.toArray();

			if (values.length === 0) return [];

			const fieldIds = values.map((v) => v.field_id);
			const definitions = await this.db.field_definitions.where('field_id').anyOf(fieldIds).toArray();
			const definitionsMap = new Map(definitions.map((def) => [def.field_id, def]));

			return values.map((value) => ({
				...(definitionsMap.get(value.field_id) || {}),
				value: value.value,
			}));
		} catch (error) {
			console.error(`Failed to get fields for entity ${objectType}:${objectId}:`, error);
			throw error;
		}
	}

	/**
	 * Validates and casts a value to its proper type based on field definition.
	 * @param {*} value - The input value.
	 * @param {string} fieldType - The target type.
	 * @param {object} validationRules - The rules to validate against.
	 * @returns {*} The casted and validated value.
	 */
	castValueToType(value, fieldType, validationRules = {}) {
		if (value === null || value === undefined) return null;

		switch (fieldType) {
			case 'integer': {
				const intVal = parseInt(value, 10);
				if (isNaN(intVal)) throw new Error(`'${value}' is not a valid integer.`);
				if (validationRules.min !== undefined &amp;&amp; intVal &lt; validationRules.min) {
					throw new Error(`Value ${intVal} is below minimum of ${validationRules.min}.`);
				}
				if (validationRules.max !== undefined &amp;&amp; intVal > validationRules.max) {
					throw new Error(`Value ${intVal} exceeds maximum of ${validationRules.max}.`);
				}
				return intVal;
			}
			case 'decimal': {
				const floatVal = parseFloat(value);
				if (isNaN(floatVal)) throw new Error(`'${value}' is not a valid decimal.`);
				return floatVal;
			}
			case 'date':
				return new Date(value).toISOString();
			case 'boolean':
				return value === true || value === 'true' || value === 1;
			case 'enum':
				if (validationRules.options &amp;&amp; !validationRules.options.includes(value)) {
					throw new Error(`'${value}' is not in the allowed options: ${validationRules.options.join(", ")}.`);
				}
				return value;
			default:
				return String(value);
		}
	}

	/**
	 * Validates that the rules provided for a field type are valid.
	 * @param {string} fieldType - The field type.
	 * @param {object} rules - The validation rules.
	 */
	validateRulesForType(fieldType, rules) {
		if (!rules) return; // No rules to validate

		if (fieldType === 'integer' || fieldType === 'decimal') {
			if (rules.min !== undefined &amp;&amp; typeof rules.min !== 'number') throw new Error("Min validation rule must be a number.");
			if (rules.max !== undefined &amp;&amp; typeof rules.max !== 'number') throw new Error("Max validation rule must be a number.");
		}
		if (fieldType === 'enum') {
			if (!Array.isArray(rules.options)) throw new Error("Enum validation requires an 'options' array.");
		}
	}

    // Standard CRUD and query methods for the field definition library

    async getById(fieldId) {
        return this.db.field_definitions.get(fieldId);
    }

    async getAll() {
        return this.db.field_definitions.toArray();
    }

    async update(fieldId, updateData) {
        return this.db.field_definitions.update(fieldId, updateData);
    }

    async delete(fieldId) {
        // First, delete all values associated with this field definition
        await this.db.custom_field_values.where({ field_id: fieldId }).delete();
        // Then, delete the definition itself
        return this.db.field_definitions.delete(fieldId);
    }

	async deleteValuesForEntity(objectType, objectId) {
		try {
			return await this.db.custom_field_values
				.where({ object_type: objectType, object_id: objectId })
				.delete();
		} catch (error) {
			console.error(`Failed to delete values for entity ${objectType}:${objectId}:`, error);
			throw error;
		}
	}
}

export default FieldDefinitionModel;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MainView.html">MainView</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DB_SCHEMA">DB_SCHEMA</a></li><li><a href="global.html#generateSchemaDefinition">generateSchemaDefinition</a></li><li><a href="global.html#schema">schema</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Oct 19 2025 13:47:38 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

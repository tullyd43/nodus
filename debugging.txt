Got it. Here’s a crisp, do-now gameplan to finish polyinstantiation + clean up the remaining NATO-SECRET refinements without breaking your current demo flow.

Gameplan (executables + minimal diffs)
0) Lint baseline (already installed)

Run these first so you see only new issues from your edits:

# from repo root
npx eslint . --ext .js,.mjs --fix

1) IndexedDB schema: add the polyinstantiated store (and keep callers happy)

Goal: Ensure we have a dedicated store and indexes for polyinstantiated rows, and keep existing code that still says “objects” or “entities” from breaking.

File: src/core/storage/modules/indexeddb-adapter.js

In your upgrade handler, make sure both exist:

objects_polyinstantiated with indexes: logical_id, classification_level, updated_at

A compatibility alias for legacy callers (either keep “entities” or also create “objects” as a simple mirror if you prefer). If you don’t want duplication, keep “entities” and update any direct “objects” callers to “entities” (see Step 4).

Diff sketch (inside onupgradeneeded):

// create/ensure polyinstantiated store
if (!db.objectStoreNames.contains('objects_polyinstantiated')) {
  const os = db.createObjectStore('objects_polyinstantiated', { keyPath: 'id' });
  os.createIndex('logical_id', 'logical_id');
  os.createIndex('classification_level', 'classification_level');
  os.createIndex('updated_at', 'updated_at');
}

// (Optional) ensure 'objects' for compatibility, or correct callers to use 'entities'
if (!db.objectStoreNames.contains('objects')) {
  const os = db.createObjectStore('objects', { keyPath: 'id' });
  os.createIndex('entity_type', 'entity_type');
  os.createIndex('classification', 'classification');
  os.createIndex('updated_at', 'updated_at');
}


If you keep only entities, update any code calling store "objects" to "entities" (Step 4 shows the touch points).

Bump the version only if needed. You already upgraded to v1 in logs; set this.#version = 2 and handle the conditional creation in the upgrade function.

2) Storage: finish polyinstantiation CRUD (merge + write rules)

You already added:

#compareClassifications

get(storeName,id) to fetch/merge by logical_id when storeName === 'objects_polyinstantiated'

#mergePolyinstantiatedEntities(entities)

Now, finalize put() for poly:

File: src/core/storage/StorageLoader.js (inside class ModularOfflineStorage)

In put(storeName, item):

If storing to objects_polyinstantiated:

Lookup existing by logical_id (via adapter queryByIndex).

Determine if there’s a higher existing classification than the incoming one; if yes → create new row (different instance, do not overwrite).

If same level exists → overwrite that level’s instance.

Create composite id = \${item.logical_id}-${item.classification_level}`` (keeps keyPath simple).

Enforce MAC “no write down” on the container label (you already wired MAC in).

Already in your code (from the screenshot) – keep it; just ensure:

record.id = ${item.logical_id}-${item.classification_level} before indexeddb.put.

instance_data holds the original item payload for that level.

3) Transparent crypto stays off in demo

You’ve got demoMode → demo-crypto. Keep it. No changes needed now. For production you’ll switch to real crypto modules. (We’ll wire constant-time padding below).


4) Callers alignment: use the right store

Audit the 3 main touch points:

EventFlowEngine currently queries "objects", "entity_type", "event_flow".
Either ensure you created an objects store (Step 1) or change to "entities".
Recommended now: Create objects as compatibility so you don’t touch a bunch of files mid-refactor.

HybridStateManager.saveEntity/loadEntity:

Normal entities → "objects" (compat store) or "entities".

Polyinstantiated entities (those with logical_id + classification_level) → "objects_polyinstantiated".

Add a tiny helper to decide the store:

// HybridStateManager.js (where you call storage.instance.put/get)
const storeFor = (e) => e?.logical_id && e?.classification_level 
  ? 'objects_polyinstantiated' 
  : 'objects'; // or 'entities' if you skipped the alias

await this.storage.instance.put(storeFor(entity), entity);


When reading a logical entity that might be polyinstantiated: call

await this.storage.instance.get('objects_polyinstantiated', logicalId);


and let your merge logic return the “effective” view for the current subject. (You already coded the MAC filter + merge path.)

5) Constant-time access checks (timing channel padding)

File: src/core/security/ct.js

export async function constantTimeCheck(fn, minMs = 100) {
  const start = performance.now();
  let result, err;
  try { result = await fn(); } catch (e) { err = e; }
  const elapsed = performance.now() - start;
  const pad = Math.max(0, minMs - elapsed);
  await new Promise(r => setTimeout(r, pad));
  if (err) throw err;
  return result;
}


Use it in reads that could leak via timing (e.g., ModularOfflineStorage.get when filtering by MAC):

return constantTimeCheck(async () => {
  const raw = await this.#modules.indexeddb?.get(store, id);
  if (!raw) return null;
  const filtered = this.#filterReadable([raw]);
  return filtered.length ? filtered[0] : null;
}, 100);

6) Information Flow Tracker (minimal hook)

File: src/core/security/InformationFlowTracker.js

export class InformationFlowTracker {
  constructor(emit) { this.emit = emit; }
  derived(fromLabels = [], derivedLabel, meta = {}) {
    // record derivation edges for audit + downstream policy
    this.emit?.('infoFlow', { fromLabels, derivedLabel, ...meta, ts: Date.now() });
  }
}


Wire it in places where you transform/aggregate (e.g., after merge of poly rows):

this.stateManager?.informationFlow?.derived(
  readableEntities.map(e => ({ level: e.classification_level, compartments: e.compartments })),
  { level: highestClassification },
  { operation: 'poly_merge', logical_id: id }
);


Add to HSM:

// in HybridStateManager constructor
this.informationFlow = new (await import('@core/security/InformationFlowTracker.js')).InformationFlowTracker(
  (evt) => this.emit('securityEvent', evt)
);

7) CDS Workflow skeleton (just enough to unblock)

File: src/core/security/cds.js

export class CrossDomainSolution {
  constructor({ emit }) { this.emit = emit; }
  async requestDowngrade({ dataId, fromLevel, toLevel, justification }) {
    this.emit?.('cdsEvent', { type: 'request_downgrade', dataId, fromLevel, toLevel, justification, ts: Date.now() });
    // Persist a CDS ticket to the DB (objects: entity_type='cds_ticket')
    // For now, return a stub ticket id
    return { ticketId: crypto.randomUUID(), status: 'pending' };
  }
  async requestUpgrade({ dataId, fromLevel, toLevel, source }) {
    this.emit?.('cdsEvent', { type: 'request_upgrade', dataId, fromLevel, toLevel, source, ts: Date.now() });
    return { ticketId: crypto.randomUUID(), status: 'pending' };
  }
}


Wire it in HSM so UI can drive the workflow later.

8) Non-repudiation (PKI) placeholder that won’t block demo

You already added CryptoDomain etc. For now, add a stable interface:

File: src/core/security/NonRepudiation.js

export class NonRepudiation {
  async signAction({ userId, action, label }) {
    // demo: create a detached JWS-like stub
    const payload = JSON.stringify({ userId, action, label, ts: Date.now() });
    const signature = btoa(payload); // replace with real JWS later
    return { signature, algorithm: 'demo-stub', timestamp: new Date().toISOString() };
  }
}


Call it from your audit trail code just before persisting an audit record.



9) ESLint blockers you still have (quick wins)

Private fields must be declared at top of the class:

File: src/core/storage/SyncLayer.js

export default class SyncLayer {
  #autoSyncInterval = null;  // ✅ declare it here
  //...
}


File: src/core/storage/modules/batch-sync.js

export default class BatchSync {
  #flushQueue = null;  // ✅ declare it here (or #syncQueue if that’s the one you meant)
  #syncQueue = [];
  //...
}


Empty block:

File: src/utils/MetricsReporter.js (line ~489)

- if (something) { }
+ if (something) { /* intentionally empty: metric suppressed in demo */ }


Browser globals errors (performance, navigator, localStorage, etc.):
Already fixed by the flat config using env: { browser: true }. If any remain, add file-level pragmas where it’s node-only or test-only:

/* eslint-env browser */


Undefined symbols like showGridToast
Either import it or guard with window?.showGridToast?.(...).

When done:

npx eslint . --ext .js,.mjs --fix

10) Smoke test checklist (quick)

Demo mode true: confirm logs show demo-crypto loaded and no encryption errors.

Seed two rows for the same logical_id at different classification_levels in objects_polyinstantiated.

Call get('objects_polyinstantiated', logicalId):

With subject at confidential: only merge levels ≤ confidential.

With subject at secret: merged data prefers fields from secret where overlapping.

Observe EventFlowEngine no longer complains about missing stores.

ESLint returns zero errors (warnings OK for now).
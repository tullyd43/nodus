t it. Here’s a comprehensive, do-now plan to close the NATO SECRET gaps you listed, mapped onto your Nodus stack (HybridStateManager → StorageLoader → Security layers → DB), with concrete patches, schemas, and test hooks.

Phase 0 — Golden Rules (apply immediately)

Deny-by-default & MAC overrides RBAC

Everywhere a permission decision is made, call MAC.enforce*() first; only if it passes, evaluate RBAC.

Make the MAC outcome non-bypassable: return hard errors and emit accessDenied(MAC) events.

Per-classification crypto domains

Separate keys per {classification, compartments}; never reuse keys across domains.

Envelope encryption with KMS/HSM; DB stores ciphertext only.

Uniform errors & constant-time

Replace all “Forbidden vs Not Found” branches with a single constant-latency response envelope to eliminate timing/semantic channels.

Phase 1 — Immediate (2–4 months)
1) Mandatory Access Control (Bell-LaPadula) – engine + integration
JS core (client) — src/core/security/MACEngine.js
// Bell–LaPadula: simple lattice with dominance relation
const LEVELS = ["unclassified","confidential","secret","nato_secret"];
const rank = (lvl) => LEVELS.indexOf(String(lvl || "").toLowerCase());

export class MACEngine {
  constructor({ getUserClearance, getCompartments }) {
    this.getUserClearance = getUserClearance;       // () => { level, compartments:Set<string> }
    this.getCompartments  = getCompartments;        // for data object or container
  }

  // No Read Up: subject.level >= object.level AND compartments superset
  canRead(subject, object) {
    const sl = rank(subject.level), ol = rank(object.level);
    if (sl < 0 || ol < 0) return false;
    if (sl < ol) return false; // no read up
    return this.#compartmentSuperset(subject.compartments, object.compartments);
  }

  // No Write Down: subject.level <= object.level AND compartments subset
  canWrite(subject, object) {
    const sl = rank(subject.level), ol = rank(object.level);
    if (sl > ol) return false; // no write down
    return this.#compartmentSubset(subject.compartments, object.compartments);
  }

  enforceNoReadUp(subject, object)  { if (!this.canRead(subject, object))  throw new Error("MAC_DENY_READ"); }
  enforceNoWriteDown(subject, object){ if (!this.canWrite(subject, object)) throw new Error("MAC_DENY_WRITE"); }

  #compartmentSuperset(a, b){ for (const x of (b||[])) if (!a?.has?.(x)) return false; return true; }
  #compartmentSubset(a, b){ for (const x of (a||[])) if (!b?.has?.(x)) return false; return true; }
}

Hook into existing checks

ComposableSecurity (RBAC) must defer to MAC:

const subj = this.context.getUserClearance();      // { level, compartments:Set }
const obj  = { level: entity.classification, compartments: new Set(entity.compartments||[]) };

try {
  this.mac.enforceNoReadUp(subj, obj); // or enforceNoWriteDown on writes
} catch {
  this.stateManager.emit("accessDenied", { reason: "MAC", entityId: entity.id });
  throw new Error("ACCESS_DENIED"); // stop before RBAC
}

// …then RBAC role/perm decision…


StorageLoader CRUD wrappers: pre-check with MAC before any fetch/save.

Server/API gateway

Mirror the exact MAC checks server-side (same lattice, same compartments) so client bypass can’t succeed.

2) Polyinstantiation (multi-level versions of same logical object)
SQL (PostgreSQL 18)
CREATE TYPE classification_level AS ENUM ('unclassified','confidential','secret','nato_secret');

CREATE TABLE objects_poly (
  logical_id          uuid       NOT NULL,
  classification      classification_level NOT NULL,
  compartments        text[]     NOT NULL DEFAULT '{}',
  version             int        NOT NULL DEFAULT 1,
  instance_data       jsonb      NOT NULL,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (logical_id, classification, compartments)
);

-- Index for per-level lookups & compartments (GIN)
CREATE INDEX ix_objects_poly_level ON objects_poly (classification);
CREATE INDEX ix_objects_poly_comp ON objects_poly USING gin (compartments);
CREATE INDEX ix_objects_poly_logical ON objects_poly (logical_id);

-- RLS on: deny by default
ALTER TABLE objects_poly ENABLE ROW LEVEL SECURITY;

-- SECURITY DEFINER view that applies MAC automatically
CREATE OR REPLACE FUNCTION mac_can_read(_lvl classification_level, _comps text[])
RETURNS boolean LANGUAGE sql IMMUTABLE AS $$
  -- Placeholder: inject Bell-LaPadula dominance + compartment superset logic server-side
  SELECT true;
$$;

CREATE POLICY p_mac_read ON objects_poly
  FOR SELECT USING (mac_can_read(classification, compartments));


You’ll implement mac_can_read to mirror the lattice/compartment checks (either in PL/pgSQL or via a lookup table).

Access pattern

Application reads via a definer view v_objects_for_session that injects the current session’s clearance/compartments (set via SET app.clearance = 'secret'; SET app.compartments = '{BLUE,ALPHA}').

Writes route to the matching (logical_id, classification, compartments) row; no write down enforced via trigger.

3) Covert channel protections (first wave)
Constant-time checks
function fixedDelay(ms) { const start = performance.now(); while (performance.now() - start < ms) {} }

export async function macGuarded(fn, opts={padMs:12}) {
  const start = performance.now();
  try { return await fn(); }
  finally {
    const elapsed = performance.now() - start;
    const pad = Math.max(0, opts.padMs - elapsed);
    fixedDelay(pad);                      // pad to fixed floor
  }
}


Wrap all deny paths (MAC_DENY_READ/WRITE) and “not found” responses the same way.

Uniform error envelope: { ok:false, code:"ACCESS_DENIED" } (no hints).

Resource shaping (storage channels)

Per-classification quotas for write rate, payload size, and queue length; apply same error + fixed delay when exceeded.

Disable high-resolution timers to untrusted code paths (e.g., avoid exposing perf markers to user scripts in classified contexts).

4) Information Flow Control (label/taint propagation)

Introduce labels in memory and events:

// Minimal taint label
function labelOf(entity){ return { level: entity.classification, compartments: new Set(entity.compartments||[]) }; }

// When transforming/aggregating:
function mergeLabels(a, b){
  // lattice join: max(level), union(compartments)
  const LEVELS = ["unclassified","confidential","secret","nato_secret"];
  const lvl = LEVELS[Math.max(LEVELS.indexOf(a.level), LEVELS.indexOf(b.level))];
  const comps = new Set([...(a.compartments||[]), ...(b.compartments||[])]);
  return { level: lvl, compartments: comps };
}


HybridStateManager: attach label onto state slices, events, cache entries.

Before emit/render/save: MAC-check subject vs target label.

5) Cryptographic separation by classification/compartment
KMS mapping
export function getCryptoDomain({ classification, compartments=[] }) {
  const base = classification.toLowerCase();
  const compKey = compartments.sort().join("+") || "none";
  return `${base}::${compKey}`; // e.g., "secret::ALPHA+BLUE"
}


Keyring: { domain → {alg, kid} }; keys in HSM/KMS per domain.

StorageLoader encrypts payload using the correct domain before persistence.

Never decrypt cross-domain to re-encrypt; use CDS workflow (see below).

6) Non-repudiation (PKI + TSA) — first cut
Tables
CREATE TABLE action_signatures (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  actor_id uuid NOT NULL,
  action   text NOT NULL,
  classification classification_level NOT NULL,
  payload_digest bytea NOT NULL,
  signature bytea NOT NULL,
  cert_chain bytea NOT NULL,
  tsa_token bytea,
  created_at timestamptz NOT NULL DEFAULT now()
);

Code stub
class NonRepudiation {
  async signAction({actorId, action, classification, payload}) {
    const digest = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
    // Use smart card / OS keystore: WebAuthn/PKCS#11 bridge (platform-specific)
    const { signature, certChain } = await this.pkiSign(Buffer.from(digest));
    const tsa = await this.requestTimestampToken(digest); // RFC 3161 TSA

    await api.storeSignature({ actorId, action, classification, digest, signature, certChain, tsa });
  }
}

7) Cross-Domain Solution (CDS) interface
Tables
CREATE TABLE cds_requests (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  logical_id uuid NOT NULL,
  from_level classification_level NOT NULL,
  to_level classification_level NOT NULL,
  compartments_from text[] NOT NULL,
  compartments_to   text[] NOT NULL,
  direction text NOT NULL CHECK (direction IN ('upgrade','downgrade')),
  status text NOT NULL DEFAULT 'pending',
  justification text,
  sanitization_profile text,     -- which redaction/sanitizer set to use
  approver_chain jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

Flow

request → queue → 2-person integrity approvals → sanitization pipeline (pluggable redactors) → write target instance in objects_poly.

Emit cds.requested, cds.approved, cds.completed, cds.denied.

8) Secure Destruction (crypto-erasure)

Keep per-domain DEK wrapped with KEK in KMS.

Destroy data by revoking KEK (rendering all DEKs unusable).

For media that requires overwrite: schedule certified wipe and record:

CREATE TABLE destruction_certificates (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  logical_id uuid NOT NULL,
  classification classification_level NOT NULL,
  method text NOT NULL,             -- "crypto-erasure" | "NIST-3pass"
  verifier text,                    -- person or system
  evidence jsonb,                   -- logs, device serials, etc.
  created_at timestamptz DEFAULT now()
);

Phase 2 — Advanced (6–12 months)
9) MLS database hardening

Partition tables by classification into separate tablespaces with independent TDE keys (filesystem or cloud KMS).

Evaluate Trusted PostgreSQL (SE-PostgreSQL) or PostgreSQL + SELinux MLS policies if deployable in your stack.

Ensure server-side MAC in PL/pgSQL matches client logic; RLS + policies + definer views for all access paths.

10) Trusted Path

Mutual TLS with client certs bound to user identity (smart card/FIDO2).

Pinning & attestation on client; mandate secure attention (trusted UI page for classified ops).

Disable mixed content; Content Security Policy locked.

Integration Points (Nodus)

HybridStateManager

Add this.mac = new MACEngine(contextProviders);

Subscribe: accessDenied(MAC), cds.*, nonrep.*;

Enforce MAC in saveEntity, loadEntity, emit paths for labeled data.

StorageLoader

Before .get/.put: call MAC.enforce*();

Resolve crypto domain → encrypt/decrypt with per-domain KMS key;

Polyinstantiation aware: choose row by {logical_id, classification, compartments}.

ComposableSecurity

Call MAC first; only then RBAC (roles/scopes).

EventFlowEngine

Carry label on event payloads; checked at each subscriber boundary.

Tests you can run now

MAC E2E (Jest)

test("no read up / no write down", () => {
  const mac = new MACEngine({ getUserClearance:()=>({level:"confidential", compartments:new Set(["BLUE"])}) });
  const secretObj = { level:"secret", compartments:new Set(["BLUE"]) };
  expect(() => mac.enforceNoReadUp(mac.getUserClearance(), secretObj)).toThrow("MAC_DENY_READ");
});


Constant-time envelope

Measure variance for allow/deny across 1k calls → assert within tolerance window (e.g., ±1ms around padded floor).

Polyinstantiation SQL

Insert (logical_id=A, classification='secret') and ('confidential'); ensure RLS returns only the dominated one for a confidential session.

Crypto domain routing

For {secret, [ALPHA]} vs {secret, [BLUE]}, assert different KMS key IDs used.

Non-repudiation

Store signature + TSA; verify with offline validator.

CDS workflow

Simulate downgrade request → require 2 approvers → sanitizer removes fields → writes new instance.

Minimal Patches (drop-in)

Lock MAC pre-checks everywhere (StorageLoader CRUD, ComposableSecurity, HybridStateManager.emit/save).

Add polyinstantiation tables + RLS + definer views (SQL above).

Add crypto domain mapping and per-domain KMS keys in your encryption module.

Wrap responses in constant-time envelope and unify errors.

Add non-repudiation tables and a signing stub; call on classified operations.

Add CDS tables and stub endpoints (/cds/request, /cds/approve, /cds/complete).

Add destruction certificates table and crypto-erasure operation (KEK revoke).
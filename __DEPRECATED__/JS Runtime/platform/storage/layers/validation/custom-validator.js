// modules/custom-validator.js
// Custom validation module for user-defined business rules

/* eslint-disable nodus/require-async-orchestration */

/**
 * @file custom-validator.js
 * @version 8.0.0
 * @description Enterprise custom validation module with a secure, declarative rule engine.
 * Provides automatic observability, policy compliance, and robust error handling for user-defined business rules.
 * All validation operations flow through orchestrated patterns for complete audit trails and performance monitoring.
 *
 * @module CustomValidator
 *
 * @privateFields {
 *   #customRules,
 *   #ruleEngine,
 *   #stateManager,
 *   #managers,
 *   #errorBoundary,
 *   #actionDispatcher,
 *   #policies,
 *   #runner
 * }
 */
export default class CustomValidator {
	/** @private @type {Map<string, object>} */
	#customRules = new Map();
	/** @private */
	#ruleEngine = null;
	/** @private @type {import('../../HybridStateManager.js').default|null} */
	#stateManager;
	/** @private @type {object} */
	#managers;
	/** @private @type {import('@shared/lib/ErrorHelpers.js').ErrorBoundary|null} */
	#errorBoundary = null;
	/** @private @type {import('@platform/actions/ActionDispatcher.js').default|null} */
	#actionDispatcher = null;
	/** @private @type {import('@platform/policies/PolicyEngineAdapter.js').default|null} */
	#policies = null;
	/** @private @type {ReturnType<import("@shared/lib/async/AsyncOrchestrationService.js").AsyncOrchestrationService["createRunner"]>} */
	#runner;

	/** @public @type {string} */
	name = "CustomValidator";
	/** @public @type {string} */
	type = "business";
	/** @public @type {string[]} */
	supports = ["objects", "events", "relationships"];

	/**
	 * Creates an instance of CustomValidator.
	 * @param {object} context - The application context.
	 * @param {import('../../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 * @param {Array<object>} [context.customRules=[]] - An array of predefined custom rule objects.
	 * @param {object} [context.options={}] - Configuration options for the validator and its rule engine.
	 */
	constructor({ stateManager, customRules = [], options = {} }) {
		this.#stateManager = stateManager;

		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from stateManager
		this.#managers = stateManager?.managers || {};
		this.#actionDispatcher = this.#managers.actionDispatcher;
		this.#policies = this.#managers.policies;
		this.#errorBoundary =
			this.#managers.errorHelpers?.createErrorBoundary(
				{
					name: "CustomValidator",
					managers: this.#managers,
				},
				"CustomValidator"
			) || null;

		const orchestrator = this.#managers.asyncOrchestrator;
		if (!orchestrator) {
			throw new Error(
				"CustomValidator requires AsyncOrchestrationService for compliance."
			);
		}

		this.#runner = orchestrator.createRunner({
			labelPrefix: "validation.custom",
			actorId: "validation.custom",
			eventType: "CUSTOM_VALIDATION_OPERATION",
			meta: { component: "CustomValidator" },
		});

		this.#ruleEngine = new ValidationRuleEngine({
			stateManager,
			...options,
		});
		this.#loadCustomRules(customRules);
	}

	/**
	 * Centralized orchestration wrapper for consistent observability and policy enforcement.
	 * @private
	 * @param {string} operationName - Operation identifier for metrics and logging.
	 * @param {Function} operation - Synchronous function that returns a Promise to execute.
	 * @param {object} [options={}] - Additional orchestrator options.
	 * @returns {Promise<any>}
	 */
	#runOrchestrated(operationName, operation, options = {}) {
		if (!this.#policies?.getPolicy("validation", "enabled")) {
			this.#dispatchAction("validation.custom.policy_disabled", {
				operation: operationName,
			});
			return Promise.resolve(null);
		}

		/* PERFORMANCE_BUDGET: 5ms */
		return this.#runner.run(
			() => this.#errorBoundary?.try(operation) || operation(),
			{
				label: `validation.custom.${operationName}`,
				classification: "INTERNAL",
				...options,
			}
		);
	}

	/**
	 * Initializes the custom validator and its rule engine.
	 * @returns {Promise<this>} The initialized validator instance.
	 */
	/**

	 * TODO: Add JSDoc for method init
	 * @memberof AutoGenerated
	 */
	init() {
		return this.#runOrchestrated("init", async () => {
			await this.#ruleEngine.init();
			return this;
		});
	}

	/**
	 * Adds a new custom validation rule to the validator's rule set.
	 * This allows for dynamic extension of validation logic at runtime.
	 * @param {string} ruleName - A unique name for the rule.
	 * @param {object} ruleDefinition - The definition of the rule, including its logic and metadata.
	 */
	/**

	 * TODO: Add JSDoc for method addRule
	 * @memberof AutoGenerated
	 */
	addRule(ruleName, ruleDefinition) {
		this.#customRules.set(ruleName, {
			...ruleDefinition,
			name: ruleName,
			createdAt: Date.now(),
		});

		this.#dispatchAction("validation.custom.rule_added", {
			ruleName,
			entityType: ruleDefinition.entityType,
		});
	}

	/**
	 * Removes a custom validation rule from the validator's rule set.
	 * @param {string} ruleName - The name of the rule to remove.
	 * @returns {boolean} True if the rule was successfully removed, false otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method removeRule
	 * @memberof AutoGenerated
	 */
	removeRule(ruleName) {
		if (this.#customRules.delete(ruleName)) {
			this.#dispatchAction("validation.custom.rule_removed", {
				ruleName,
			});
			return true;
		}
		return false;
	}

	/**
	 * Main validation entry point
	 * @param {object} entity - The entity to validate against custom rules.
	 * @param {object} [context={}] - The validation context.
	 * @returns {Promise<object>} A validation result object.
	 */
	/**

	 * TODO: Add JSDoc for method validate
	 * @memberof AutoGenerated
	 */
	validate(entity, context = {}) {
		return this.#runOrchestrated(
			"validate",
			async () => {
				return this.#executeValidate(entity, context);
			},
			{
				meta: {
					entityId: entity?.id,
					entityType: entity?.entity_type,
				},
			}
		);
	}

	async #executeValidate(entity, context) {
		const errors = [];
		const warnings = [];
		const ruleResults = [];

		const applicableRules = this.#getApplicableRules(entity);

		/* PERFORMANCE_BUDGET: 50ms */
		for (const rule of applicableRules) {
			const result = await this.#executeRule(rule, entity, context);

			ruleResults.push({
				ruleName: rule.name,
				passed: result.passed,
				message: result.message,
			});

			if (!result.passed) {
				if (rule.severity === "error") {
					errors.push(result.message);
				} else {
					warnings.push(result.message);
				}
			}
		}

		this.#dispatchAction("validation.custom.entity_validated", {
			entityId: entity.id,
			valid: errors.length === 0,
			errorCount: errors.length,
			warningCount: warnings.length,
		});

		return {
			valid: errors.length === 0,
			errors,
			warnings,
			ruleResults,
			validator: this.name,
		};
	}

	/**
	 * Validates a single field's value against all applicable field-specific custom rules.
	 * @param {string} entityType - The type of the entity.
	 * @param {string} fieldName - The name of the field to validate.
	 * @param {*} value - The value of the field.
	 * @param {object} [context={}] - The validation context.
	 * @returns {Promise<object>} A validation result object for the field.
	 */
	/**

	 * TODO: Add JSDoc for method validateField
	 * @memberof AutoGenerated
	 */
	validateField(entityType, fieldName, value, context = {}) {
		return this.#runOrchestrated(
			"validateField",
			() =>
				this.#executeValidateField(
					entityType,
					fieldName,
					value,
					context
				),
			{ meta: { entityType, fieldName } }
		);
	}

	async #executeValidateField(entityType, fieldName, value, context) {
		const errors = [];
		const warnings = [];

		const fieldRules = Array.from(this.#customRules.values()).filter(
			(rule) =>
				rule.scope === "field" &&
				rule.entityType === entityType &&
				rule.fieldName === fieldName
		);

		/* PERFORMANCE_BUDGET: 20ms */
		for (const rule of fieldRules) {
			const result = await this.#executeFieldRule(rule, value, context);

			if (!result.passed) {
				if (rule.severity === "error") {
					errors.push(result.message);
				} else {
					warnings.push(result.message);
				}
			}
		}

		return {
			valid: errors.length === 0,
			errors,
			warnings,
		};
	}

	/**
	 * Checks if this validator has any applicable rules for a given entity.
	 * This is used by the `ValidationStack` to determine if this validator should run.
	 * @param {object} entity - The entity to check.
	 * @param {object} context - The validation context.
	 * @returns {boolean} `true` if there are applicable rules for this entity.
	 */
	/**

	 * TODO: Add JSDoc for method isApplicableFor
	 * @memberof AutoGenerated
	 */
	isApplicableFor(entity, _context) {
		return this.#getApplicableRules(entity).length > 0;
	}

	/**
	 * Checks if this validator has any applicable rules for a specific field.
	 * @param {string} entityType - The type of the entity.
	 * @param {string} fieldName - The name of the field.
	 * @returns {boolean} True if there are applicable rules for this field.
	 */
	/**

	 * TODO: Add JSDoc for method supportsField
	 * @memberof AutoGenerated
	 */
	supportsField(entityType, fieldName) {
		return Array.from(this.#customRules.values()).some(
			(rule) =>
				rule.scope === "field" &&
				rule.entityType === entityType &&
				rule.fieldName === fieldName
		);
	}

	/**
	 * Retrieves performance and usage metrics for the custom validator.
	 * @returns {object} An object containing performance and usage metrics.
	 */
	/**

	 * TODO: Add JSDoc for method getMetrics
	 * @memberof AutoGenerated
	 */
	getMetrics() {
		const metrics =
			this.#managers.metricsRegistry?.namespace("customValidator") || {};
		return {
			...(metrics.getAllAsObject?.() || {}),
			rulesLoaded: this.#customRules.size,
		};
	}

	/**
	 * Retrieves a list of all currently loaded custom rules.
	 * @returns {Array<object>} A list of the currently loaded custom rules.
	 */
	/**

	 * TODO: Add JSDoc for method getRules
	 * @memberof AutoGenerated
	 */
	getRules() {
		return Array.from(this.#customRules.entries()).map(([name, rule]) => ({
			name,
			description: rule.description,
			entityType: rule.entityType,
			scope: rule.scope,
			severity: rule.severity,
			enabled: rule.enabled !== false,
		}));
	}

	// Private methods
	/**
	 * Loads an initial set of custom rules.
	 * @private
	 * @param {Array<object>} customRules - The rules to load.
	 */
	#loadCustomRules(customRules) {
		for (const rule of customRules) {
			this.addRule(rule.name, rule);
		}
	}

	/**
	 * Filters the loaded rules to find ones applicable to a given entity.
	 * @private
	 * @param {object} entity - The entity being validated.
	 * @returns {Array<object>} A list of applicable rules.
	 */
	#getApplicableRules(entity) {
		return Array.from(this.#customRules.values()).filter((rule) => {
			// Check if rule is enabled
			if (rule.enabled === false) return false;

			// Check entity type match
			if (rule.entityType && rule.entityType !== entity.entity_type)
				return false;

			// Check scope (entity-level rules)
			if (rule.scope !== "entity") return false;

			// Check conditions
			if (rule.conditions) {
				return this.#evaluateConditions(rule.conditions, entity);
			}

			return true;
		});
	}

	/**
	 * Evaluates a set of conditions against an entity.
	 * @private
	 * @param {Array<object>} conditions - The conditions to evaluate.
	 * @param {object} entity - The entity to check against.
	 * @returns {boolean} True if all conditions pass.
	 */
	async #evaluateConditions(conditions, entity) {
		const conditionRegistry =
			this.#stateManager?.managers?.conditionRegistry;
		if (!conditionRegistry) {
			this.#dispatchAction("validation.custom.condition_eval_failed", {
				reason: "ConditionRegistry not available.",
			});
			return false;
		}

		// The context for evaluation is the entity itself.
		// The ConditionRegistry expects a context object.
		const evaluationContext = { entity };

		// V8.0 Parity: Mandate 2.2 - Delegate evaluation to the central, secure ConditionRegistry.
		// This avoids hardcoded logic and supports complex, nested conditions.
		const conditionSet = {
			type: "and", // All conditions in the array must pass.
			conditions,
		};

		return await conditionRegistry.evaluate(
			conditionSet,
			evaluationContext
		);
	}

	/**
	 * Safely retrieves a nested property value from an object using a dot-notation path.
	 * @private
	 * @param {object} obj - The object to query.
	 * @param {string} path - The dot-notation path (e.g., 'a.b.c').
	 * @returns {*} The value at the specified path, or undefined if not found.
	 */
	#getNestedValue(obj, path) {
		if (!path || typeof path !== "string") return undefined;
		return path.split(".").reduce((current, key) => current?.[key], obj);
	}

	/**
	 * Executes a validation rule based on its type.
	 * @private
	 * @param {object} rule - The rule to execute.
	 * @param {object} entity - The entity being validated.
	 * @param {object} context - The validation context.
	 * @returns {Promise<object>} The result of the rule execution.
	 */
	async #executeRule(rule, entity, context) {
		switch (rule.type) {
			case "expression":
				return await this.#executeExpressionRule(rule, entity, context);
			case "regex":
				return await this.#executeRegexRule(rule, entity, context);
			case "lookup":
				return await this.#executeLookupRule(rule, entity, context);
			default:
				throw new Error(`Unknown rule type: ${rule.type}`);
		}
	}

	/**
	 * Executes a rule defined by a simple expression.
	 * @private
	 * @param {object} rule - The expression rule to execute.
	 * @param {object} entity - The entity being validated.
	 * @param {object} context - The validation context.
	 * @returns {Promise<object>} The result of the rule execution.
	 */

	async #executeExpressionRule(rule, entity, _context) {
		const expression = rule.expression;
		const variables = { ...entity, ..._context };

		try {
			const result = this.#ruleEngine.evaluateExpression(
				expression,
				variables
			);

			return {
				passed: Boolean(result),
				message: result
					? `Expression rule ${rule.name} passed`
					: `Expression rule ${rule.name} failed: ${expression}`,
			};
		} catch (error) {
			throw new Error(`Expression evaluation failed: ${error.message}`);
		}
	}

	/**
	 * Executes a rule defined by a regular expression pattern.
	 * @private
	 * @param {object} rule - The regex rule to execute.
	 * @param {object} entity - The entity being validated.
	 * @param {object} context - The validation context.
	 * @returns {Promise<object>} The result of the rule execution.
	 */
	async #executeRegexRule(rule, entity, _context) {
		const fieldValue = this.#getNestedValue(entity, rule.field);
		const regex = new RegExp(rule.pattern, rule.flags || "i");

		const passed = regex.test(String(fieldValue || ""));

		return {
			passed,
			message: passed
				? `Field ${rule.field} matches pattern`
				: `Field ${rule.field} does not match required pattern`,
		};
	}

	/**
	 * Executes a rule that looks up a value in a predefined list.
	 * @private
	 * @param {object} rule - The lookup rule to execute.
	 * @param {object} entity - The entity being validated.
	 * @param {object} context - The validation context.
	 * @returns {Promise<object>} The result of the rule execution.
	 */
	async #executeLookupRule(rule, entity, _context) {
		const lookupValue = this.#getNestedValue(entity, rule.field);

		// Simulate lookup (in real implementation, this would query a database/API)
		const validValues = rule.lookupTable || [];
		const passed = validValues.includes(lookupValue);

		return {
			passed,
			message: passed
				? `Field ${rule.field} has valid value`
				: `Field ${rule.field} contains invalid value: ${lookupValue}`,
		};
	}

	/**
	 * Executes a rule specifically for a single field's value.
	 * @private
	 * @param {object} rule - The rule to execute.
	 * @param {*} value - The field value to validate.
	 * @param {object} context - The validation context.
	 * @returns {Promise<object>} The result of the rule execution.
	 */
	async #executeFieldRule(rule, value, _context) {
		// Create field-specific entity for rule execution
		const fieldEntity = { [rule.fieldName]: value };
		return await this.#executeRule(rule, fieldEntity, context);
	}

	/**
	 * Dispatches an action through the ActionDispatcher for observability.
	 * @private
	 * @param {string} actionType - Type of action to dispatch
	 * @param {object} payload - Action payload
	 */
	#dispatchAction(actionType, payload) {
		try {
			/* PERFORMANCE_BUDGET: 2ms */
			this.#actionDispatcher?.dispatch(actionType, {
				...payload,
				component: "CustomValidator",
			});
		} catch (error) {
			console.error(
				`[CustomValidator] Failed to dispatch action ${actionType}:`,
				error
			);
		}
	}
}

/**
 * A simple expression evaluation engine for custom validation rules.
 * @private
 */
class ValidationRuleEngine {
	/** @private @type {import('../../HybridStateManager.js').default} */
	#stateManager;

	/**
	 * Creates an instance of ValidationRuleEngine.
	 * @param {object} context - The application context.
	 * @param {import('../../HybridStateManager.js').default} context.stateManager - The main state manager instance.
	 */
	/**
	 * TODO: Add JSDoc for method constructor
	 * @memberof AutoGenerated
	 */
	constructor({ stateManager }) {
		this.#stateManager = stateManager;
	}

	/**
	 * Initializes the rule engine.
	 * @returns {Promise<this>} The initialized engine.
	 */
	/**
	 * TODO: Add JSDoc for method init
	 * @memberof AutoGenerated
	 */
	async init() {
		// Initialize expression engine
		return this;
	}

	/**
	 * Evaluates a simple expression with a given set of variables.
	 * @param {string} expression - The expression to evaluate (e.g., "status == 'active'").
	 * @param {object} variables - An object of variables to substitute into the expression.
	 * @returns {*} The result of the expression evaluation.
	 */
	/**
	 * TODO: Add JSDoc for method evaluateExpression
	 * @memberof AutoGenerated
	 */
	evaluateExpression(expression, _variables) {
		// The use of `new Function()` is a security risk and has been removed.
		// All logic is now handled by the secure, declarative ConditionRegistry.
		const conditionRegistry =
			this.#stateManager?.managers?.conditionRegistry;
		if (!conditionRegistry) {
			throw new Error(
				"ConditionRegistry is not available for expression evaluation."
			);
		}

		// The expression is now expected to be a declarative condition object.
		const condition = {
			type: "evaluate_logical",
			...expression, // Assume the expression is now a declarative condition object
		};

		// The evaluation context is the `variables` object.
		return conditionRegistry.evaluate(condition, context);
	}
}

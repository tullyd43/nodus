Here’s what I’d do next, aligning to your Feature Development Philosophy (composability, policy‑driven behavior, security by default, observability, and resilience).

Policies and Governance

Register dashboard policies: add system.enable_developer_dashboard and system.developer_dashboard_permission to SystemPolicies with defaults, validators, and descriptions so they’re discoverable and controllable via policy UI.
Standardize feature flags: document and register flags for dev HUD, virtual list, and grid analytics (e.g., ui.enable_virtual_list, grid.enable_analytics) with validators.
Security and Compliance

Signer readiness policy: add security.allow_unsigned_audit_in_dev (default true in dev, false in prod). ForensicLogger uses this to suppress or enforce signatures; switch from debug fallback when policy disallows unsigned.
Action audit hardening: ensure every ActionDispatcher path performs MAC checks, emits structured audit envelopes, and rate‑limits via the is_rate_limited condition.
Performance and Resilience

Metrics wrap, safely: adopt the “optional measure” guard everywhere we decorate methods (storage, renderers, policies). Keep measure unbound‑safe; never block the hot path if metrics are not ready.
Grid init health: keep initialization idempotent; track and emit grid.init_duration and grid.ready events so failures are visible without crashing.
Event bus stability: keep subscriptions on stateManager.on(...) only; avoid engine‑internal APIs for listeners.
Storage and Migrations

IndexedDB migrations: formalize store definitions and version bump history (audit_events, system_settings). Add a dev tool to dump schema and reset stores via a policy or HMR hook.
StorageLoader validations: before handing instances to ModularOfflineStorage, assert required methods (get, put, putBulk). Fail fast with a clear StorageError.
Observability and Diagnostics

Startup pipeline metrics: emit metrics event for bootstrap and per‑module init durations (policies, eventFlow, grid, dashboard). Wire this into MetricsReporter with a “bootstrap” channel.
Error taxonomy: keep ErrorHelpers emitting structured, low‑noise events. Ensure all “expected in dev” messages are debug‑level and once‑only.
UI/UX Composability

VirtualList UX: lazy‑instantiate on visibility (IntersectionObserver). Support optional itemSize: (i) => number for dynamic rows. Expose a small adapter that binds to a selector on HybridState for large lists.
Light reactivity bridge: optional tiny EventBridge hook (in addition to BindEngine) for [data-bind] elements app‑wide; non‑intrusive and policy‑guarded.
Cache Strategy

Invalidation semantics: document supported patterns (prefix, regex). Add a minimal unit test for CacheManager.invalidate and LRUCache.invalidate; ensure we don’t evict unintended namespaces.
Dev Ergonomics

Scoped debug namespace: we already use window.Nodus; extend with a read‑only “capability map” (e.g., { hasSigner, hasIndexedDB, policies: {...} }) to quickly inspect readiness without exposing mutators.
HMR cleanup: we’re already doing disposal; add a noop guard for any remaining late timers (e.g., ForensicLogger flush) on teardown.
Documentation

Update docs around:
New policy keys and their defaults.
The bootstrap lifecycle and idempotency guarantees.
Dev‑only features (HUD, dashboard) and how to enable in staging (policies + permission).
Storage schema and version migration notes.
If you want, I can implement the policy registrations and validators for: